{"version":3,"sources":["../node_modules/jsts/dist/jsts.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B,CAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,UAAU;AACzC;AACA;;AAEA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;;;AAGT;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA,SAAS;AACT;;;AAGA;AACA,oBAAoB;;AAEpB,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;;;AAGf;AACA;AACA,wCAAwC;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT,0BAA0B;AAC1B;AACA;;AAEA,uBAAuB;;AAEvB,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;;AAE3B,uCAAuC;;AAEvC,iDAAiD;AACjD;;AAEA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA,SAAS;;;AAGT;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;;AAGA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,aAAa,UAAU;AACvB;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,WAAW;AACX,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,iDAAiD;AACjD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qEAAqE;AACrE,4BAA4B;AAC5B,8DAA8D;AAC9D;AACA,KAAK;AACL,uDAAuD;AACvD,4CAA4C;AAC5C,iCAAiC;AACjC,mDAAmD;AACnD,4BAA4B;AAC5B,iCAAiC;AACjC,sDAAsD;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,oCAAoC;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,yDAAyD;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;;;AAGA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa,QAAQ;AACrB;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+CAA+C;AAC1F;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iDAAiD;AAC5F;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;;;AAGA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa,wBAAwB;AACrC;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc;AACd;;;AAGA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sCAAsC;AACtC,gCAAgC;AAChC,sDAAsD;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,cAAc;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA,qBAAqB,yCAAyC;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA,yBAAyB,wBAAwB;AACjD;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,0CAA0C;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qCAAqC;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE;;AAEA;AACA,oEAAoE;AACpE;;AAEA;AACA,2FAA2F;AAC3F;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ;;AAER;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,mCAAmC;;AAEnC;AACA,KAAK;;;AAGL;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC,4CAA4C,uCAAuC;AACnF;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,gCAAgC;;;AAGhC;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iHAAiH;;AAEjH,uDAAuD,0BAA0B,IAAI;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA,2DAA2D,SAAS;AACpE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,oEAAoE,SAAS;AAC7E;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,oEAAoE,SAAS;AAC7E;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,gEAAgE,SAAS;AACzE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,6DAA6D,SAAS;AACtE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,6BAA6B;AAC7B,KAAK;AACL;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,sDAAsD;AACtD,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC;AACvC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,QAAQ;AAC9B,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,sBAAsB,QAAQ;AAC9B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,iCAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,wCAAwC;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ,kDAAkD;AACxE;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,+BAA+B;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;;AAGA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,OAAO;AACP,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C,OAAO;AACP,6CAA6C;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA,6GAA6G;;AAE7G;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,yBAAyB,SAAS;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,yBAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,KAAK;AACL;AACA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,uBAAuB;AAC/D;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,gCAAgC;AACrD,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;;AAEL,mBAAmB,OAAO;AAC1B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,OAAO;AAC9B;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iDAAiD;AACjD,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,2FAA2F;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,0CAA0C,cAAc;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qHAAqH;AACrH,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,0CAA0C,aAAa;AACvD;AACA;;AAEA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qDAAqD,wDAAwD,8CAA8C,wDAAwD,6DAA6D,0DAA0D,gEAAgE;AAC1Y,OAAO;AACP,KAAK;AACL;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA,kCAAkC;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,wCAAwC,cAAc;AACtD;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,kDAAkD;AAClD,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,YAAY,wBAAwB;AACpC;AACA;AACA,qGAAqG;AACrG;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,wDAAwD;AACpE;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wDAAwD,aAAa;AACrE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yDAAyD,aAAa;AACtE;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD,aAAa;AACrE;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,+FAA+F,wFAAwF;;AAEvL;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf,kCAAkC,OAAO;AACzC;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,wCAAwC;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,eAAe,cAAc;AAC7B,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA,kBAAkB,aAAa,MAAM,aAAa;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,eAAe;AACf;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,GAAG;AAChB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,wBAAwB;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,wCAAwC;AAC7D;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,2CAA2C;AAChE;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,2BAA2B;AAChD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,uBAAuB;AAC/D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,uBAAuB;AAC/D;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,uEAAuE;AACvE,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT,mCAAmC;AACnC;AACA,OAAO;AACP;AACA,mCAAmC;AACnC,SAAS;AACT,mCAAmC;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD,4BAA4B;AAC5B,+CAA+C;AAC/C,oCAAoC;AACpC,sCAAsC;AACtC,kCAAkC;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,qEAAqE;AACrE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,sDAAsD;AACtD,wDAAwD;AACxD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,+CAA+C,aAAa;AAC5D;;AAEA;;AAEA,8CAA8C,aAAa;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,2CAA2C,aAAa;AACxD;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,2CAA2C,aAAa;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA,iDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mDAAmD,cAAc;AACjE;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,8CAA8C,aAAa;AAC3D;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,oBAAoB;AACpD;AACA;AACA,OAAO;AACP;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,wCAAwC,cAAc;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL,kCAAkC;AAClC;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA,OAAO;AACP,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,QAAQ;AAClC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,mDAAmD,wDAAwD,8CAA8C,wDAAwD,6DAA6D,0DAA0D,gEAAgE;AACxY,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,mFAAmF;AAClK,0CAA0C;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,gCAAgC,cAAc;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA,uCAAuC,aAAa;AACpD;AACA;AACA,KAAK;AACL;AACA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,wFAAwF;AACxF,gCAAgC;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+CAA+C,aAAa;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iDAAiD,aAAa;AAC9D;;AAEA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,sBAAsB;AAC9C,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,qFAAqF;AACrF,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,kBAAkB;AACvC;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD,2BAA2B,uBAAuB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,oBAAoB;AACzC;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,mBAAmB;AACxC;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qDAAqD,aAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,aAAa;AAC7D;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;;AAEA,iEAAiE,cAAc;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,cAAc;AACvD;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;AACA,KAAK;AACL;AACA,mDAAmD,cAAc;AACjE;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA,4DAA4D;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iIAAiI;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,yDAAyD,cAAc;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA,KAAK;AACL;AACA,wCAAwC,cAAc;AACtD;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,8CAA8C,cAAc;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA,yDAAyD,aAAa;AACtE;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,yDAAyD,cAAc;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA,sDAAsD,cAAc;AACpE;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA,KAAK;AACL,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;;AAEA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,4CAA4C,aAAa;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,aAAa;AACxD;AACA,oDAAoD;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA,gDAAgD;AAChD;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,sCAAsC,aAAa;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,aAAa;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa;AACxC;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,oCAAoC,cAAc;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA,uFAAuF;;AAEvF,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,2DAA2D,cAAc;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA,yDAAyD,aAAa;AACtE;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,yDAAyD,aAAa;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA,yDAAyD,aAAa;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;AACA,KAAK;AACL;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;;AAEA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,2BAA2B;AAChD,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+CAA+C,aAAa;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wCAAwC;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA,oFAAoF;AACpF;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,aAAa;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA,6CAA6C;AAC7C;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,+CAA+C;AAC/F;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,mDAAmD,cAAc;AACjE;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,wCAAwC,cAAc;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,oDAAoD,kBAAkB;AACtE;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oDAAoD,kBAAkB;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA,uEAAuE;AACvE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,kBAAkB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,0DAA0D,kBAAkB;AAC5E;;AAEA,gDAAgD,aAAa;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uDAAuD,yDAAyD,yDAAyD,yDAAyD,sDAAsD,2DAA2D,iEAAiE;AACpZ;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,wCAAwC,aAAa;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB,SAAS;AAClC;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,wCAAwC,aAAa;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0CAA0C,aAAa;AACvD;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;;;AAIA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,+FAA+F;AAC/F,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,iCAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,2CAA2C,cAAc;AACzD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;AACA;AACA;;AAEA,iDAAiD,cAAc;AAC/D;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA,OAAO;AACP;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA;AACA,gEAAgE;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,uBAAuB;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,yEAAyE,aAAa;AACtF;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;;AAE9D,CAAC;AACD","file":"scripts.js","sourcesContent":["/**\n * JSTS. See https://github.com/bjornharrtell/jsts\n * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt\n * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt\n * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt\n * @license\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.jsts = {})));\n}(this, (function (exports) { 'use strict';\n\n  /* Polyfill service v3.13.0\n   * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n   *\n   * - Array.prototype.fill, License: CC0 */\n  if (!('fill' in Array.prototype)) {\n    Object.defineProperty(Array.prototype, 'fill', {\n      configurable: true,\n      value: function fill(value) {\n        if (this === undefined || this === null) {\n          throw new TypeError(this + ' is not an object');\n        }\n\n        var arrayLike = Object(this);\n        var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n        var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n        relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n        var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n        relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n        while (relativeStart < relativeEnd) {\n          arrayLike[relativeStart] = value;\n          ++relativeStart;\n        }\n\n        return arrayLike;\n      },\n      writable: true\n    });\n  }\n\n  Number.isFinite = Number.isFinite || function (value) {\n    return typeof value === 'number' && isFinite(value);\n  };\n\n  Number.isInteger = Number.isInteger || function (val) {\n    return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;\n  };\n\n  Number.parseFloat = Number.parseFloat || parseFloat;\n\n  Number.isNaN = Number.isNaN || function (value) {\n    return value !== value; // eslint-disable-line\n  };\n\n  Math.trunc = Math.trunc || function (x) {\n    return x < 0 ? Math.ceil(x) : Math.floor(x);\n  };\n\n  Math.log2 = Math.log2 || function (x) {\n    return Math.log(x) * Math.LOG2E;\n  };\n\n  function extend (target, source) {\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) target[key] = source[key];\n    }\n  }\n\n  function NumberUtil() {}\n  extend(NumberUtil.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NumberUtil;\n    }\n  });\n\n  NumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n    return Math.abs(x1 - x2) <= tolerance;\n  };\n\n  function IllegalArgumentException() {}\n\n  function Long(high, low) {\n    this.low = low | 0;\n    this.high = high | 0;\n  }\n\n  Long.toBinaryString = function (i) {\n    var result = '';\n\n    for (var mask = 0x80000000; mask > 0; mask >>>= 1) {\n      result += (i.high & mask) === mask ? '1' : '0';\n    }\n\n    for (var mask = 0x80000000; mask > 0; mask >>>= 1) {\n      result += (i.low & mask) === mask ? '1' : '0';\n    }\n\n    return result;\n  };\n\n  function Double() {}\n\n  Double.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n\n  Double.isInfinite = function (n) {\n    return !Number.isFinite(n);\n  };\n\n  Double.MAX_VALUE = Number.MAX_VALUE;\n\n  if (typeof Float64Array == 'function' && typeof Int32Array == 'function') {\n    // Simple and fast conversion between double and long bits\n    // using TypedArrays and ArrayViewBuffers.\n    (function () {\n      var EXP_BIT_MASK = 0x7ff00000;\n      var SIGNIF_BIT_MASK = 0xFFFFF;\n      var f64buf = new Float64Array(1);\n      var i32buf = new Int32Array(f64buf.buffer);\n\n      Double.doubleToLongBits = function (value) {\n        f64buf[0] = value;\n        var low = i32buf[0] | 0;\n        var high = i32buf[1] | 0; // Check for NaN based on values of bit fields, maximum\n        // exponent and nonzero significand.\n\n        if ((high & EXP_BIT_MASK) === EXP_BIT_MASK && (high & SIGNIF_BIT_MASK) !== 0 && low !== 0) {\n          low = 0 | 0;\n          high = 0x7ff80000 | 0;\n        }\n\n        return new Long(high, low);\n      };\n\n      Double.longBitsToDouble = function (bits) {\n        i32buf[0] = bits.low;\n        i32buf[1] = bits.high;\n        return f64buf[0];\n      };\n    })();\n  } else {\n    // More complex and slower fallback implementation using \n    // math and the divide-by-two and multiply-by-two algorithms.\n    (function () {\n      var BIAS = 1023;\n      var log2 = Math.log2;\n      var floor = Math.floor;\n      var pow = Math.pow;\n\n      var MAX_REL_BITS_INTEGER = function () {\n        for (var i = 53; i > 0; i--) {\n          var bits = pow(2, i) - 1;\n\n          if (floor(log2(bits)) + 1 === i) {\n            return bits;\n          }\n        }\n\n        return 0;\n      }();\n\n      Double.doubleToLongBits = function (value) {\n        var x, y, f, bits, skip;\n        var sign, exp, high, low; // Get the sign bit and absolute value.\n\n        if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n          sign = 1 << 31;\n          value = -value;\n        } else {\n          sign = 0;\n        } // Handle some special values.\n\n\n        if (value === 0) {\n          // Handle zeros (+/-0).\n          low = 0 | 0;\n          high = sign; // exponent: 00..00, significand: 00..00\n\n          return new Long(high, low);\n        }\n\n        if (value === Infinity) {\n          // Handle infinity (only positive values for value possible).\n          low = 0 | 0;\n          high = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\n          return new Long(high, low);\n        }\n\n        if (value !== value) {\n          // Handle NaNs (boiled down to only one distinct NaN).\n          low = 0 | 0;\n          high = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\n          return new Long(high, low);\n        } // Preinitialize variables, that are not neccessarily set by\n        // the algorithm.\n\n\n        bits = 0;\n        low = 0 | 0; // Get the (always positive) integer part of value.\n\n        x = floor(value); // Process the integer part if it's greater than 1. Zero requires\n        // no bits at all, 1 represents the implicit (hidden) leading bit,\n        // which must not be written as well.\n\n        if (x > 1) {\n          // If we can reliably determine the number of bits required for\n          // the integer part,\n          if (x <= MAX_REL_BITS_INTEGER) {\n            // get the number of bits required to represent it minus 1\n            bits = floor(log2(x))\n            /* + 1 - 1*/\n            ; // and simply copy/shift the integer bits into low and high.\n            // That's much faster than the divide-by-two algorithm (saves\n            // up to ~60%).\n            // We always need to mask out the most significant bit, which\n            // is the implicit (aka hidden) bit.\n\n            if (bits <= 20) {\n              // The simple case in which the integer fits into the\n              // lower 20 bits of the high word is worth to be handled\n              // separately (saves ~25%).\n              low = 0 | 0;\n              high = x << 20 - bits & 0xfffff;\n            } else {\n              // Here, the integer part is split into low and high.\n              // Since its value may require more than 32 bits, we\n              // cannot use bitwise operators (which implicitly cast\n              // to Int32), but use arithmetic operators % and / to\n              // get low and high parts. The uppper 20 bits go to high,\n              // the remaining bits (in f) to low.\n              f = bits - 20; // Like (1 << f) but safe with even more than 32 bits.\n\n              y = pow(2, f);\n              low = x % y << 32 - f;\n              high = x / y & 0xfffff;\n            }\n          } else {\n            // For greater values, we must use the much slower divide-by-two\n            // algorithm. Bits are generated from right to left, that is from\n            // least to most significant bit. For each bit, we left-shift both\n            // low and high by one and carry bit #0 from high to #31 in low.\n            // The next bit is then copied into bit #19 in high, the leftmost\n            // bit of the double's significand.\n            // Preserve x for later user, so work with f.\n            f = x;\n            low = 0 | 0;\n\n            while (true) {\n              y = f / 2;\n              f = floor(y);\n\n              if (f === 0) {\n                // We just found the most signigicant (1-)bit, which\n                // is the implicit bit and so, not stored in the double\n                // value. So, it's time to leave the loop.\n                break;\n              } // Count this bit, shift low and carry bit #0 from high.\n\n\n              bits++;\n              low >>>= 1;\n              low |= (high & 0x1) << 31; // Shift high.\n\n              high >>>= 1;\n\n              if (y !== f) {\n                // Copy the new bit into bit #19 in high (only required if 1).\n                high |= 0x80000;\n              }\n            }\n          }\n        } // Bias the exponent.\n\n\n        exp = bits + BIAS; // If the integer part is zero, we've not yet seen the implicit\n        // leading bit. Variable skip is later used while processing the \n        // fractional part (if any).\n\n        skip = x === 0; // Get fraction only into x.\n\n        x = value - x; // If some significand bits are still left to be filled and\n        // the fractional part is not zero, convert the fraction using\n        // the multiply-by-2 algorithm.\n\n        if (bits < 52 && x !== 0) {\n          // Initialize 'buffer' f, into which newly created bits get\n          // shifted from right to left.\n          f = 0;\n\n          while (true) {\n            y = x * 2;\n\n            if (y >= 1) {\n              // This is a new 1-bit. Add and count this bit, if not\n              // prohibited by skip.\n              x = y - 1;\n\n              if (!skip) {\n                f <<= 1;\n                f |= 1;\n                bits++;\n              } else {\n                // Otherwise, decrement the exponent and unset\n                // skip, so that all following bits get written.\n                exp--;\n                skip = false;\n              }\n            } else {\n              // This is a new 0-bit. Add and count this bit, if not\n              // prohibited by skip.\n              x = y;\n\n              if (!skip) {\n                f <<= 1;\n                bits++;\n              } else if (--exp === 0) {\n                // Otherwise we've just decremented the exponent. If the\n                // biased exponent is zero now (-1023), we process a\n                // subnormal number, which has no impled leading 1-bit.\n                // So, count this 0-bit and unset skip to write out\n                // all the following bits.\n                bits++;\n                skip = false;\n              }\n            }\n\n            if (bits === 20) {\n              // When 20 bits have been created in total, we're done with\n              // the high word. Copy the bits from 'buffer' f into high\n              // and reset 'buffer' f. Following bits will end up in the\n              // low word.\n              high |= f;\n              f = 0;\n            } else if (bits === 52) {\n              // When 52 bits have been created in total, we're done with\n              // low word as well. Copy the bits from 'buffer' f into low\n              // and exit the loop.\n              low |= f;\n              break;\n            }\n\n            if (y === 1) {\n              // When y is exactly 1, there is no remainder and the process\n              // is complete (the number is finite). Copy the bits from\n              // 'buffer' f into either low or high and exit the loop.\n              if (bits < 20) {\n                high |= f << 20 - bits;\n              } else if (bits < 52) {\n                low |= f << 52 - bits;\n              }\n\n              break;\n            }\n          }\n        } // Copy/shift the exponent and sign bits into the high word.\n\n\n        high |= exp << 20;\n        high |= sign;\n        return new Long(high, low);\n      };\n\n      Double.longBitsToDouble = function (bits) {\n        var x, sign, exp, fract;\n        var high = bits.high;\n        var low = bits.low; // Extract the sign.\n\n        sign = high & 1 << 31 ? -1 : 1; // Extract the unbiased exponent.\n\n        exp = ((high & 0x7ff00000) >> 20) - BIAS; // Calculate the fraction from left to right. Start\n        // off with the 20 lower bits from the high word.\n\n        fract = 0;\n        x = 1 << 19;\n\n        for (var i = 1; i <= 20; i++) {\n          if (high & x) {\n            fract += pow(2, -i);\n          }\n\n          x >>>= 1;\n        } // Continue with all 32 bits from the low word.\n\n\n        x = 1 << 31;\n\n        for (var i = 21; i <= 52; i++) {\n          if (low & x) {\n            fract += pow(2, -i);\n          }\n\n          x >>>= 1;\n        } // Handle special values.\n        // Check for zero and subnormal values.\n\n\n        if (exp === -BIAS) {\n          if (fract === 0) {\n            // +/-1.0 * 0.0 => +/-0.0\n            return sign * 0;\n          }\n\n          exp = -1022;\n        } // Check for +/-Infinity or NaN.\n        else if (exp === BIAS + 1) {\n            if (fract === 0) {\n              // +/-1.0 / 0.0 => +/-Infinity\n              return sign / 0;\n            }\n\n            return NaN;\n          } // Nothing special? Seems to be a normal number.\n          else {\n              // Add the implicit leading bit (1*2^0).\n              fract += 1;\n            }\n\n        return sign * fract * pow(2, exp);\n      };\n    })();\n  }\n\n  function Comparable() {}\n\n  function Clonable() {}\n\n  function Comparator() {}\n\n  function Serializable() {}\n\n  function RuntimeException(message) {\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = new Error().stack;\n    Error.call(this, message);\n  }\n  RuntimeException.prototype = Object.create(Error.prototype);\n  RuntimeException.prototype.constructor = Error;\n\n  function inherits (c, p) {\n    c.prototype = Object.create(p.prototype);\n    c.prototype.constructor = c;\n  }\n\n  function AssertionFailedException() {\n    if (arguments.length === 0) {\n      RuntimeException.call(this);\n    } else if (arguments.length === 1) {\n      var message = arguments[0];\n      RuntimeException.call(this, message);\n    }\n  }\n  inherits(AssertionFailedException, RuntimeException);\n  extend(AssertionFailedException.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return AssertionFailedException;\n    }\n  });\n\n  function Assert() {}\n  extend(Assert.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Assert;\n    }\n  });\n\n  Assert.shouldNeverReachHere = function () {\n    if (arguments.length === 0) {\n      Assert.shouldNeverReachHere(null);\n    } else if (arguments.length === 1) {\n      var message = arguments[0];\n      throw new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n    }\n  };\n\n  Assert.isTrue = function () {\n    if (arguments.length === 1) {\n      var assertion = arguments[0];\n      Assert.isTrue(assertion, null);\n    } else if (arguments.length === 2) {\n      var _assertion = arguments[0],\n          message = arguments[1];\n\n      if (!_assertion) {\n        if (message === null) {\n          throw new AssertionFailedException();\n        } else {\n          throw new AssertionFailedException(message);\n        }\n      }\n    }\n  };\n\n  Assert.equals = function () {\n    if (arguments.length === 2) {\n      var expectedValue = arguments[0],\n          actualValue = arguments[1];\n      Assert.equals(expectedValue, actualValue, null);\n    } else if (arguments.length === 3) {\n      var _expectedValue = arguments[0],\n          _actualValue = arguments[1],\n          message = arguments[2];\n\n      if (!_actualValue.equals(_expectedValue)) {\n        throw new AssertionFailedException(\"Expected \" + _expectedValue + \" but encountered \" + _actualValue + (message !== null ? \": \" + message : \"\"));\n      }\n    }\n  };\n\n  function Coordinate() {\n    this.x = null;\n    this.y = null;\n    this.z = null;\n\n    if (arguments.length === 0) {\n      Coordinate.call(this, 0.0, 0.0);\n    } else if (arguments.length === 1) {\n      var c = arguments[0];\n      Coordinate.call(this, c.x, c.y, c.z);\n    } else if (arguments.length === 2) {\n      var x = arguments[0],\n          y = arguments[1];\n      Coordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n    } else if (arguments.length === 3) {\n      var _x = arguments[0],\n          _y = arguments[1],\n          z = arguments[2];\n      this.x = _x;\n      this.y = _y;\n      this.z = z;\n    }\n  }\n  extend(Coordinate.prototype, {\n    setOrdinate: function setOrdinate(ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          this.x = value;\n          break;\n\n        case Coordinate.Y:\n          this.y = value;\n          break;\n\n        case Coordinate.Z:\n          this.z = value;\n          break;\n\n        default:\n          throw new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n      }\n    },\n    equals2D: function equals2D() {\n      if (arguments.length === 1) {\n        var other = arguments[0];\n\n        if (this.x !== other.x) {\n          return false;\n        }\n\n        if (this.y !== other.y) {\n          return false;\n        }\n\n        return true;\n      } else if (arguments.length === 2) {\n        var c = arguments[0],\n            tolerance = arguments[1];\n\n        if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n          return false;\n        }\n\n        if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n          return false;\n        }\n\n        return true;\n      }\n    },\n    getOrdinate: function getOrdinate(ordinateIndex) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          return this.x;\n\n        case Coordinate.Y:\n          return this.y;\n\n        case Coordinate.Z:\n          return this.z;\n      }\n\n      throw new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n    },\n    equals3D: function equals3D(other) {\n      return this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n    },\n    equals: function equals(other) {\n      if (!(other instanceof Coordinate)) {\n        return false;\n      }\n\n      return this.equals2D(other);\n    },\n    equalInZ: function equalInZ(c, tolerance) {\n      return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n    },\n    compareTo: function compareTo(o) {\n      var other = o;\n      if (this.x < other.x) return -1;\n      if (this.x > other.x) return 1;\n      if (this.y < other.y) return -1;\n      if (this.y > other.y) return 1;\n      return 0;\n    },\n    clone: function clone() {\n      try {\n        var coord = null;\n        return coord;\n      } catch (e) {\n        if (e instanceof CloneNotSupportedException) {\n          Assert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n          return null;\n        } else throw e;\n      } finally {}\n    },\n    copy: function copy() {\n      return new Coordinate(this);\n    },\n    toString: function toString() {\n      return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n    },\n    distance3D: function distance3D(c) {\n      var dx = this.x - c.x;\n      var dy = this.y - c.y;\n      var dz = this.z - c.z;\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    },\n    distance: function distance(c) {\n      var dx = this.x - c.x;\n      var dy = this.y - c.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    hashCode: function hashCode() {\n      var result = 17;\n      result = 37 * result + Coordinate.hashCode(this.x);\n      result = 37 * result + Coordinate.hashCode(this.y);\n      return result;\n    },\n    setCoordinate: function setCoordinate(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.z;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable, Clonable, Serializable];\n    },\n    getClass: function getClass() {\n      return Coordinate;\n    }\n  });\n\n  Coordinate.hashCode = function () {\n    if (arguments.length === 1 && typeof arguments[0] === \"number\") {\n      var x = arguments[0];\n      var f = Double.doubleToLongBits(x);\n      return Math.trunc(f ^ f >>> 32);\n    }\n  };\n\n  function DimensionalComparator() {\n    this._dimensionsToTest = 2;\n\n    if (arguments.length === 0) {\n      DimensionalComparator.call(this, 2);\n    } else if (arguments.length === 1) {\n      var dimensionsToTest = arguments[0];\n      if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n      this._dimensionsToTest = dimensionsToTest;\n    }\n  }\n\n  extend(DimensionalComparator.prototype, {\n    compare: function compare(o1, o2) {\n      var c1 = o1;\n      var c2 = o2;\n      var compX = DimensionalComparator.compare(c1.x, c2.x);\n      if (compX !== 0) return compX;\n      var compY = DimensionalComparator.compare(c1.y, c2.y);\n      if (compY !== 0) return compY;\n      if (this._dimensionsToTest <= 2) return 0;\n      var compZ = DimensionalComparator.compare(c1.z, c2.z);\n      return compZ;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return DimensionalComparator;\n    }\n  });\n\n  DimensionalComparator.compare = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (Double.isNaN(a)) {\n      if (Double.isNaN(b)) return 0;\n      return -1;\n    }\n\n    if (Double.isNaN(b)) return 1;\n    return 0;\n  };\n\n  Coordinate.DimensionalComparator = DimensionalComparator;\n  Coordinate.serialVersionUID = 6683108902428366910;\n  Coordinate.NULL_ORDINATE = Double.NaN;\n  Coordinate.X = 0;\n  Coordinate.Y = 1;\n  Coordinate.Z = 2;\n\n  function hasInterface (o, i) {\n    return o.interfaces_ && o.interfaces_().indexOf(i) > -1;\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n   * @constructor\n   * @private\n   */\n  function Iterator() {}\n  /**\n   * Returns true if the iteration has more elements.\n   * @return {boolean}\n   */\n\n  Iterator.prototype.hasNext = function () {};\n  /**\n   * Returns the next element in the iteration.\n   * @return {Object}\n   */\n\n\n  Iterator.prototype.next = function () {};\n  /**\n   * Removes from the underlying collection the last element returned by the\n   * iterator (optional operation).\n   */\n\n\n  Iterator.prototype.remove = function () {};\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n   *\n   * @constructor\n   * @private\n   */\n\n  function Collection() {}\n  /**\n   * Ensures that this collection contains the specified element (optional\n   * operation).\n   * @param {Object} e\n   * @return {boolean}\n   */\n\n  Collection.prototype.add = function () {};\n  /**\n   * Appends all of the elements in the specified collection to the end of this\n   * list, in the order that they are returned by the specified collection's\n   * iterator (optional operation).\n   * @param {javascript.util.Collection} c\n   * @return {boolean}\n   */\n\n\n  Collection.prototype.addAll = function () {};\n  /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */\n\n\n  Collection.prototype.isEmpty = function () {};\n  /**\n   * Returns an iterator over the elements in this collection.\n   * @return {javascript.util.Iterator}\n   */\n\n\n  Collection.prototype.iterator = function () {};\n  /**\n   * Returns an iterator over the elements in this collection.\n   * @return {number}\n   */\n\n\n  Collection.prototype.size = function () {};\n  /**\n   * Returns an array containing all of the elements in this collection.\n   * @return {Array}\n   */\n\n\n  Collection.prototype.toArray = function () {};\n  /**\n   * Removes a single instance of the specified element from this collection if it\n   * is present. (optional)\n   * @param {Object} e\n   * @return {boolean}\n   */\n\n\n  Collection.prototype.remove = function () {};\n\n  /**\n   * @param {string=} message Optional message\n   * @extends {Error}\n   * @constructor\n   * @private\n   */\n  function IndexOutOfBoundsException$1(message) {\n    this.message = message || '';\n  }\n  IndexOutOfBoundsException$1.prototype = new Error();\n  /**\n   * @type {string}\n   */\n\n  IndexOutOfBoundsException$1.prototype.name = 'IndexOutOfBoundsException';\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n   *\n   * @extends {javascript.util.Collection}\n   * @constructor\n   * @private\n   */\n\n  function List() {}\n  List.prototype = Object.create(Collection.prototype);\n  List.prototype.constructor = List;\n  /**\n   * Returns the element at the specified position in this list.\n   * @param {number} index\n   * @return {Object}\n   */\n\n  List.prototype.get = function () {};\n  /**\n   * Replaces the element at the specified position in this list with the\n   * specified element (optional operation).\n   * @param {number} index\n   * @param {Object} e\n   * @return {Object}\n   */\n\n\n  List.prototype.set = function () {};\n  /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */\n\n\n  List.prototype.isEmpty = function () {};\n\n  /**\n   * @param {string=} message Optional message\n   * @extends {Error}\n   * @constructor\n   * @private\n   */\n  function NoSuchElementException(message) {\n    this.message = message || '';\n  }\n  NoSuchElementException.prototype = new Error();\n  /**\n   * @type {string}\n   */\n\n  NoSuchElementException.prototype.name = 'NoSuchElementException';\n\n  /**\n   * @param {string=} message Optional message\n   * @extends {Error}\n   * @constructor\n   * @private\n   */\n  function OperationNotSupported(message) {\n    this.message = message || '';\n  }\n  OperationNotSupported.prototype = new Error();\n  /**\n   * @type {string}\n   */\n\n  OperationNotSupported.prototype.name = 'OperationNotSupported';\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n   *\n   * @extends List\n   * @private\n   */\n\n  function ArrayList() {\n    /**\n     * @type {Array}\n     * @private\n    */\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n  ArrayList.prototype = Object.create(List.prototype);\n  ArrayList.prototype.constructor = ArrayList;\n\n  ArrayList.prototype.ensureCapacity = function () {};\n\n  ArrayList.prototype.interfaces_ = function () {\n    return [List, Collection];\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.add = function (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], 0, arguments[1]);\n    }\n\n    return true;\n  };\n\n  ArrayList.prototype.clear = function () {\n    this.array_ = [];\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.set = function (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement;\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.iterator = function () {\n    return new Iterator_(this);\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException$1();\n    }\n\n    return this.array_[index];\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.size = function () {\n    return this.array_.length;\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n\n    return array;\n  };\n  /**\n   * @override\n   */\n\n\n  ArrayList.prototype.remove = function (o) {\n    var found = false;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this.array_[i] === o) {\n        this.array_.splice(i, 1);\n        found = true;\n        break;\n      }\n    }\n\n    return found;\n  };\n\n  ArrayList.prototype.removeAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.remove(i.next());\n    }\n\n    return true;\n  };\n  /**\n   * @extends {Iterator}\n   * @param {ArrayList} arrayList\n   * @constructor\n   * @private\n   */\n\n\n  var Iterator_ = function Iterator_(arrayList) {\n    /**\n     * @type {ArrayList}\n     * @private\n    */\n    this.arrayList_ = arrayList;\n    /**\n     * @type {number}\n     * @private\n    */\n\n    this.position_ = 0;\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_.prototype.next = function () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException();\n    }\n\n    return this.arrayList_.get(this.position_++);\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_.prototype.hasNext = function () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * TODO: should be in ListIterator\n   * @override\n   */\n\n\n  Iterator_.prototype.set = function (element) {\n    return this.arrayList_.set(this.position_ - 1, element);\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_.prototype.remove = function () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  function CoordinateList() {\n    ArrayList.apply(this);\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var coord = arguments[0];\n      this.ensureCapacity(coord.length);\n      this.add(coord, true);\n    } else if (arguments.length === 2) {\n      var _coord = arguments[0],\n          allowRepeated = arguments[1];\n      this.ensureCapacity(_coord.length);\n      this.add(_coord, allowRepeated);\n    }\n  }\n  inherits(CoordinateList, ArrayList);\n  extend(CoordinateList.prototype, {\n    getCoordinate: function getCoordinate(i) {\n      return this.get(i);\n    },\n    addAll: function addAll() {\n      if (arguments.length === 2 && typeof arguments[1] === \"boolean\" && hasInterface(arguments[0], Collection)) {\n        var coll = arguments[0],\n            allowRepeated = arguments[1];\n        var isChanged = false;\n\n        for (var i = coll.iterator(); i.hasNext();) {\n          this.add(i.next(), allowRepeated);\n          isChanged = true;\n        }\n\n        return isChanged;\n      } else return ArrayList.prototype.addAll.apply(this, arguments);\n    },\n    clone: function clone() {\n      var clone = ArrayList.prototype.clone.call(this);\n\n      for (var i = 0; i < this.size(); i++) {\n        clone.add(i, this.get(i).clone());\n      }\n\n      return clone;\n    },\n    toCoordinateArray: function toCoordinateArray() {\n      return this.toArray(CoordinateList.coordArrayType);\n    },\n    add: function add() {\n      if (arguments.length === 1) {\n        var coord = arguments[0];\n        ArrayList.prototype.add.call(this, coord);\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n          var _coord2 = arguments[0],\n              allowRepeated = arguments[1];\n          this.add(_coord2, allowRepeated, true);\n          return true;\n        } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n          var _coord3 = arguments[0],\n              _allowRepeated = arguments[1];\n\n          if (!_allowRepeated) {\n            if (this.size() >= 1) {\n              var last = this.get(this.size() - 1);\n              if (last.equals2D(_coord3)) return null;\n            }\n          }\n\n          ArrayList.prototype.add.call(this, _coord3);\n        } else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n          var obj = arguments[0],\n              _allowRepeated2 = arguments[1];\n          this.add(obj, _allowRepeated2);\n          return true;\n        }\n      } else if (arguments.length === 3) {\n        if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n          var _coord4 = arguments[0],\n              _allowRepeated3 = arguments[1],\n              direction = arguments[2];\n\n          if (direction) {\n            for (var i = 0; i < _coord4.length; i++) {\n              this.add(_coord4[i], _allowRepeated3);\n            }\n          } else {\n            for (var i = _coord4.length - 1; i >= 0; i--) {\n              this.add(_coord4[i], _allowRepeated3);\n            }\n          }\n\n          return true;\n        } else if (typeof arguments[2] === \"boolean\" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n          var _i = arguments[0],\n              _coord5 = arguments[1],\n              _allowRepeated4 = arguments[2];\n\n          if (!_allowRepeated4) {\n            var size = this.size();\n\n            if (size > 0) {\n              if (_i > 0) {\n                var prev = this.get(_i - 1);\n                if (prev.equals2D(_coord5)) return null;\n              }\n\n              if (_i < size) {\n                var next = this.get(_i);\n                if (next.equals2D(_coord5)) return null;\n              }\n            }\n          }\n\n          ArrayList.prototype.add.call(this, _i, _coord5);\n        }\n      } else if (arguments.length === 4) {\n        var _coord6 = arguments[0],\n            _allowRepeated5 = arguments[1],\n            start = arguments[2],\n            end = arguments[3];\n        var inc = 1;\n        if (start > end) inc = -1;\n\n        for (var i = start; i !== end; i += inc) {\n          this.add(_coord6[i], _allowRepeated5);\n        }\n\n        return true;\n      }\n    },\n    closeRing: function closeRing() {\n      if (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateList;\n    }\n  });\n  CoordinateList.coordArrayType = new Array(0).fill(null);\n\n  function Envelope() {\n    this._minx = null;\n    this._maxx = null;\n    this._miny = null;\n    this._maxy = null;\n\n    if (arguments.length === 0) {\n      this.init();\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        this.init(p.x, p.x, p.y, p.y);\n      } else if (arguments[0] instanceof Envelope) {\n        var env = arguments[0];\n        this.init(env);\n      }\n    } else if (arguments.length === 2) {\n      var p1 = arguments[0],\n          p2 = arguments[1];\n      this.init(p1.x, p2.x, p1.y, p2.y);\n    } else if (arguments.length === 4) {\n      var x1 = arguments[0],\n          x2 = arguments[1],\n          y1 = arguments[2],\n          y2 = arguments[3];\n      this.init(x1, x2, y1, y2);\n    }\n  }\n  extend(Envelope.prototype, {\n    getArea: function getArea() {\n      return this.getWidth() * this.getHeight();\n    },\n    equals: function equals(other) {\n      if (!(other instanceof Envelope)) {\n        return false;\n      }\n\n      var otherEnvelope = other;\n\n      if (this.isNull()) {\n        return otherEnvelope.isNull();\n      }\n\n      return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n    },\n    intersection: function intersection(env) {\n      if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n      var intMinX = this._minx > env._minx ? this._minx : env._minx;\n      var intMinY = this._miny > env._miny ? this._miny : env._miny;\n      var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n      var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n      return new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n    },\n    isNull: function isNull() {\n      return this._maxx < this._minx;\n    },\n    getMaxX: function getMaxX() {\n      return this._maxx;\n    },\n    covers: function covers() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          return this.covers(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          var other = arguments[0];\n\n          if (this.isNull() || other.isNull()) {\n            return false;\n          }\n\n          return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n        }\n      } else if (arguments.length === 2) {\n        var x = arguments[0],\n            y = arguments[1];\n        if (this.isNull()) return false;\n        return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n      }\n    },\n    intersects: function intersects() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n          var other = arguments[0];\n\n          if (this.isNull() || other.isNull()) {\n            return false;\n          }\n\n          return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n        } else if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          return this.intersects(p.x, p.y);\n        }\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n          var a = arguments[0],\n              b = arguments[1];\n\n          if (this.isNull()) {\n            return false;\n          }\n\n          var envminx = a.x < b.x ? a.x : b.x;\n          if (envminx > this._maxx) return false;\n          var envmaxx = a.x > b.x ? a.x : b.x;\n          if (envmaxx < this._minx) return false;\n          var envminy = a.y < b.y ? a.y : b.y;\n          if (envminy > this._maxy) return false;\n          var envmaxy = a.y > b.y ? a.y : b.y;\n          if (envmaxy < this._miny) return false;\n          return true;\n        } else if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n          var x = arguments[0],\n              y = arguments[1];\n          if (this.isNull()) return false;\n          return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n        }\n      }\n    },\n    getMinY: function getMinY() {\n      return this._miny;\n    },\n    getMinX: function getMinX() {\n      return this._minx;\n    },\n    expandToInclude: function expandToInclude() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          this.expandToInclude(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          var other = arguments[0];\n\n          if (other.isNull()) {\n            return null;\n          }\n\n          if (this.isNull()) {\n            this._minx = other.getMinX();\n            this._maxx = other.getMaxX();\n            this._miny = other.getMinY();\n            this._maxy = other.getMaxY();\n          } else {\n            if (other._minx < this._minx) {\n              this._minx = other._minx;\n            }\n\n            if (other._maxx > this._maxx) {\n              this._maxx = other._maxx;\n            }\n\n            if (other._miny < this._miny) {\n              this._miny = other._miny;\n            }\n\n            if (other._maxy > this._maxy) {\n              this._maxy = other._maxy;\n            }\n          }\n        }\n      } else if (arguments.length === 2) {\n        var x = arguments[0],\n            y = arguments[1];\n\n        if (this.isNull()) {\n          this._minx = x;\n          this._maxx = x;\n          this._miny = y;\n          this._maxy = y;\n        } else {\n          if (x < this._minx) {\n            this._minx = x;\n          }\n\n          if (x > this._maxx) {\n            this._maxx = x;\n          }\n\n          if (y < this._miny) {\n            this._miny = y;\n          }\n\n          if (y > this._maxy) {\n            this._maxy = y;\n          }\n        }\n      }\n    },\n    minExtent: function minExtent() {\n      if (this.isNull()) return 0.0;\n      var w = this.getWidth();\n      var h = this.getHeight();\n      if (w < h) return w;\n      return h;\n    },\n    getWidth: function getWidth() {\n      if (this.isNull()) {\n        return 0;\n      }\n\n      return this._maxx - this._minx;\n    },\n    compareTo: function compareTo(o) {\n      var env = o;\n\n      if (this.isNull()) {\n        if (env.isNull()) return 0;\n        return -1;\n      } else {\n        if (env.isNull()) return 1;\n      }\n\n      if (this._minx < env._minx) return -1;\n      if (this._minx > env._minx) return 1;\n      if (this._miny < env._miny) return -1;\n      if (this._miny > env._miny) return 1;\n      if (this._maxx < env._maxx) return -1;\n      if (this._maxx > env._maxx) return 1;\n      if (this._maxy < env._maxy) return -1;\n      if (this._maxy > env._maxy) return 1;\n      return 0;\n    },\n    translate: function translate(transX, transY) {\n      if (this.isNull()) {\n        return null;\n      }\n\n      this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n    },\n    toString: function toString() {\n      return \"Env[\" + this._minx + \" : \" + this._maxx + \", \" + this._miny + \" : \" + this._maxy + \"]\";\n    },\n    setToNull: function setToNull() {\n      this._minx = 0;\n      this._maxx = -1;\n      this._miny = 0;\n      this._maxy = -1;\n    },\n    getHeight: function getHeight() {\n      if (this.isNull()) {\n        return 0;\n      }\n\n      return this._maxy - this._miny;\n    },\n    maxExtent: function maxExtent() {\n      if (this.isNull()) return 0.0;\n      var w = this.getWidth();\n      var h = this.getHeight();\n      if (w > h) return w;\n      return h;\n    },\n    expandBy: function expandBy() {\n      if (arguments.length === 1) {\n        var distance = arguments[0];\n        this.expandBy(distance, distance);\n      } else if (arguments.length === 2) {\n        var deltaX = arguments[0],\n            deltaY = arguments[1];\n        if (this.isNull()) return null;\n        this._minx -= deltaX;\n        this._maxx += deltaX;\n        this._miny -= deltaY;\n        this._maxy += deltaY;\n        if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n      }\n    },\n    contains: function contains() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n          var other = arguments[0];\n          return this.covers(other);\n        } else if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          return this.covers(p);\n        }\n      } else if (arguments.length === 2) {\n        var x = arguments[0],\n            y = arguments[1];\n        return this.covers(x, y);\n      }\n    },\n    centre: function centre() {\n      if (this.isNull()) return null;\n      return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n    },\n    init: function init() {\n      if (arguments.length === 0) {\n        this.setToNull();\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          this.init(p.x, p.x, p.y, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          var env = arguments[0];\n          this._minx = env._minx;\n          this._maxx = env._maxx;\n          this._miny = env._miny;\n          this._maxy = env._maxy;\n        }\n      } else if (arguments.length === 2) {\n        var p1 = arguments[0],\n            p2 = arguments[1];\n        this.init(p1.x, p2.x, p1.y, p2.y);\n      } else if (arguments.length === 4) {\n        var x1 = arguments[0],\n            x2 = arguments[1],\n            y1 = arguments[2],\n            y2 = arguments[3];\n\n        if (x1 < x2) {\n          this._minx = x1;\n          this._maxx = x2;\n        } else {\n          this._minx = x2;\n          this._maxx = x1;\n        }\n\n        if (y1 < y2) {\n          this._miny = y1;\n          this._maxy = y2;\n        } else {\n          this._miny = y2;\n          this._maxy = y1;\n        }\n      }\n    },\n    getMaxY: function getMaxY() {\n      return this._maxy;\n    },\n    distance: function distance(env) {\n      if (this.intersects(env)) return 0;\n      var dx = 0.0;\n      if (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n      var dy = 0.0;\n      if (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n      if (dx === 0.0) return dy;\n      if (dy === 0.0) return dx;\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n    hashCode: function hashCode() {\n      var result = 17;\n      result = 37 * result + Coordinate.hashCode(this._minx);\n      result = 37 * result + Coordinate.hashCode(this._maxx);\n      result = 37 * result + Coordinate.hashCode(this._miny);\n      result = 37 * result + Coordinate.hashCode(this._maxy);\n      return result;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable, Serializable];\n    },\n    getClass: function getClass() {\n      return Envelope;\n    }\n  });\n\n  Envelope.intersects = function () {\n    if (arguments.length === 3) {\n      var p1 = arguments[0],\n          p2 = arguments[1],\n          q = arguments[2];\n\n      if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {\n        return true;\n      }\n\n      return false;\n    } else if (arguments.length === 4) {\n      var _p = arguments[0],\n          _p2 = arguments[1],\n          q1 = arguments[2],\n          q2 = arguments[3];\n      var minq = Math.min(q1.x, q2.x);\n      var maxq = Math.max(q1.x, q2.x);\n      var minp = Math.min(_p.x, _p2.x);\n      var maxp = Math.max(_p.x, _p2.x);\n      if (minp > maxq) return false;\n      if (maxp < minq) return false;\n      minq = Math.min(q1.y, q2.y);\n      maxq = Math.max(q1.y, q2.y);\n      minp = Math.min(_p.y, _p2.y);\n      maxp = Math.max(_p.y, _p2.y);\n      if (minp > maxq) return false;\n      if (maxp < minq) return false;\n      return true;\n    }\n  };\n\n  Envelope.serialVersionUID = 5873921885273102420;\n\n  function Exception() {}\n\n  function NotRepresentableException() {\n    Exception.call(this, \"Projective point not representable on the Cartesian plane.\");\n  }\n  inherits(NotRepresentableException, Exception);\n  extend(NotRepresentableException.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NotRepresentableException;\n    }\n  });\n\n  function StringBuffer(str) {\n    this.str = str;\n  }\n\n  StringBuffer.prototype.append = function (e) {\n    this.str += e;\n  };\n\n  StringBuffer.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n  };\n\n  StringBuffer.prototype.toString = function (e) {\n    return this.str;\n  };\n\n  function Integer(value) {\n    this.value = value;\n  }\n\n  Integer.prototype.intValue = function () {\n    return this.value;\n  };\n\n  Integer.prototype.compareTo = function (o) {\n    if (this.value < o) return -1;\n    if (this.value > o) return 1;\n    return 0;\n  };\n\n  Integer.isNaN = function (n) {\n    return Number.isNaN(n);\n  };\n\n  function Character() {}\n\n  Character.isWhitespace = function (c) {\n    return c <= 32 && c >= 0 || c == 127;\n  };\n\n  Character.toUpperCase = function (c) {\n    return c.toUpperCase();\n  };\n\n  function DD() {\n    this._hi = 0.0;\n    this._lo = 0.0;\n\n    if (arguments.length === 0) {\n      this.init(0.0);\n    } else if (arguments.length === 1) {\n      if (typeof arguments[0] === \"number\") {\n        var x = arguments[0];\n        this.init(x);\n      } else if (arguments[0] instanceof DD) {\n        var dd = arguments[0];\n        this.init(dd);\n      } else if (typeof arguments[0] === \"string\") {\n        var str = arguments[0];\n        DD.call(this, DD.parse(str));\n      }\n    } else if (arguments.length === 2) {\n      var hi = arguments[0],\n          lo = arguments[1];\n      this.init(hi, lo);\n    }\n  }\n  extend(DD.prototype, {\n    le: function le(y) {\n      return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n    },\n    extractSignificantDigits: function extractSignificantDigits(insertDecimalPoint, magnitude) {\n      var y = this.abs();\n      var mag = DD.magnitude(y._hi);\n      var scale = DD.TEN.pow(mag);\n      y = y.divide(scale);\n\n      if (y.gt(DD.TEN)) {\n        y = y.divide(DD.TEN);\n        mag += 1;\n      } else if (y.lt(DD.ONE)) {\n        y = y.multiply(DD.TEN);\n        mag -= 1;\n      }\n\n      var decimalPointPos = mag + 1;\n      var buf = new StringBuffer();\n      var numDigits = DD.MAX_PRINT_DIGITS - 1;\n\n      for (var i = 0; i <= numDigits; i++) {\n        if (insertDecimalPoint && i === decimalPointPos) {\n          buf.append('.');\n        }\n\n        var digit = Math.trunc(y._hi);\n\n        if (digit < 0) {\n          break;\n        }\n\n        var rebiasBy10 = false;\n        var digitChar = 0;\n\n        if (digit > 9) {\n          rebiasBy10 = true;\n          digitChar = '9';\n        } else {\n          digitChar = '0' + digit;\n        }\n\n        buf.append(digitChar);\n        y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n        if (rebiasBy10) y.selfAdd(DD.TEN);\n        var continueExtractingDigits = true;\n        var remMag = DD.magnitude(y._hi);\n        if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n        if (!continueExtractingDigits) break;\n      }\n\n      magnitude[0] = mag;\n      return buf.toString();\n    },\n    sqr: function sqr() {\n      return this.multiply(this);\n    },\n    doubleValue: function doubleValue() {\n      return this._hi + this._lo;\n    },\n    subtract: function subtract() {\n      if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        return this.add(y.negate());\n      } else if (typeof arguments[0] === \"number\") {\n        var _y = arguments[0];\n        return this.add(-_y);\n      }\n    },\n    equals: function equals() {\n      if (arguments.length === 1 && arguments[0] instanceof DD) {\n        var y = arguments[0];\n        return this._hi === y._hi && this._lo === y._lo;\n      }\n    },\n    isZero: function isZero() {\n      return this._hi === 0.0 && this._lo === 0.0;\n    },\n    selfSubtract: function selfSubtract() {\n      if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        if (this.isNaN()) return this;\n        return this.selfAdd(-y._hi, -y._lo);\n      } else if (typeof arguments[0] === \"number\") {\n        var _y2 = arguments[0];\n        if (this.isNaN()) return this;\n        return this.selfAdd(-_y2, 0.0);\n      }\n    },\n    getSpecialNumberString: function getSpecialNumberString() {\n      if (this.isZero()) return \"0.0\";\n      if (this.isNaN()) return \"NaN \";\n      return null;\n    },\n    min: function min(x) {\n      if (this.le(x)) {\n        return this;\n      } else {\n        return x;\n      }\n    },\n    selfDivide: function selfDivide() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          var y = arguments[0];\n          return this.selfDivide(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n          var _y3 = arguments[0];\n          return this.selfDivide(_y3, 0.0);\n        }\n      } else if (arguments.length === 2) {\n        var yhi = arguments[0],\n            ylo = arguments[1];\n        var hc = null,\n            tc = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null,\n            U = null,\n            u = null;\n        C = this._hi / yhi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * yhi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - yhi;\n        U = C * yhi;\n        hy = u - hy;\n        ty = yhi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n        u = C + c;\n        this._hi = u;\n        this._lo = C - u + c;\n        return this;\n      }\n    },\n    dump: function dump() {\n      return \"DD<\" + this._hi + \", \" + this._lo + \">\";\n    },\n    divide: function divide() {\n      if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        var hc = null,\n            tc = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null,\n            U = null,\n            u = null;\n        C = this._hi / y._hi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * y._hi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - y._hi;\n        U = C * y._hi;\n        hy = u - hy;\n        ty = y._hi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n        u = C + c;\n        var zhi = u;\n        var zlo = C - u + c;\n        return new DD(zhi, zlo);\n      } else if (typeof arguments[0] === \"number\") {\n        var _y4 = arguments[0];\n        if (Double.isNaN(_y4)) return DD.createNaN();\n        return DD.copy(this).selfDivide(_y4, 0.0);\n      }\n    },\n    ge: function ge(y) {\n      return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n    },\n    pow: function pow(exp) {\n      if (exp === 0.0) return DD.valueOf(1.0);\n      var r = new DD(this);\n      var s = DD.valueOf(1.0);\n      var n = Math.abs(exp);\n\n      if (n > 1) {\n        while (n > 0) {\n          if (n % 2 === 1) {\n            s.selfMultiply(r);\n          }\n\n          n /= 2;\n          if (n > 0) r = r.sqr();\n        }\n      } else {\n        s = r;\n      }\n\n      if (exp < 0) return s.reciprocal();\n      return s;\n    },\n    ceil: function ceil() {\n      if (this.isNaN()) return DD.NaN;\n      var fhi = Math.ceil(this._hi);\n      var flo = 0.0;\n\n      if (fhi === this._hi) {\n        flo = Math.ceil(this._lo);\n      }\n\n      return new DD(fhi, flo);\n    },\n    compareTo: function compareTo(o) {\n      var other = o;\n      if (this._hi < other._hi) return -1;\n      if (this._hi > other._hi) return 1;\n      if (this._lo < other._lo) return -1;\n      if (this._lo > other._lo) return 1;\n      return 0;\n    },\n    rint: function rint() {\n      if (this.isNaN()) return this;\n      var plus5 = this.add(0.5);\n      return plus5.floor();\n    },\n    setValue: function setValue() {\n      if (arguments[0] instanceof DD) {\n        var value = arguments[0];\n        this.init(value);\n        return this;\n      } else if (typeof arguments[0] === \"number\") {\n        var _value = arguments[0];\n        this.init(_value);\n        return this;\n      }\n    },\n    max: function max(x) {\n      if (this.ge(x)) {\n        return this;\n      } else {\n        return x;\n      }\n    },\n    sqrt: function sqrt() {\n      if (this.isZero()) return DD.valueOf(0.0);\n\n      if (this.isNegative()) {\n        return DD.NaN;\n      }\n\n      var x = 1.0 / Math.sqrt(this._hi);\n      var ax = this._hi * x;\n      var axdd = DD.valueOf(ax);\n      var diffSq = this.subtract(axdd.sqr());\n      var d2 = diffSq._hi * (x * 0.5);\n      return axdd.add(d2);\n    },\n    selfAdd: function selfAdd() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          var y = arguments[0];\n          return this.selfAdd(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n          var _y5 = arguments[0];\n          var H = null,\n              h = null,\n              S = null,\n              s = null,\n              e = null,\n              f = null;\n          S = this._hi + _y5;\n          e = S - this._hi;\n          s = S - e;\n          s = _y5 - e + (this._hi - s);\n          f = s + this._lo;\n          H = S + f;\n          h = f + (S - H);\n          this._hi = H + h;\n          this._lo = h + (H - this._hi);\n          return this;\n        }\n      } else if (arguments.length === 2) {\n        var yhi = arguments[0],\n            ylo = arguments[1];\n        var H = null,\n            h = null,\n            T = null,\n            t = null,\n            S = null,\n            s = null,\n            e = null,\n            f = null;\n        S = this._hi + yhi;\n        T = this._lo + ylo;\n        e = S - this._hi;\n        f = T - this._lo;\n        s = S - e;\n        t = T - f;\n        s = yhi - e + (this._hi - s);\n        t = ylo - f + (this._lo - t);\n        e = s + T;\n        H = S + e;\n        h = e + (S - H);\n        e = t + h;\n        var zhi = H + e;\n        var zlo = e + (H - zhi);\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n      }\n    },\n    selfMultiply: function selfMultiply() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          var y = arguments[0];\n          return this.selfMultiply(y._hi, y._lo);\n        } else if (typeof arguments[0] === \"number\") {\n          var _y6 = arguments[0];\n          return this.selfMultiply(_y6, 0.0);\n        }\n      } else if (arguments.length === 2) {\n        var yhi = arguments[0],\n            ylo = arguments[1];\n        var hx = null,\n            tx = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null;\n        C = DD.SPLIT * this._hi;\n        hx = C - this._hi;\n        c = DD.SPLIT * yhi;\n        hx = C - hx;\n        tx = this._hi - hx;\n        hy = c - yhi;\n        C = this._hi * yhi;\n        hy = c - hy;\n        ty = yhi - hy;\n        c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n        var zhi = C + c;\n        hx = C - zhi;\n        var zlo = c + hx;\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n      }\n    },\n    selfSqr: function selfSqr() {\n      return this.selfMultiply(this);\n    },\n    floor: function floor() {\n      if (this.isNaN()) return DD.NaN;\n      var fhi = Math.floor(this._hi);\n      var flo = 0.0;\n\n      if (fhi === this._hi) {\n        flo = Math.floor(this._lo);\n      }\n\n      return new DD(fhi, flo);\n    },\n    negate: function negate() {\n      if (this.isNaN()) return this;\n      return new DD(-this._hi, -this._lo);\n    },\n    clone: function clone() {\n      try {\n        return null;\n      } catch (ex) {\n        if (ex instanceof CloneNotSupportedException) {\n          return null;\n        } else throw ex;\n      } finally {}\n    },\n    multiply: function multiply() {\n      if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        if (y.isNaN()) return DD.createNaN();\n        return DD.copy(this).selfMultiply(y);\n      } else if (typeof arguments[0] === \"number\") {\n        var _y7 = arguments[0];\n        if (Double.isNaN(_y7)) return DD.createNaN();\n        return DD.copy(this).selfMultiply(_y7, 0.0);\n      }\n    },\n    isNaN: function isNaN() {\n      return Double.isNaN(this._hi);\n    },\n    intValue: function intValue() {\n      return Math.trunc(this._hi);\n    },\n    toString: function toString() {\n      var mag = DD.magnitude(this._hi);\n      if (mag >= -3 && mag <= 20) return this.toStandardNotation();\n      return this.toSciNotation();\n    },\n    toStandardNotation: function toStandardNotation() {\n      var specialStr = this.getSpecialNumberString();\n      if (specialStr !== null) return specialStr;\n      var magnitude = new Array(1).fill(null);\n      var sigDigits = this.extractSignificantDigits(true, magnitude);\n      var decimalPointPos = magnitude[0] + 1;\n      var num = sigDigits;\n\n      if (sigDigits.charAt(0) === '.') {\n        num = \"0\" + sigDigits;\n      } else if (decimalPointPos < 0) {\n        num = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n      } else if (sigDigits.indexOf('.') === -1) {\n        var numZeroes = decimalPointPos - sigDigits.length;\n        var zeroes = DD.stringOfChar('0', numZeroes);\n        num = sigDigits + zeroes + \".0\";\n      }\n\n      if (this.isNegative()) return \"-\" + num;\n      return num;\n    },\n    reciprocal: function reciprocal() {\n      var hc = null,\n          tc = null,\n          hy = null,\n          ty = null,\n          C = null,\n          c = null,\n          U = null,\n          u = null;\n      C = 1.0 / this._hi;\n      c = DD.SPLIT * C;\n      hc = c - C;\n      u = DD.SPLIT * this._hi;\n      hc = c - hc;\n      tc = C - hc;\n      hy = u - this._hi;\n      U = C * this._hi;\n      hy = u - hy;\n      ty = this._hi - hy;\n      u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n      c = (1.0 - U - u - C * this._lo) / this._hi;\n      var zhi = C + c;\n      var zlo = C - zhi + c;\n      return new DD(zhi, zlo);\n    },\n    toSciNotation: function toSciNotation() {\n      if (this.isZero()) return DD.SCI_NOT_ZERO;\n      var specialStr = this.getSpecialNumberString();\n      if (specialStr !== null) return specialStr;\n      var magnitude = new Array(1).fill(null);\n      var digits = this.extractSignificantDigits(false, magnitude);\n      var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\n      if (digits.charAt(0) === '0') {\n        throw new IllegalStateException(\"Found leading zero: \" + digits);\n      }\n\n      var trailingDigits = \"\";\n      if (digits.length > 1) trailingDigits = digits.substring(1);\n      var digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n      if (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n      return digitsWithDecimal + expStr;\n    },\n    abs: function abs() {\n      if (this.isNaN()) return DD.NaN;\n      if (this.isNegative()) return this.negate();\n      return new DD(this);\n    },\n    isPositive: function isPositive() {\n      return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n    },\n    lt: function lt(y) {\n      return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n    },\n    add: function add() {\n      if (arguments[0] instanceof DD) {\n        var y = arguments[0];\n        return DD.copy(this).selfAdd(y);\n      } else if (typeof arguments[0] === \"number\") {\n        var _y8 = arguments[0];\n        return DD.copy(this).selfAdd(_y8);\n      }\n    },\n    init: function init() {\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n          var x = arguments[0];\n          this._hi = x;\n          this._lo = 0.0;\n        } else if (arguments[0] instanceof DD) {\n          var dd = arguments[0];\n          this._hi = dd._hi;\n          this._lo = dd._lo;\n        }\n      } else if (arguments.length === 2) {\n        var hi = arguments[0],\n            lo = arguments[1];\n        this._hi = hi;\n        this._lo = lo;\n      }\n    },\n    gt: function gt(y) {\n      return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n    },\n    isNegative: function isNegative() {\n      return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n    },\n    trunc: function trunc() {\n      if (this.isNaN()) return DD.NaN;\n      if (this.isPositive()) return this.floor();else return this.ceil();\n    },\n    signum: function signum() {\n      if (this._hi > 0) return 1;\n      if (this._hi < 0) return -1;\n      if (this._lo > 0) return 1;\n      if (this._lo < 0) return -1;\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable, Comparable, Clonable];\n    },\n    getClass: function getClass() {\n      return DD;\n    }\n  });\n\n  DD.sqr = function (x) {\n    return DD.valueOf(x).selfMultiply(x);\n  };\n\n  DD.valueOf = function () {\n    if (typeof arguments[0] === \"string\") {\n      var str = arguments[0];\n      return DD.parse(str);\n    } else if (typeof arguments[0] === \"number\") {\n      var x = arguments[0];\n      return new DD(x);\n    }\n  };\n\n  DD.sqrt = function (x) {\n    return DD.valueOf(x).sqrt();\n  };\n\n  DD.parse = function (str) {\n    var i = 0;\n    var strlen = str.length;\n\n    while (Character.isWhitespace(str.charAt(i))) {\n      i++;\n    }\n\n    var isNegative = false;\n\n    if (i < strlen) {\n      var signCh = str.charAt(i);\n\n      if (signCh === '-' || signCh === '+') {\n        i++;\n        if (signCh === '-') isNegative = true;\n      }\n    }\n\n    var val = new DD();\n    var numDigits = 0;\n    var numBeforeDec = 0;\n    var exp = 0;\n\n    while (true) {\n      if (i >= strlen) break;\n      var ch = str.charAt(i);\n      i++;\n\n      if (Character.isDigit(ch)) {\n        var d = ch - '0';\n        val.selfMultiply(DD.TEN);\n        val.selfAdd(d);\n        numDigits++;\n        continue;\n      }\n\n      if (ch === '.') {\n        numBeforeDec = numDigits;\n        continue;\n      }\n\n      if (ch === 'e' || ch === 'E') {\n        var expStr = str.substring(i);\n\n        try {\n          exp = Integer.parseInt(expStr);\n        } catch (ex) {\n          if (ex instanceof NumberFormatException) {\n            throw new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n          } else throw ex;\n        } finally {}\n\n        break;\n      }\n\n      throw new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n    }\n\n    var val2 = val;\n    var numDecPlaces = numDigits - numBeforeDec - exp;\n\n    if (numDecPlaces === 0) {\n      val2 = val;\n    } else if (numDecPlaces > 0) {\n      var scale = DD.TEN.pow(numDecPlaces);\n      val2 = val.divide(scale);\n    } else if (numDecPlaces < 0) {\n      var scale = DD.TEN.pow(-numDecPlaces);\n      val2 = val.multiply(scale);\n    }\n\n    if (isNegative) {\n      return val2.negate();\n    }\n\n    return val2;\n  };\n\n  DD.createNaN = function () {\n    return new DD(Double.NaN, Double.NaN);\n  };\n\n  DD.copy = function (dd) {\n    return new DD(dd);\n  };\n\n  DD.magnitude = function (x) {\n    var xAbs = Math.abs(x);\n    var xLog10 = Math.log(xAbs) / Math.log(10);\n    var xMag = Math.trunc(Math.floor(xLog10));\n    var xApprox = Math.pow(10, xMag);\n    if (xApprox * 10 <= xAbs) xMag += 1;\n    return xMag;\n  };\n\n  DD.stringOfChar = function (ch, len) {\n    var buf = new StringBuffer();\n\n    for (var i = 0; i < len; i++) {\n      buf.append(ch);\n    }\n\n    return buf.toString();\n  };\n\n  DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\n  DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\n  DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\n  DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\n  DD.NaN = new DD(Double.NaN, Double.NaN);\n  DD.EPS = 1.23259516440783e-32;\n  DD.SPLIT = 134217729.0;\n  DD.MAX_PRINT_DIGITS = 32;\n  DD.TEN = DD.valueOf(10.0);\n  DD.ONE = DD.valueOf(1.0);\n  DD.SCI_NOT_EXPONENT_CHAR = \"E\";\n  DD.SCI_NOT_ZERO = \"0.0E0\";\n\n  function CGAlgorithmsDD() {}\n  extend(CGAlgorithmsDD.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CGAlgorithmsDD;\n    }\n  });\n\n  CGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n    var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n    if (index <= 1) return index;\n    var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n    var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n    var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n    var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n    return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n  };\n\n  CGAlgorithmsDD.signOfDet2x2 = function () {\n    if (arguments[0] instanceof DD) {\n      var _x = arguments[0],\n          _y = arguments[1],\n          _x2 = arguments[2],\n          _y2 = arguments[3];\n\n      var det = _x.multiply(_y2).selfSubtract(_y.multiply(_x2));\n\n      return det.signum();\n    } else if (typeof arguments[0] === \"number\") {\n      var dx1 = arguments[0],\n          dy1 = arguments[1],\n          dx2 = arguments[2],\n          dy2 = arguments[3];\n      var x1 = DD.valueOf(dx1);\n      var y1 = DD.valueOf(dy1);\n      var x2 = DD.valueOf(dx2);\n      var y2 = DD.valueOf(dy2);\n      var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n      return det.signum();\n    }\n  };\n\n  CGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n    var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n    var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n    var denom = denom1.subtract(denom2);\n    var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n    var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n    var numx = numx1.subtract(numx2);\n    var fracP = numx.selfDivide(denom).doubleValue();\n    var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n    var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n    var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n    var numy = numy1.subtract(numy2);\n    var fracQ = numy.selfDivide(denom).doubleValue();\n    var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n    return new Coordinate(x, y);\n  };\n\n  CGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n    var detsum = null;\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var det = detleft - detright;\n\n    if (detleft > 0.0) {\n      if (detright <= 0.0) {\n        return CGAlgorithmsDD.signum(det);\n      } else {\n        detsum = detleft + detright;\n      }\n    } else if (detleft < 0.0) {\n      if (detright >= 0.0) {\n        return CGAlgorithmsDD.signum(det);\n      } else {\n        detsum = -detleft - detright;\n      }\n    } else {\n      return CGAlgorithmsDD.signum(det);\n    }\n\n    var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\n    if (det >= errbound || -det >= errbound) {\n      return CGAlgorithmsDD.signum(det);\n    }\n\n    return 2;\n  };\n\n  CGAlgorithmsDD.signum = function (x) {\n    if (x > 0) return 1;\n    if (x < 0) return -1;\n    return 0;\n  };\n\n  CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\n  function Orientation() {}\n  extend(Orientation.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Orientation;\n    }\n  });\n\n  Orientation.index = function (p1, p2, q) {\n    return CGAlgorithmsDD.orientationIndex(p1, p2, q);\n  };\n\n  Orientation.isCCW = function (ring) {\n    var nPts = ring.length - 1;\n    if (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n    var hiPt = ring[0];\n    var hiIndex = 0;\n\n    for (var i = 1; i <= nPts; i++) {\n      var p = ring[i];\n\n      if (p.y > hiPt.y) {\n        hiPt = p;\n        hiIndex = i;\n      }\n    }\n\n    var iPrev = hiIndex;\n\n    do {\n      iPrev = iPrev - 1;\n      if (iPrev < 0) iPrev = nPts;\n    } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\n    var iNext = hiIndex;\n\n    do {\n      iNext = (iNext + 1) % nPts;\n    } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\n    var prev = ring[iPrev];\n    var next = ring[iNext];\n    if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n    var disc = Orientation.index(prev, hiPt, next);\n    var isCCW = null;\n\n    if (disc === 0) {\n      isCCW = prev.x > next.x;\n    } else {\n      isCCW = disc > 0;\n    }\n\n    return isCCW;\n  };\n\n  Orientation.CLOCKWISE = -1;\n  Orientation.RIGHT = Orientation.CLOCKWISE;\n  Orientation.COUNTERCLOCKWISE = 1;\n  Orientation.LEFT = Orientation.COUNTERCLOCKWISE;\n  Orientation.COLLINEAR = 0;\n  Orientation.STRAIGHT = Orientation.COLLINEAR;\n\n  function System() {}\n\n  System.arraycopy = function (src, srcPos, dest, destPos, len) {\n    var c = 0;\n\n    for (var i = srcPos; i < srcPos + len; i++) {\n      dest[destPos + c] = src[i];\n      c++;\n    }\n  };\n\n  System.getProperty = function (name) {\n    return {\n      'line.separator': '\\n'\n    }[name];\n  };\n\n  function HCoordinate() {\n    this.x = null;\n    this.y = null;\n    this.w = null;\n\n    if (arguments.length === 0) {\n      this.x = 0.0;\n      this.y = 0.0;\n      this.w = 1.0;\n    } else if (arguments.length === 1) {\n      var p = arguments[0];\n      this.x = p.x;\n      this.y = p.y;\n      this.w = 1.0;\n    } else if (arguments.length === 2) {\n      if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n        var _x = arguments[0],\n            _y = arguments[1];\n        this.x = _x;\n        this.y = _y;\n        this.w = 1.0;\n      } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n        var p1 = arguments[0],\n            p2 = arguments[1];\n        this.x = p1.y * p2.w - p2.y * p1.w;\n        this.y = p2.x * p1.w - p1.x * p2.w;\n        this.w = p1.x * p2.y - p2.x * p1.y;\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        var _p = arguments[0],\n            _p2 = arguments[1];\n        this.x = _p.y - _p2.y;\n        this.y = _p2.x - _p.x;\n        this.w = _p.x * _p2.y - _p2.x * _p.y;\n      }\n    } else if (arguments.length === 3) {\n      var _x2 = arguments[0],\n          _y2 = arguments[1],\n          _w = arguments[2];\n      this.x = _x2;\n      this.y = _y2;\n      this.w = _w;\n    } else if (arguments.length === 4) {\n      var _p3 = arguments[0],\n          _p4 = arguments[1],\n          q1 = arguments[2],\n          q2 = arguments[3];\n      var px = _p3.y - _p4.y;\n      var py = _p4.x - _p3.x;\n      var pw = _p3.x * _p4.y - _p4.x * _p3.y;\n      var qx = q1.y - q2.y;\n      var qy = q2.x - q1.x;\n      var qw = q1.x * q2.y - q2.x * q1.y;\n      this.x = py * qw - qy * pw;\n      this.y = qx * pw - px * qw;\n      this.w = px * qy - qx * py;\n    }\n  }\n  extend(HCoordinate.prototype, {\n    getY: function getY() {\n      var a = this.y / this.w;\n\n      if (Double.isNaN(a) || Double.isInfinite(a)) {\n        throw new NotRepresentableException();\n      }\n\n      return a;\n    },\n    getX: function getX() {\n      var a = this.x / this.w;\n\n      if (Double.isNaN(a) || Double.isInfinite(a)) {\n        throw new NotRepresentableException();\n      }\n\n      return a;\n    },\n    getCoordinate: function getCoordinate() {\n      var p = new Coordinate();\n      p.x = this.getX();\n      p.y = this.getY();\n      return p;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return HCoordinate;\n    }\n  });\n\n  HCoordinate.intersection = function (p1, p2, q1, q2) {\n    var px = p1.y - p2.y;\n    var py = p2.x - p1.x;\n    var pw = p1.x * p2.y - p2.x * p1.y;\n    var qx = q1.y - q2.y;\n    var qy = q2.x - q1.x;\n    var qw = q1.x * q2.y - q2.x * q1.y;\n    var x = py * qw - qy * pw;\n    var y = qx * pw - px * qw;\n    var w = px * qy - qx * py;\n    var xInt = x / w;\n    var yInt = y / w;\n\n    if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {\n      throw new NotRepresentableException();\n    }\n\n    return new Coordinate(xInt, yInt);\n  };\n\n  function MathUtil() {}\n  extend(MathUtil.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MathUtil;\n    }\n  });\n\n  MathUtil.log10 = function (x) {\n    var ln = Math.log(x);\n    if (Double.isInfinite(ln)) return ln;\n    if (Double.isNaN(ln)) return ln;\n    return ln / MathUtil.LOG_10;\n  };\n\n  MathUtil.min = function (v1, v2, v3, v4) {\n    var min = v1;\n    if (v2 < min) min = v2;\n    if (v3 < min) min = v3;\n    if (v4 < min) min = v4;\n    return min;\n  };\n\n  MathUtil.clamp = function () {\n    if (typeof arguments[2] === \"number\" && typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n      var x = arguments[0],\n          min = arguments[1],\n          max = arguments[2];\n      if (x < min) return min;\n      if (x > max) return max;\n      return x;\n    } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var _x = arguments[0],\n          _min = arguments[1],\n          _max = arguments[2];\n      if (_x < _min) return _min;\n      if (_x > _max) return _max;\n      return _x;\n    }\n  };\n\n  MathUtil.wrap = function (index, max) {\n    if (index < 0) {\n      return max - -index % max;\n    }\n\n    return index % max;\n  };\n\n  MathUtil.max = function () {\n    if (arguments.length === 3) {\n      var v1 = arguments[0],\n          v2 = arguments[1],\n          v3 = arguments[2];\n      var max = v1;\n      if (v2 > max) max = v2;\n      if (v3 > max) max = v3;\n      return max;\n    } else if (arguments.length === 4) {\n      var _v = arguments[0],\n          _v2 = arguments[1],\n          _v3 = arguments[2],\n          v4 = arguments[3];\n      var max = _v;\n      if (_v2 > max) max = _v2;\n      if (_v3 > max) max = _v3;\n      if (v4 > max) max = v4;\n      return max;\n    }\n  };\n\n  MathUtil.average = function (x1, x2) {\n    return (x1 + x2) / 2.0;\n  };\n\n  MathUtil.LOG_10 = Math.log(10);\n\n  function Distance() {}\n  extend(Distance.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Distance;\n    }\n  });\n\n  Distance.segmentToSegment = function (A, B, C, D) {\n    if (A.equals(B)) return Distance.pointToSegment(A, C, D);\n    if (C.equals(D)) return Distance.pointToSegment(D, A, B);\n    var noIntersection = false;\n\n    if (!Envelope.intersects(A, B, C, D)) {\n      noIntersection = true;\n    } else {\n      var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\n      if (denom === 0) {\n        noIntersection = true;\n      } else {\n        var r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n        var s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n        var s = s_num / denom;\n        var r = r_num / denom;\n\n        if (r < 0 || r > 1 || s < 0 || s > 1) {\n          noIntersection = true;\n        }\n      }\n    }\n\n    if (noIntersection) {\n      return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n    }\n\n    return 0.0;\n  };\n\n  Distance.pointToSegment = function (p, A, B) {\n    if (A.x === B.x && A.y === B.y) return p.distance(A);\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n    if (r <= 0.0) return p.distance(A);\n    if (r >= 1.0) return p.distance(B);\n    var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2);\n  };\n\n  Distance.pointToLinePerpendicular = function (p, A, B) {\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2);\n  };\n\n  Distance.pointToSegmentString = function (p, line) {\n    if (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n    var minDistance = p.distance(line[0]);\n\n    for (var i = 0; i < line.length - 1; i++) {\n      var dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n      }\n    }\n\n    return minDistance;\n  };\n\n  function CoordinateSequence() {}\n  extend(CoordinateSequence.prototype, {\n    setOrdinate: function setOrdinate(index, ordinateIndex, value) {},\n    size: function size() {},\n    getOrdinate: function getOrdinate(index, ordinateIndex) {},\n    getCoordinate: function getCoordinate() {\n    },\n    getCoordinateCopy: function getCoordinateCopy(i) {},\n    getDimension: function getDimension() {},\n    getX: function getX(index) {},\n    expandEnvelope: function expandEnvelope(env) {},\n    copy: function copy() {},\n    getY: function getY(index) {},\n    toCoordinateArray: function toCoordinateArray() {},\n    interfaces_: function interfaces_() {\n      return [Clonable];\n    },\n    getClass: function getClass() {\n      return CoordinateSequence;\n    }\n  });\n  CoordinateSequence.X = 0;\n  CoordinateSequence.Y = 1;\n  CoordinateSequence.Z = 2;\n  CoordinateSequence.M = 3;\n\n  function CoordinateSequenceFactory() {}\n  extend(CoordinateSequenceFactory.prototype, {\n    create: function create() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) ; else if (hasInterface(arguments[0], CoordinateSequence)) ;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateSequenceFactory;\n    }\n  });\n\n  function GeometryComponentFilter() {}\n  extend(GeometryComponentFilter.prototype, {\n    filter: function filter(geom) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryComponentFilter;\n    }\n  });\n\n  function Geometry() {\n    this._envelope = null;\n    this._factory = null;\n    this._SRID = null;\n    this._userData = null;\n    var factory = arguments[0];\n    this._factory = factory;\n    this._SRID = factory.getSRID();\n  }\n  extend(Geometry.prototype, {\n    isGeometryCollection: function isGeometryCollection() {\n      return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n    },\n    getFactory: function getFactory() {\n      return this._factory;\n    },\n    getGeometryN: function getGeometryN(n) {\n      return this;\n    },\n    getArea: function getArea() {\n      return 0.0;\n    },\n    isRectangle: function isRectangle() {\n      return false;\n    },\n    equals: function equals() {\n      if (arguments[0] instanceof Geometry) {\n        var _g = arguments[0];\n        if (_g === null) return false;\n        return this.equalsTopo(_g);\n      } else if (arguments[0] instanceof Object) {\n        var o = arguments[0];\n        if (!(o instanceof Geometry)) return false;\n        var g = o;\n        return this.equalsExact(g);\n      }\n    },\n    equalsExact: function equalsExact(other) {\n      return this === other || this.equalsExact(other, 0);\n    },\n    geometryChanged: function geometryChanged() {\n      this.apply(Geometry.geometryChangedFilter);\n    },\n    geometryChangedAction: function geometryChangedAction() {\n      this._envelope = null;\n    },\n    equalsNorm: function equalsNorm(g) {\n      if (g === null) return false;\n      return this.norm().equalsExact(g.norm());\n    },\n    getLength: function getLength() {\n      return 0.0;\n    },\n    getNumGeometries: function getNumGeometries() {\n      return 1;\n    },\n    compareTo: function compareTo() {\n      if (arguments.length === 1) {\n        var o = arguments[0];\n        var other = o;\n\n        if (this.getTypeCode() !== other.getTypeCode()) {\n          return this.getTypeCode() - other.getTypeCode();\n        }\n\n        if (this.isEmpty() && other.isEmpty()) {\n          return 0;\n        }\n\n        if (this.isEmpty()) {\n          return -1;\n        }\n\n        if (other.isEmpty()) {\n          return 1;\n        }\n\n        return this.compareToSameClass(o);\n      } else if (arguments.length === 2) {\n        var _o = arguments[0],\n            comp = arguments[1];\n        var other = _o;\n\n        if (this.getTypeCode() !== other.getTypeCode()) {\n          return this.getTypeCode() - other.getTypeCode();\n        }\n\n        if (this.isEmpty() && other.isEmpty()) {\n          return 0;\n        }\n\n        if (this.isEmpty()) {\n          return -1;\n        }\n\n        if (other.isEmpty()) {\n          return 1;\n        }\n\n        return this.compareToSameClass(_o, comp);\n      }\n    },\n    getUserData: function getUserData() {\n      return this._userData;\n    },\n    getSRID: function getSRID() {\n      return this._SRID;\n    },\n    getEnvelope: function getEnvelope() {\n      return this.getFactory().toGeometry(this.getEnvelopeInternal());\n    },\n    checkNotGeometryCollection: function checkNotGeometryCollection(g) {\n      if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {\n        throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n      }\n    },\n    equal: function equal(a, b, tolerance) {\n      if (tolerance === 0) {\n        return a.equals(b);\n      }\n\n      return a.distance(b) <= tolerance;\n    },\n    norm: function norm() {\n      var copy = this.copy();\n      copy.normalize();\n      return copy;\n    },\n    getPrecisionModel: function getPrecisionModel() {\n      return this._factory.getPrecisionModel();\n    },\n    getEnvelopeInternal: function getEnvelopeInternal() {\n      if (this._envelope === null) {\n        this._envelope = this.computeEnvelopeInternal();\n      }\n\n      return new Envelope(this._envelope);\n    },\n    setSRID: function setSRID(SRID) {\n      this._SRID = SRID;\n    },\n    setUserData: function setUserData(userData) {\n      this._userData = userData;\n    },\n    compare: function compare(a, b) {\n      var i = a.iterator();\n      var j = b.iterator();\n\n      while (i.hasNext() && j.hasNext()) {\n        var aElement = i.next();\n        var bElement = j.next();\n        var comparison = aElement.compareTo(bElement);\n\n        if (comparison !== 0) {\n          return comparison;\n        }\n      }\n\n      if (i.hasNext()) {\n        return 1;\n      }\n\n      if (j.hasNext()) {\n        return -1;\n      }\n\n      return 0;\n    },\n    hashCode: function hashCode() {\n      return this.getEnvelopeInternal().hashCode();\n    },\n    isGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {\n      if (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {\n        return true;\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [Clonable, Comparable, Serializable];\n    },\n    getClass: function getClass() {\n      return Geometry;\n    }\n  });\n\n  Geometry.hasNonEmptyElements = function (geometries) {\n    for (var i = 0; i < geometries.length; i++) {\n      if (!geometries[i].isEmpty()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Geometry.hasNullElements = function (array) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === null) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Geometry.serialVersionUID = 8763622679187376702;\n  Geometry.TYPECODE_POINT = 0;\n  Geometry.TYPECODE_MULTIPOINT = 1;\n  Geometry.TYPECODE_LINESTRING = 2;\n  Geometry.TYPECODE_LINEARRING = 3;\n  Geometry.TYPECODE_MULTILINESTRING = 4;\n  Geometry.TYPECODE_POLYGON = 5;\n  Geometry.TYPECODE_MULTIPOLYGON = 6;\n  Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;\n  Geometry.TYPENAME_POINT = \"Point\";\n  Geometry.TYPENAME_MULTIPOINT = \"MultiPoint\";\n  Geometry.TYPENAME_LINESTRING = \"LineString\";\n  Geometry.TYPENAME_LINEARRING = \"LinearRing\";\n  Geometry.TYPENAME_MULTILINESTRING = \"MultiLineString\";\n  Geometry.TYPENAME_POLYGON = \"Polygon\";\n  Geometry.TYPENAME_MULTIPOLYGON = \"MultiPolygon\";\n  Geometry.TYPENAME_GEOMETRYCOLLECTION = \"GeometryCollection\";\n  Geometry.geometryChangedFilter = {\n    interfaces_: function interfaces_() {\n      return [GeometryComponentFilter];\n    },\n    filter: function filter(geom) {\n      geom.geometryChangedAction();\n    }\n  };\n\n  function CoordinateFilter() {}\n  extend(CoordinateFilter.prototype, {\n    filter: function filter(coord) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateFilter;\n    }\n  });\n\n  function BoundaryNodeRule() {}\n  extend(BoundaryNodeRule.prototype, {\n    isInBoundary: function isInBoundary(boundaryCount) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BoundaryNodeRule;\n    }\n  });\n\n  function Mod2BoundaryNodeRule() {}\n\n  extend(Mod2BoundaryNodeRule.prototype, {\n    isInBoundary: function isInBoundary(boundaryCount) {\n      return boundaryCount % 2 === 1;\n    },\n    interfaces_: function interfaces_() {\n      return [BoundaryNodeRule];\n    },\n    getClass: function getClass() {\n      return Mod2BoundaryNodeRule;\n    }\n  });\n\n  function EndPointBoundaryNodeRule() {}\n\n  extend(EndPointBoundaryNodeRule.prototype, {\n    isInBoundary: function isInBoundary(boundaryCount) {\n      return boundaryCount > 0;\n    },\n    interfaces_: function interfaces_() {\n      return [BoundaryNodeRule];\n    },\n    getClass: function getClass() {\n      return EndPointBoundaryNodeRule;\n    }\n  });\n\n  function MultiValentEndPointBoundaryNodeRule() {}\n\n  extend(MultiValentEndPointBoundaryNodeRule.prototype, {\n    isInBoundary: function isInBoundary(boundaryCount) {\n      return boundaryCount > 1;\n    },\n    interfaces_: function interfaces_() {\n      return [BoundaryNodeRule];\n    },\n    getClass: function getClass() {\n      return MultiValentEndPointBoundaryNodeRule;\n    }\n  });\n\n  function MonoValentEndPointBoundaryNodeRule() {}\n\n  extend(MonoValentEndPointBoundaryNodeRule.prototype, {\n    isInBoundary: function isInBoundary(boundaryCount) {\n      return boundaryCount === 1;\n    },\n    interfaces_: function interfaces_() {\n      return [BoundaryNodeRule];\n    },\n    getClass: function getClass() {\n      return MonoValentEndPointBoundaryNodeRule;\n    }\n  });\n  BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\n  BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\n  BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\n  BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\n  BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\n  function CoordinateArrays() {}\n  extend(CoordinateArrays.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateArrays;\n    }\n  });\n\n  CoordinateArrays.isRing = function (pts) {\n    if (pts.length < 4) return false;\n    if (!pts[0].equals2D(pts[pts.length - 1])) return false;\n    return true;\n  };\n\n  CoordinateArrays.ptNotInList = function (testPts, pts) {\n    for (var i = 0; i < testPts.length; i++) {\n      var testPt = testPts[i];\n      if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n    }\n\n    return null;\n  };\n\n  CoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n    var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n    if (i < 0) return null;\n    var newCoordinates = new Array(coordinates.length).fill(null);\n    System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n    System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n    System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n  };\n\n  CoordinateArrays.equals = function () {\n    if (arguments.length === 2) {\n      var coord1 = arguments[0],\n          coord2 = arguments[1];\n      if (coord1 === coord2) return true;\n      if (coord1 === null || coord2 === null) return false;\n      if (coord1.length !== coord2.length) return false;\n\n      for (var i = 0; i < coord1.length; i++) {\n        if (!coord1[i].equals(coord2[i])) return false;\n      }\n\n      return true;\n    } else if (arguments.length === 3) {\n      var _coord = arguments[0],\n          _coord2 = arguments[1],\n          coordinateComparator = arguments[2];\n      if (_coord === _coord2) return true;\n      if (_coord === null || _coord2 === null) return false;\n      if (_coord.length !== _coord2.length) return false;\n\n      for (var i = 0; i < _coord.length; i++) {\n        if (coordinateComparator.compare(_coord[i], _coord2[i]) !== 0) return false;\n      }\n\n      return true;\n    }\n  };\n\n  CoordinateArrays.intersection = function (coordinates, env) {\n    var coordList = new CoordinateList();\n\n    for (var i = 0; i < coordinates.length; i++) {\n      if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n    }\n\n    return coordList.toCoordinateArray();\n  };\n\n  CoordinateArrays.hasRepeatedPoints = function (coord) {\n    for (var i = 1; i < coord.length; i++) {\n      if (coord[i - 1].equals(coord[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  CoordinateArrays.removeRepeatedPoints = function (coord) {\n    if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n    var coordList = new CoordinateList(coord, false);\n    return coordList.toCoordinateArray();\n  };\n\n  CoordinateArrays.reverse = function (coord) {\n    var last = coord.length - 1;\n    var mid = Math.trunc(last / 2);\n\n    for (var i = 0; i <= mid; i++) {\n      var tmp = coord[i];\n      coord[i] = coord[last - i];\n      coord[last - i] = tmp;\n    }\n  };\n\n  CoordinateArrays.removeNull = function (coord) {\n    var nonNull = 0;\n\n    for (var i = 0; i < coord.length; i++) {\n      if (coord[i] !== null) nonNull++;\n    }\n\n    var newCoord = new Array(nonNull).fill(null);\n    if (nonNull === 0) return newCoord;\n    var j = 0;\n\n    for (var i = 0; i < coord.length; i++) {\n      if (coord[i] !== null) newCoord[j++] = coord[i];\n    }\n\n    return newCoord;\n  };\n\n  CoordinateArrays.copyDeep = function () {\n    if (arguments.length === 1) {\n      var coordinates = arguments[0];\n      var copy = new Array(coordinates.length).fill(null);\n\n      for (var i = 0; i < coordinates.length; i++) {\n        copy[i] = new Coordinate(coordinates[i]);\n      }\n\n      return copy;\n    } else if (arguments.length === 5) {\n      var src = arguments[0],\n          srcStart = arguments[1],\n          dest = arguments[2],\n          destStart = arguments[3],\n          length = arguments[4];\n\n      for (var i = 0; i < length; i++) {\n        dest[destStart + i] = new Coordinate(src[srcStart + i]);\n      }\n    }\n  };\n\n  CoordinateArrays.isEqualReversed = function (pts1, pts2) {\n    for (var i = 0; i < pts1.length; i++) {\n      var p1 = pts1[i];\n      var p2 = pts2[pts1.length - i - 1];\n      if (p1.compareTo(p2) !== 0) return false;\n    }\n\n    return true;\n  };\n\n  CoordinateArrays.envelope = function (coordinates) {\n    var env = new Envelope();\n\n    for (var i = 0; i < coordinates.length; i++) {\n      env.expandToInclude(coordinates[i]);\n    }\n\n    return env;\n  };\n\n  CoordinateArrays.toCoordinateArray = function (coordList) {\n    return coordList.toArray(CoordinateArrays.coordArrayType);\n  };\n\n  CoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n    return c.length >= n ? c : [];\n  };\n\n  CoordinateArrays.indexOf = function (coordinate, coordinates) {\n    for (var i = 0; i < coordinates.length; i++) {\n      if (coordinate.equals(coordinates[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  CoordinateArrays.increasingDirection = function (pts) {\n    for (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n      var j = pts.length - 1 - i;\n      var comp = pts[i].compareTo(pts[j]);\n      if (comp !== 0) return comp;\n    }\n\n    return 1;\n  };\n\n  CoordinateArrays.compare = function (pts1, pts2) {\n    var i = 0;\n\n    while (i < pts1.length && i < pts2.length) {\n      var compare = pts1[i].compareTo(pts2[i]);\n      if (compare !== 0) return compare;\n      i++;\n    }\n\n    if (i < pts2.length) return -1;\n    if (i < pts1.length) return 1;\n    return 0;\n  };\n\n  CoordinateArrays.minCoordinate = function (coordinates) {\n    var minCoord = null;\n\n    for (var i = 0; i < coordinates.length; i++) {\n      if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n        minCoord = coordinates[i];\n      }\n    }\n\n    return minCoord;\n  };\n\n  CoordinateArrays.extract = function (pts, start, end) {\n    start = MathUtil.clamp(start, 0, pts.length);\n    end = MathUtil.clamp(end, -1, pts.length);\n    var npts = end - start + 1;\n    if (end < 0) npts = 0;\n    if (start >= pts.length) npts = 0;\n    if (end < start) npts = 0;\n    var extractPts = new Array(npts).fill(null);\n    if (npts === 0) return extractPts;\n    var iPts = 0;\n\n    for (var i = start; i <= end; i++) {\n      extractPts[iPts++] = pts[i];\n    }\n\n    return extractPts;\n  };\n\n  function ForwardComparator() {}\n\n  extend(ForwardComparator.prototype, {\n    compare: function compare(o1, o2) {\n      var pts1 = o1;\n      var pts2 = o2;\n      return CoordinateArrays.compare(pts1, pts2);\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return ForwardComparator;\n    }\n  });\n\n  function BidirectionalComparator() {}\n\n  extend(BidirectionalComparator.prototype, {\n    compare: function compare(o1, o2) {\n      var pts1 = o1;\n      var pts2 = o2;\n      if (pts1.length < pts2.length) return -1;\n      if (pts1.length > pts2.length) return 1;\n      if (pts1.length === 0) return 0;\n      var forwardComp = CoordinateArrays.compare(pts1, pts2);\n      var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n      if (isEqualRev) return 0;\n      return forwardComp;\n    },\n    OLDcompare: function OLDcompare(o1, o2) {\n      var pts1 = o1;\n      var pts2 = o2;\n      if (pts1.length < pts2.length) return -1;\n      if (pts1.length > pts2.length) return 1;\n      if (pts1.length === 0) return 0;\n      var dir1 = CoordinateArrays.increasingDirection(pts1);\n      var dir2 = CoordinateArrays.increasingDirection(pts2);\n      var i1 = dir1 > 0 ? 0 : pts1.length - 1;\n      var i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\n      for (var i = 0; i < pts1.length; i++) {\n        var comparePt = pts1[i1].compareTo(pts2[i2]);\n        if (comparePt !== 0) return comparePt;\n        i1 += dir1;\n        i2 += dir2;\n      }\n\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return BidirectionalComparator;\n    }\n  });\n  CoordinateArrays.ForwardComparator = ForwardComparator;\n  CoordinateArrays.BidirectionalComparator = BidirectionalComparator;\n  CoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n   *\n   * @constructor\n   * @private\n   */\n  function Map$1() {}\n  /**\n   * Returns the value to which the specified key is mapped, or null if this map\n   * contains no mapping for the key.\n   * @param {Object} key\n   * @return {Object}\n   */\n\n  Map$1.prototype.get = function () {};\n  /**\n   * Associates the specified value with the specified key in this map (optional\n   * operation).\n   * @param {Object} key\n   * @param {Object} value\n   * @return {Object}\n   */\n\n\n  Map$1.prototype.put = function () {};\n  /**\n   * Returns the number of key-value mappings in this map.\n   * @return {number}\n   */\n\n\n  Map$1.prototype.size = function () {};\n  /**\n   * Returns a Collection view of the values contained in this map.\n   * @return {javascript.util.Collection}\n   */\n\n\n  Map$1.prototype.values = function () {};\n  /**\n   * Returns a {@link Set} view of the mappings contained in this map.\n   * The set is backed by the map, so changes to the map are\n   * reflected in the set, and vice-versa.  If the map is modified\n   * while an iteration over the set is in progress (except through\n   * the iterator's own <tt>remove</tt> operation, or through the\n   * <tt>setValue</tt> operation on a map entry returned by the\n   * iterator) the results of the iteration are undefined.  The set\n   * supports element removal, which removes the corresponding\n   * mapping from the map, via the <tt>Iterator.remove</tt>,\n   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n   * <tt>clear</tt> operations.  It does not support the\n   * <tt>add</tt> or <tt>addAll</tt> operations.\n   *\n   * @return {Set} a set view of the mappings contained in this map\n   */\n\n\n  Map$1.prototype.entrySet = function () {};\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n   *\n   * @extends {Map}\n   * @constructor\n   * @private\n   */\n\n  function SortedMap() {}\n  SortedMap.prototype = new Map$1();\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n   *\n   * @extends {Collection}\n   * @constructor\n   * @private\n   */\n\n  function Set() {}\n  Set.prototype = new Collection();\n  /**\n   * Returns true if this set contains the specified element. More formally,\n   * returns true if and only if this set contains an element e such that (o==null ?\n   * e==null : o.equals(e)).\n   * @param {Object} e\n   * @return {boolean}\n   */\n\n  Set.prototype.contains = function () {};\n\n  /**\n   * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n   *\n   * @extends {javascript.util.Set}\n   * @constructor\n   * @private\n   */\n\n  function HashSet() {\n    /**\n     * @type {Array}\n     * @private\n    */\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n  HashSet.prototype = new Set();\n  /**\n   * @override\n   */\n\n  HashSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n\n      if (e === o) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n\n    this.array_.push(o);\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.remove = function (o) {\n    throw new javascript.util.OperationNotSupported();\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n\n    return array;\n  };\n  /**\n   * @override\n   */\n\n\n  HashSet.prototype.iterator = function () {\n    return new Iterator_$1(this);\n  };\n  /**\n   * @extends {Iterator}\n   * @param {HashSet} hashSet\n   * @constructor\n   * @private\n   */\n\n\n  var Iterator_$1 = function Iterator_(hashSet) {\n    /**\n     * @type {HashSet}\n     * @private\n     */\n    this.hashSet_ = hashSet;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.position_ = 0;\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$1.prototype.next = function () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException();\n    }\n\n    return this.hashSet_.array_[this.position_++];\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$1.prototype.hasNext = function () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$1.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  var BLACK = 0;\n  var RED = 1;\n\n  function colorOf(p) {\n    return p == null ? BLACK : p.color;\n  }\n\n  function parentOf(p) {\n    return p == null ? null : p.parent;\n  }\n\n  function setColor(p, c) {\n    if (p !== null) p.color = c;\n  }\n\n  function leftOf(p) {\n    return p == null ? null : p.left;\n  }\n\n  function rightOf(p) {\n    return p == null ? null : p.right;\n  }\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n   *\n   * @extends {SortedMap}\n   * @constructor\n   * @private\n   */\n\n\n  function TreeMap() {\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.root_ = null;\n    /**\n     * @type {number}\n     * @private\n    */\n\n    this.size_ = 0;\n  }\n  TreeMap.prototype = new SortedMap();\n  /**\n   * @override\n   */\n\n  TreeMap.prototype.get = function (key) {\n    var p = this.root_;\n\n    while (p !== null) {\n      var cmp = key['compareTo'](p.key);\n\n      if (cmp < 0) {\n        p = p.left;\n      } else if (cmp > 0) {\n        p = p.right;\n      } else {\n        return p.value;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeMap.prototype.put = function (key, value) {\n    if (this.root_ === null) {\n      this.root_ = {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n        parent: null,\n        color: BLACK,\n        getValue: function getValue() {\n          return this.value;\n        },\n        getKey: function getKey() {\n          return this.key;\n        }\n      };\n      this.size_ = 1;\n      return null;\n    }\n\n    var t = this.root_,\n        parent,\n        cmp;\n\n    do {\n      parent = t;\n      cmp = key['compareTo'](t.key);\n\n      if (cmp < 0) {\n        t = t.left;\n      } else if (cmp > 0) {\n        t = t.right;\n      } else {\n        var oldValue = t.value;\n        t.value = value;\n        return oldValue;\n      }\n    } while (t !== null);\n\n    var e = {\n      key: key,\n      left: null,\n      right: null,\n      value: value,\n      parent: parent,\n      color: BLACK,\n      getValue: function getValue() {\n        return this.value;\n      },\n      getKey: function getKey() {\n        return this.key;\n      }\n    };\n\n    if (cmp < 0) {\n      parent.left = e;\n    } else {\n      parent.right = e;\n    }\n\n    this.fixAfterInsertion(e);\n    this.size_++;\n    return null;\n  };\n  /**\n   * @param {Object} x\n   */\n\n\n  TreeMap.prototype.fixAfterInsertion = function (x) {\n    x.color = RED;\n\n    while (x != null && x != this.root_ && x.parent.color == RED) {\n      if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n        var y = rightOf(parentOf(parentOf(x)));\n\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == rightOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateLeft(x);\n          }\n\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateRight(parentOf(parentOf(x)));\n        }\n      } else {\n        var y = leftOf(parentOf(parentOf(x)));\n\n        if (colorOf(y) == RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x == leftOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateRight(x);\n          }\n\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateLeft(parentOf(parentOf(x)));\n        }\n      }\n    }\n\n    this.root_.color = BLACK;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var p = this.getFirstEntry();\n\n    if (p !== null) {\n      arrayList.add(p.value);\n\n      while ((p = TreeMap.successor(p)) !== null) {\n        arrayList.add(p.value);\n      }\n    }\n\n    return arrayList;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    var p = this.getFirstEntry();\n\n    if (p !== null) {\n      hashSet.add(p);\n\n      while ((p = TreeMap.successor(p)) !== null) {\n        hashSet.add(p);\n      }\n    }\n\n    return hashSet;\n  };\n  /**\n   * @param {Object} p\n   */\n\n\n  TreeMap.prototype.rotateLeft = function (p) {\n    if (p != null) {\n      var r = p.right;\n      p.right = r.left;\n      if (r.left != null) r.left.parent = p;\n      r.parent = p.parent;\n      if (p.parent == null) this.root_ = r;else if (p.parent.left == p) p.parent.left = r;else p.parent.right = r;\n      r.left = p;\n      p.parent = r;\n    }\n  };\n  /**\n   * @param {Object} p\n   */\n\n\n  TreeMap.prototype.rotateRight = function (p) {\n    if (p != null) {\n      var l = p.left;\n      p.left = l.right;\n      if (l.right != null) l.right.parent = p;\n      l.parent = p.parent;\n      if (p.parent == null) this.root_ = l;else if (p.parent.right == p) p.parent.right = l;else p.parent.left = l;\n      l.right = p;\n      p.parent = l;\n    }\n  };\n  /**\n   * @return {Object}\n   */\n\n\n  TreeMap.prototype.getFirstEntry = function () {\n    var p = this.root_;\n\n    if (p != null) {\n      while (p.left != null) {\n        p = p.left;\n      }\n    }\n\n    return p;\n  };\n  /**\n   * @param {Object} t\n   * @return {Object}\n   * @private\n   */\n\n\n  TreeMap.successor = function (t) {\n    if (t === null) return null;else if (t.right !== null) {\n      var p = t.right;\n\n      while (p.left !== null) {\n        p = p.left;\n      }\n\n      return p;\n    } else {\n      var p = t.parent;\n      var ch = t;\n\n      while (p !== null && ch === p.right) {\n        ch = p;\n        p = p.parent;\n      }\n\n      return p;\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  TreeMap.prototype.size = function () {\n    return this.size_;\n  };\n\n  TreeMap.prototype.containsKey = function (key) {\n    var p = this.root_;\n\n    while (p !== null) {\n      var cmp = key['compareTo'](p.key);\n\n      if (cmp < 0) {\n        p = p.left;\n      } else if (cmp > 0) {\n        p = p.right;\n      } else {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  function Lineal() {}\n  extend(Lineal.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Lineal;\n    }\n  });\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n   *\n   * @extends {Set}\n   * @constructor\n   * @private\n   */\n\n  function SortedSet() {}\n  SortedSet.prototype = new Set();\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n   *\n   * @extends {SortedSet}\n   * @constructor\n   * @private\n   */\n\n  function TreeSet() {\n    /**\n     * @type {Array}\n     * @private\n    */\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n  TreeSet.prototype = new SortedSet();\n  /**\n   * @override\n   */\n\n  TreeSet.prototype.contains = function (o) {\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n\n      if (e['compareTo'](o) === 0) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.add = function (o) {\n    if (this.contains(o)) {\n      return false;\n    }\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this.array_[i];\n\n      if (e['compareTo'](o) === 1) {\n        this.array_.splice(i, 0, o);\n        return true;\n      }\n    }\n\n    this.array_.push(o);\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.addAll = function (c) {\n    for (var i = c.iterator(); i.hasNext();) {\n      this.add(i.next());\n    }\n\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.remove = function (e) {\n    throw new OperationNotSupported();\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.size = function () {\n    return this.array_.length;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n\n    return array;\n  };\n  /**\n   * @override\n   */\n\n\n  TreeSet.prototype.iterator = function () {\n    return new Iterator_$2(this);\n  };\n  /**\n   * @extends {javascript.util.Iterator}\n   * @param {javascript.util.TreeSet} treeSet\n   * @constructor\n   * @private\n   */\n\n\n  var Iterator_$2 = function Iterator_(treeSet) {\n    /**\n     * @type {javascript.util.TreeSet}\n     * @private\n     */\n    this.treeSet_ = treeSet;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.position_ = 0;\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$2.prototype.next = function () {\n    if (this.position_ === this.treeSet_.size()) {\n      throw new NoSuchElementException();\n    }\n\n    return this.treeSet_.array_[this.position_++];\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$2.prototype.hasNext = function () {\n    if (this.position_ < this.treeSet_.size()) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  Iterator_$2.prototype.remove = function () {\n    throw new OperationNotSupported();\n  };\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n   *\n   * @constructor\n   * @private\n   */\n\n  function Arrays() {}\n  /**\n   */\n\n  Arrays.sort = function () {\n    var a = arguments[0],\n        i,\n        t,\n        comparator,\n        compare;\n\n    if (arguments.length === 1) {\n      compare = function compare(a, b) {\n        return a.compareTo(b);\n      };\n\n      a.sort(compare);\n      return;\n    } else if (arguments.length === 2) {\n      comparator = arguments[1];\n\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n\n      a.sort(compare);\n    } else if (arguments.length === 3) {\n      t = a.slice(arguments[1], arguments[2]);\n      t.sort();\n      var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n\n      return;\n    } else if (arguments.length === 4) {\n      t = a.slice(arguments[1], arguments[2]);\n      comparator = arguments[3];\n\n      compare = function compare(a, b) {\n        return comparator['compare'](a, b);\n      };\n\n      t.sort(compare);\n      r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n      a.splice(0, a.length);\n\n      for (i = 0; i < r.length; i++) {\n        a.push(r[i]);\n      }\n\n      return;\n    }\n  };\n  /**\n   * @param {Array} array\n   * @return {ArrayList}\n   */\n\n\n  Arrays.asList = function (array) {\n    var arrayList = new ArrayList();\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      arrayList.add(array[i]);\n    }\n\n    return arrayList;\n  };\n\n  function Dimension() {}\n  extend(Dimension.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Dimension;\n    }\n  });\n\n  Dimension.toDimensionSymbol = function (dimensionValue) {\n    switch (dimensionValue) {\n      case Dimension.FALSE:\n        return Dimension.SYM_FALSE;\n\n      case Dimension.TRUE:\n        return Dimension.SYM_TRUE;\n\n      case Dimension.DONTCARE:\n        return Dimension.SYM_DONTCARE;\n\n      case Dimension.P:\n        return Dimension.SYM_P;\n\n      case Dimension.L:\n        return Dimension.SYM_L;\n\n      case Dimension.A:\n        return Dimension.SYM_A;\n    }\n\n    throw new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n  };\n\n  Dimension.toDimensionValue = function (dimensionSymbol) {\n    switch (Character.toUpperCase(dimensionSymbol)) {\n      case Dimension.SYM_FALSE:\n        return Dimension.FALSE;\n\n      case Dimension.SYM_TRUE:\n        return Dimension.TRUE;\n\n      case Dimension.SYM_DONTCARE:\n        return Dimension.DONTCARE;\n\n      case Dimension.SYM_P:\n        return Dimension.P;\n\n      case Dimension.SYM_L:\n        return Dimension.L;\n\n      case Dimension.SYM_A:\n        return Dimension.A;\n    }\n\n    throw new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n  };\n\n  Dimension.P = 0;\n  Dimension.L = 1;\n  Dimension.A = 2;\n  Dimension.FALSE = -1;\n  Dimension.TRUE = -2;\n  Dimension.DONTCARE = -3;\n  Dimension.SYM_FALSE = 'F';\n  Dimension.SYM_TRUE = 'T';\n  Dimension.SYM_DONTCARE = '*';\n  Dimension.SYM_P = '0';\n  Dimension.SYM_L = '1';\n  Dimension.SYM_A = '2';\n\n  function GeometryFilter() {}\n  extend(GeometryFilter.prototype, {\n    filter: function filter(geom) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryFilter;\n    }\n  });\n\n  function CoordinateSequenceFilter() {}\n  extend(CoordinateSequenceFilter.prototype, {\n    filter: function filter(seq, i) {},\n    isDone: function isDone() {},\n    isGeometryChanged: function isGeometryChanged() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateSequenceFilter;\n    }\n  });\n\n  function GeometryCollection() {\n    this._geometries = null;\n    var geometries = arguments[0],\n        factory = arguments[1];\n    Geometry.call(this, factory);\n\n    if (geometries === null) {\n      geometries = [];\n    }\n\n    if (Geometry.hasNullElements(geometries)) {\n      throw new IllegalArgumentException(\"geometries must not contain null elements\");\n    }\n\n    this._geometries = geometries;\n  }\n  inherits(GeometryCollection, Geometry);\n  extend(GeometryCollection.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      var envelope = new Envelope();\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n      }\n\n      return envelope;\n    },\n    getGeometryN: function getGeometryN(n) {\n      return this._geometries[n];\n    },\n    getCoordinates: function getCoordinates() {\n      var coordinates = new Array(this.getNumPoints()).fill(null);\n      var k = -1;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        var childCoordinates = this._geometries[i].getCoordinates();\n\n        for (var j = 0; j < childCoordinates.length; j++) {\n          k++;\n          coordinates[k] = childCoordinates[j];\n        }\n      }\n\n      return coordinates;\n    },\n    getArea: function getArea() {\n      var area = 0.0;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        area += this._geometries[i].getArea();\n      }\n\n      return area;\n    },\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        var otherCollection = other;\n\n        if (this._geometries.length !== otherCollection._geometries.length) {\n          return false;\n        }\n\n        for (var i = 0; i < this._geometries.length; i++) {\n          if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n            return false;\n          }\n        }\n\n        return true;\n      } else return Geometry.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      for (var i = 0; i < this._geometries.length; i++) {\n        this._geometries[i].normalize();\n      }\n\n      Arrays.sort(this._geometries);\n    },\n    getCoordinate: function getCoordinate() {\n      if (this.isEmpty()) return null;\n      return this._geometries[0].getCoordinate();\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      var dimension = Dimension.FALSE;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n      }\n\n      return dimension;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_GEOMETRYCOLLECTION;\n    },\n    getDimension: function getDimension() {\n      var dimension = Dimension.FALSE;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        dimension = Math.max(dimension, this._geometries[i].getDimension());\n      }\n\n      return dimension;\n    },\n    getLength: function getLength() {\n      var sum = 0.0;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        sum += this._geometries[i].getLength();\n      }\n\n      return sum;\n    },\n    getNumPoints: function getNumPoints() {\n      var numPoints = 0;\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        numPoints += this._geometries[i].getNumPoints();\n      }\n\n      return numPoints;\n    },\n    getNumGeometries: function getNumGeometries() {\n      return this._geometries.length;\n    },\n    reverse: function reverse() {\n      var n = this._geometries.length;\n      var revGeoms = new Array(n).fill(null);\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        revGeoms[i] = this._geometries[i].reverse();\n      }\n\n      return this.getFactory().createGeometryCollection(revGeoms);\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (arguments.length === 1) {\n        var o = arguments[0];\n        var theseElements = new TreeSet(Arrays.asList(this._geometries));\n        var otherElements = new TreeSet(Arrays.asList(o._geometries));\n        return this.compare(theseElements, otherElements);\n      } else if (arguments.length === 2) {\n        var _o = arguments[0],\n            comp = arguments[1];\n        var gc = _o;\n        var n1 = this.getNumGeometries();\n        var n2 = gc.getNumGeometries();\n        var i = 0;\n\n        while (i < n1 && i < n2) {\n          var thisGeom = this.getGeometryN(i);\n          var otherGeom = gc.getGeometryN(i);\n          var holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n          if (holeComp !== 0) return holeComp;\n          i++;\n        }\n\n        if (i < n1) return 1;\n        if (i < n2) return -1;\n        return 0;\n      }\n    },\n    apply: function apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        var filter = arguments[0];\n\n        for (var i = 0; i < this._geometries.length; i++) {\n          this._geometries[i].apply(filter);\n        }\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        var _filter = arguments[0];\n        if (this._geometries.length === 0) return null;\n\n        for (var i = 0; i < this._geometries.length; i++) {\n          this._geometries[i].apply(_filter);\n\n          if (_filter.isDone()) {\n            break;\n          }\n        }\n\n        if (_filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        var _filter2 = arguments[0];\n\n        _filter2.filter(this);\n\n        for (var i = 0; i < this._geometries.length; i++) {\n          this._geometries[i].apply(_filter2);\n        }\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        var _filter3 = arguments[0];\n\n        _filter3.filter(this);\n\n        for (var i = 0; i < this._geometries.length; i++) {\n          this._geometries[i].apply(_filter3);\n        }\n      }\n    },\n    getBoundary: function getBoundary() {\n      this.checkNotGeometryCollection(this);\n      Assert.shouldNeverReachHere();\n      return null;\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_GEOMETRYCOLLECTION;\n    },\n    copy: function copy() {\n      var geometries = new Array(this._geometries.length).fill(null);\n\n      for (var i = 0; i < geometries.length; i++) {\n        geometries[i] = this._geometries[i].copy();\n      }\n\n      return new GeometryCollection(geometries, this._factory);\n    },\n    isEmpty: function isEmpty() {\n      for (var i = 0; i < this._geometries.length; i++) {\n        if (!this._geometries[i].isEmpty()) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryCollection;\n    }\n  });\n  GeometryCollection.serialVersionUID = -5694727726395021467;\n\n  function MultiLineString() {\n    var lineStrings = arguments[0],\n        factory = arguments[1];\n    GeometryCollection.call(this, lineStrings, factory);\n  }\n  inherits(MultiLineString, GeometryCollection);\n  extend(MultiLineString.prototype, {\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      if (this.isClosed()) {\n        return Dimension.FALSE;\n      }\n\n      return 0;\n    },\n    isClosed: function isClosed() {\n      if (this.isEmpty()) {\n        return false;\n      }\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        if (!this._geometries[i].isClosed()) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_MULTILINESTRING;\n    },\n    getDimension: function getDimension() {\n      return 1;\n    },\n    reverse: function reverse() {\n      var nLines = this._geometries.length;\n      var revLines = new Array(nLines).fill(null);\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        revLines[nLines - 1 - i] = this._geometries[i].reverse();\n      }\n\n      return this.getFactory().createMultiLineString(revLines);\n    },\n    getBoundary: function getBoundary() {\n      return new BoundaryOp(this).getBoundary();\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_MULTILINESTRING;\n    },\n    copy: function copy() {\n      var lineStrings = new Array(this._geometries.length).fill(null);\n\n      for (var i = 0; i < lineStrings.length; i++) {\n        lineStrings[i] = this._geometries[i].copy();\n      }\n\n      return new MultiLineString(lineStrings, this._factory);\n    },\n    interfaces_: function interfaces_() {\n      return [Lineal];\n    },\n    getClass: function getClass() {\n      return MultiLineString;\n    }\n  });\n  MultiLineString.serialVersionUID = 8166665132445433741;\n\n  function BoundaryOp() {\n    this._geom = null;\n    this._geomFact = null;\n    this._bnRule = null;\n    this._endpointMap = null;\n\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      BoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n    } else if (arguments.length === 2) {\n      var _geom = arguments[0],\n          bnRule = arguments[1];\n      this._geom = _geom;\n      this._geomFact = _geom.getFactory();\n      this._bnRule = bnRule;\n    }\n  }\n  extend(BoundaryOp.prototype, {\n    boundaryMultiLineString: function boundaryMultiLineString(mLine) {\n      if (this._geom.isEmpty()) {\n        return this.getEmptyMultiPoint();\n      }\n\n      var bdyPts = this.computeBoundaryCoordinates(mLine);\n\n      if (bdyPts.length === 1) {\n        return this._geomFact.createPoint(bdyPts[0]);\n      }\n\n      return this._geomFact.createMultiPointFromCoords(bdyPts);\n    },\n    getBoundary: function getBoundary() {\n      if (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n      if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n      return this._geom.getBoundary();\n    },\n    boundaryLineString: function boundaryLineString(line) {\n      if (this._geom.isEmpty()) {\n        return this.getEmptyMultiPoint();\n      }\n\n      if (line.isClosed()) {\n        var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\n        if (closedEndpointOnBoundary) {\n          return line.getStartPoint();\n        } else {\n          return this._geomFact.createMultiPoint();\n        }\n      }\n\n      return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n    },\n    getEmptyMultiPoint: function getEmptyMultiPoint() {\n      return this._geomFact.createMultiPoint();\n    },\n    computeBoundaryCoordinates: function computeBoundaryCoordinates(mLine) {\n      var bdyPts = new ArrayList();\n      this._endpointMap = new TreeMap();\n\n      for (var i = 0; i < mLine.getNumGeometries(); i++) {\n        var line = mLine.getGeometryN(i);\n        if (line.getNumPoints() === 0) continue;\n        this.addEndpoint(line.getCoordinateN(0));\n        this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n      }\n\n      for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n        var entry = it.next();\n        var counter = entry.getValue();\n        var valence = counter.count;\n\n        if (this._bnRule.isInBoundary(valence)) {\n          bdyPts.add(entry.getKey());\n        }\n      }\n\n      return CoordinateArrays.toCoordinateArray(bdyPts);\n    },\n    addEndpoint: function addEndpoint(pt) {\n      var counter = this._endpointMap.get(pt);\n\n      if (counter === null) {\n        counter = new Counter();\n\n        this._endpointMap.put(pt, counter);\n      }\n\n      counter.count++;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BoundaryOp;\n    }\n  });\n\n  BoundaryOp.getBoundary = function () {\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      var bop = new BoundaryOp(g);\n      return bop.getBoundary();\n    } else if (arguments.length === 2) {\n      var _g = arguments[0],\n          bnRule = arguments[1];\n      var bop = new BoundaryOp(_g, bnRule);\n      return bop.getBoundary();\n    }\n  };\n\n  function Counter() {\n    this.count = null;\n  }\n\n  extend(Counter.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Counter;\n    }\n  });\n\n  function Length() {}\n  extend(Length.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Length;\n    }\n  });\n\n  Length.ofLine = function (pts) {\n    var n = pts.size();\n    if (n <= 1) return 0.0;\n    var len = 0.0;\n    var p = new Coordinate();\n    pts.getCoordinate(0, p);\n    var x0 = p.x;\n    var y0 = p.y;\n\n    for (var i = 1; i < n; i++) {\n      pts.getCoordinate(i, p);\n      var x1 = p.x;\n      var y1 = p.y;\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      len += Math.sqrt(dx * dx + dy * dy);\n      x0 = x1;\n      y0 = y1;\n    }\n\n    return len;\n  };\n\n  function PrintStream() {}\n\n  function StringReader() {}\n\n  function DecimalFormat() {}\n\n  function ByteArrayOutputStream() {}\n\n  function IOException() {}\n\n  function LineNumberReader() {}\n\n  function StringUtil() {}\n  extend(StringUtil.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return StringUtil;\n    }\n  });\n\n  StringUtil.chars = function (c, n) {\n    var ch = new Array(n).fill(null);\n\n    for (var i = 0; i < n; i++) {\n      ch[i] = c;\n    }\n\n    return new String(ch);\n  };\n\n  StringUtil.getStackTrace = function () {\n    if (arguments.length === 1) {\n      var t = arguments[0];\n      var os = new ByteArrayOutputStream();\n      var ps = new PrintStream(os);\n      t.printStackTrace(ps);\n      return os.toString();\n    } else if (arguments.length === 2) {\n      var _t = arguments[0],\n          depth = arguments[1];\n      var stackTrace = \"\";\n      var stringReader = new StringReader(StringUtil.getStackTrace(_t));\n      var lineNumberReader = new LineNumberReader(stringReader);\n\n      for (var i = 0; i < depth; i++) {\n        try {\n          stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n        } catch (e) {\n          if (e instanceof IOException) {\n            Assert.shouldNeverReachHere();\n          } else throw e;\n        } finally {}\n      }\n\n      return stackTrace;\n    }\n  };\n\n  StringUtil.split = function (s, separator) {\n    var separatorlen = separator.length;\n    var tokenList = new ArrayList();\n    var tmpString = \"\" + s;\n    var pos = tmpString.indexOf(separator);\n\n    while (pos >= 0) {\n      var token = tmpString.substring(0, pos);\n      tokenList.add(token);\n      tmpString = tmpString.substring(pos + separatorlen);\n      pos = tmpString.indexOf(separator);\n    }\n\n    if (tmpString.length > 0) tokenList.add(tmpString);\n    var res = new Array(tokenList.size()).fill(null);\n\n    for (var i = 0; i < res.length; i++) {\n      res[i] = tokenList.get(i);\n    }\n\n    return res;\n  };\n\n  StringUtil.toString = function () {\n    if (arguments.length === 1 && typeof arguments[0] === \"number\") {\n      var d = arguments[0];\n      return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n    }\n  };\n\n  StringUtil.spaces = function (n) {\n    return StringUtil.chars(' ', n);\n  };\n\n  StringUtil.NEWLINE = System.getProperty(\"line.separator\");\n  StringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n\n  function StringBuilder(str) {\n    this.str = str;\n  }\n\n  StringBuilder.prototype.append = function (e) {\n    this.str += e;\n  };\n\n  StringBuilder.prototype.setCharAt = function (i, c) {\n    this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n  };\n\n  StringBuilder.prototype.toString = function (e) {\n    return this.str;\n  };\n\n  function CoordinateSequences() {}\n  extend(CoordinateSequences.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CoordinateSequences;\n    }\n  });\n\n  CoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n    var minDim = Math.min(src.getDimension(), dest.getDimension());\n\n    for (var dim = 0; dim < minDim; dim++) {\n      dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n    }\n  };\n\n  CoordinateSequences.isRing = function (seq) {\n    var n = seq.size();\n    if (n === 0) return true;\n    if (n <= 3) return false;\n    return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  };\n\n  CoordinateSequences.isEqual = function (cs1, cs2) {\n    var cs1Size = cs1.size();\n    var cs2Size = cs2.size();\n    if (cs1Size !== cs2Size) return false;\n    var dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\n    for (var i = 0; i < cs1Size; i++) {\n      for (var d = 0; d < dim; d++) {\n        var v1 = cs1.getOrdinate(i, d);\n        var v2 = cs2.getOrdinate(i, d);\n        if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n        if (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  CoordinateSequences.extend = function (fact, seq, size) {\n    var newseq = fact.create(size, seq.getDimension());\n    var n = seq.size();\n    CoordinateSequences.copy(seq, 0, newseq, 0, n);\n\n    if (n > 0) {\n      for (var i = n; i < size; i++) {\n        CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n      }\n    }\n\n    return newseq;\n  };\n\n  CoordinateSequences.reverse = function (seq) {\n    var last = seq.size() - 1;\n    var mid = Math.trunc(last / 2);\n\n    for (var i = 0; i <= mid; i++) {\n      CoordinateSequences.swap(seq, i, last - i);\n    }\n  };\n\n  CoordinateSequences.swap = function (seq, i, j) {\n    if (i === j) return null;\n\n    for (var dim = 0; dim < seq.getDimension(); dim++) {\n      var tmp = seq.getOrdinate(i, dim);\n      seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n      seq.setOrdinate(j, dim, tmp);\n    }\n  };\n\n  CoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n    for (var i = 0; i < length; i++) {\n      CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n    }\n  };\n\n  CoordinateSequences.toString = function () {\n    if (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {\n      var cs = arguments[0];\n      var size = cs.size();\n      if (size === 0) return \"()\";\n      var dim = cs.getDimension();\n      var builder = new StringBuilder();\n      builder.append('(');\n\n      for (var i = 0; i < size; i++) {\n        if (i > 0) builder.append(\" \");\n\n        for (var d = 0; d < dim; d++) {\n          if (d > 0) builder.append(\",\");\n          builder.append(StringUtil.toString(cs.getOrdinate(i, d)));\n        }\n      }\n\n      builder.append(')');\n      return builder.toString();\n    }\n  };\n\n  CoordinateSequences.ensureValidRing = function (fact, seq) {\n    var n = seq.size();\n    if (n === 0) return seq;\n    if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n    var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n    if (isClosed) return seq;\n    return CoordinateSequences.createClosedRing(fact, seq, n + 1);\n  };\n\n  CoordinateSequences.createClosedRing = function (fact, seq, size) {\n    var newseq = fact.create(size, seq.getDimension());\n    var n = seq.size();\n    CoordinateSequences.copy(seq, 0, newseq, 0, n);\n\n    for (var i = n; i < size; i++) {\n      CoordinateSequences.copy(seq, 0, newseq, i, 1);\n    }\n\n    return newseq;\n  };\n\n  function LineString() {\n    this._points = null;\n    var points = arguments[0],\n        factory = arguments[1];\n    Geometry.call(this, factory);\n    this.init(points);\n  }\n  inherits(LineString, Geometry);\n  extend(LineString.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      if (this.isEmpty()) {\n        return new Envelope();\n      }\n\n      return this._points.expandEnvelope(new Envelope());\n    },\n    isRing: function isRing() {\n      return this.isClosed() && this.isSimple();\n    },\n    getCoordinates: function getCoordinates() {\n      return this._points.toCoordinateArray();\n    },\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        var otherLineString = other;\n\n        if (this._points.size() !== otherLineString._points.size()) {\n          return false;\n        }\n\n        for (var i = 0; i < this._points.size(); i++) {\n          if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n            return false;\n          }\n        }\n\n        return true;\n      } else return Geometry.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n        var j = this._points.size() - 1 - i;\n\n        if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n          if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n            var copy = this._points.copy();\n\n            CoordinateSequences.reverse(copy);\n            this._points = copy;\n          }\n\n          return null;\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      if (this.isEmpty()) return null;\n      return this._points.getCoordinate(0);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      if (this.isClosed()) {\n        return Dimension.FALSE;\n      }\n\n      return 0;\n    },\n    isClosed: function isClosed() {\n      if (this.isEmpty()) {\n        return false;\n      }\n\n      return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n    },\n    getEndPoint: function getEndPoint() {\n      if (this.isEmpty()) {\n        return null;\n      }\n\n      return this.getPointN(this.getNumPoints() - 1);\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_LINESTRING;\n    },\n    getDimension: function getDimension() {\n      return 1;\n    },\n    getLength: function getLength() {\n      return Length.ofLine(this._points);\n    },\n    getNumPoints: function getNumPoints() {\n      return this._points.size();\n    },\n    reverse: function reverse() {\n      var seq = this._points.copy();\n\n      CoordinateSequences.reverse(seq);\n      var revLine = this.getFactory().createLineString(seq);\n      return revLine;\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (arguments.length === 1) {\n        var o = arguments[0];\n        var line = o;\n        var i = 0;\n        var j = 0;\n\n        while (i < this._points.size() && j < line._points.size()) {\n          var comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\n          if (comparison !== 0) {\n            return comparison;\n          }\n\n          i++;\n          j++;\n        }\n\n        if (i < this._points.size()) {\n          return 1;\n        }\n\n        if (j < line._points.size()) {\n          return -1;\n        }\n\n        return 0;\n      } else if (arguments.length === 2) {\n        var _o = arguments[0],\n            comp = arguments[1];\n        var line = _o;\n        return comp.compare(this._points, line._points);\n      }\n    },\n    apply: function apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        var filter = arguments[0];\n\n        for (var i = 0; i < this._points.size(); i++) {\n          filter.filter(this._points.getCoordinate(i));\n        }\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        var _filter = arguments[0];\n        if (this._points.size() === 0) return null;\n\n        for (var i = 0; i < this._points.size(); i++) {\n          _filter.filter(this._points, i);\n\n          if (_filter.isDone()) break;\n        }\n\n        if (_filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        var _filter2 = arguments[0];\n\n        _filter2.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        var _filter3 = arguments[0];\n\n        _filter3.filter(this);\n      }\n    },\n    getBoundary: function getBoundary() {\n      return new BoundaryOp(this).getBoundary();\n    },\n    isEquivalentClass: function isEquivalentClass(other) {\n      return other instanceof LineString;\n    },\n    getCoordinateN: function getCoordinateN(n) {\n      return this._points.getCoordinate(n);\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_LINESTRING;\n    },\n    copy: function copy() {\n      return new LineString(this._points.copy(), this._factory);\n    },\n    getCoordinateSequence: function getCoordinateSequence() {\n      return this._points;\n    },\n    isEmpty: function isEmpty() {\n      return this._points.size() === 0;\n    },\n    init: function init(points) {\n      if (points === null) {\n        points = this.getFactory().getCoordinateSequenceFactory().create([]);\n      }\n\n      if (points.size() === 1) {\n        throw new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n      }\n\n      this._points = points;\n    },\n    isCoordinate: function isCoordinate(pt) {\n      for (var i = 0; i < this._points.size(); i++) {\n        if (this._points.getCoordinate(i).equals(pt)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    getStartPoint: function getStartPoint() {\n      if (this.isEmpty()) {\n        return null;\n      }\n\n      return this.getPointN(0);\n    },\n    getPointN: function getPointN(n) {\n      return this.getFactory().createPoint(this._points.getCoordinate(n));\n    },\n    interfaces_: function interfaces_() {\n      return [Lineal];\n    },\n    getClass: function getClass() {\n      return LineString;\n    }\n  });\n  LineString.serialVersionUID = 3110669828065365560;\n\n  function Puntal() {}\n  extend(Puntal.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Puntal;\n    }\n  });\n\n  function Point() {\n    this._coordinates = null;\n    var coordinates = arguments[0],\n        factory = arguments[1];\n    Geometry.call(this, factory);\n    this.init(coordinates);\n  }\n  inherits(Point, Geometry);\n  extend(Point.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      if (this.isEmpty()) {\n        return new Envelope();\n      }\n\n      var env = new Envelope();\n      env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n      return env;\n    },\n    getCoordinates: function getCoordinates() {\n      return this.isEmpty() ? [] : [this.getCoordinate()];\n    },\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        if (this.isEmpty() && other.isEmpty()) {\n          return true;\n        }\n\n        if (this.isEmpty() !== other.isEmpty()) {\n          return false;\n        }\n\n        return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n      } else return Geometry.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {},\n    getCoordinate: function getCoordinate() {\n      return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return Dimension.FALSE;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_POINT;\n    },\n    getDimension: function getDimension() {\n      return 0;\n    },\n    getNumPoints: function getNumPoints() {\n      return this.isEmpty() ? 0 : 1;\n    },\n    reverse: function reverse() {\n      return this.copy();\n    },\n    getX: function getX() {\n      if (this.getCoordinate() === null) {\n        throw new IllegalStateException(\"getX called on empty Point\");\n      }\n\n      return this.getCoordinate().x;\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (arguments.length === 1) {\n        var other = arguments[0];\n        var point = other;\n        return this.getCoordinate().compareTo(point.getCoordinate());\n      } else if (arguments.length === 2) {\n        var _other = arguments[0],\n            comp = arguments[1];\n        var point = _other;\n        return comp.compare(this._coordinates, point._coordinates);\n      }\n    },\n    apply: function apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        var filter = arguments[0];\n\n        if (this.isEmpty()) {\n          return null;\n        }\n\n        filter.filter(this.getCoordinate());\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        var _filter = arguments[0];\n        if (this.isEmpty()) return null;\n\n        _filter.filter(this._coordinates, 0);\n\n        if (_filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        var _filter2 = arguments[0];\n\n        _filter2.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        var _filter3 = arguments[0];\n\n        _filter3.filter(this);\n      }\n    },\n    getBoundary: function getBoundary() {\n      return this.getFactory().createGeometryCollection();\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_POINT;\n    },\n    copy: function copy() {\n      return new Point(this._coordinates.copy(), this._factory);\n    },\n    getCoordinateSequence: function getCoordinateSequence() {\n      return this._coordinates;\n    },\n    getY: function getY() {\n      if (this.getCoordinate() === null) {\n        throw new IllegalStateException(\"getY called on empty Point\");\n      }\n\n      return this.getCoordinate().y;\n    },\n    isEmpty: function isEmpty() {\n      return this._coordinates.size() === 0;\n    },\n    init: function init(coordinates) {\n      if (coordinates === null) {\n        coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n      }\n\n      Assert.isTrue(coordinates.size() <= 1);\n      this._coordinates = coordinates;\n    },\n    isSimple: function isSimple() {\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [Puntal];\n    },\n    getClass: function getClass() {\n      return Point;\n    }\n  });\n  Point.serialVersionUID = 4902022702746614570;\n\n  function Area() {}\n  extend(Area.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Area;\n    }\n  });\n\n  Area.ofRing = function () {\n    if (arguments[0] instanceof Array) {\n      var ring = arguments[0];\n      return Math.abs(Area.ofRingSigned(ring));\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var _ring = arguments[0];\n      return Math.abs(Area.ofRingSigned(_ring));\n    }\n  };\n\n  Area.ofRingSigned = function () {\n    if (arguments[0] instanceof Array) {\n      var ring = arguments[0];\n      if (ring.length < 3) return 0.0;\n      var sum = 0.0;\n      var x0 = ring[0].x;\n\n      for (var i = 1; i < ring.length - 1; i++) {\n        var x = ring[i].x - x0;\n        var y1 = ring[i + 1].y;\n        var y2 = ring[i - 1].y;\n        sum += x * (y2 - y1);\n      }\n\n      return sum / 2.0;\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var _ring2 = arguments[0];\n\n      var n = _ring2.size();\n\n      if (n < 3) return 0.0;\n      var p0 = new Coordinate();\n      var p1 = new Coordinate();\n      var p2 = new Coordinate();\n\n      _ring2.getCoordinate(0, p1);\n\n      _ring2.getCoordinate(1, p2);\n\n      var x0 = p1.x;\n      p2.x -= x0;\n      var sum = 0.0;\n\n      for (var i = 1; i < n - 1; i++) {\n        p0.y = p1.y;\n        p1.x = p2.x;\n        p1.y = p2.y;\n\n        _ring2.getCoordinate(i + 1, p2);\n\n        p2.x -= x0;\n        sum += p1.x * (p0.y - p2.y);\n      }\n\n      return sum / 2.0;\n    }\n  };\n\n  function Polygonal() {}\n  extend(Polygonal.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Polygonal;\n    }\n  });\n\n  function Polygon() {\n    this._shell = null;\n    this._holes = null;\n    var shell = arguments[0],\n        holes = arguments[1],\n        factory = arguments[2];\n    Geometry.call(this, factory);\n\n    if (shell === null) {\n      shell = this.getFactory().createLinearRing();\n    }\n\n    if (holes === null) {\n      holes = [];\n    }\n\n    if (Geometry.hasNullElements(holes)) {\n      throw new IllegalArgumentException(\"holes must not contain null elements\");\n    }\n\n    if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n      throw new IllegalArgumentException(\"shell is empty but holes are not\");\n    }\n\n    this._shell = shell;\n    this._holes = holes;\n  }\n  inherits(Polygon, Geometry);\n  extend(Polygon.prototype, {\n    computeEnvelopeInternal: function computeEnvelopeInternal() {\n      return this._shell.getEnvelopeInternal();\n    },\n    getCoordinates: function getCoordinates() {\n      if (this.isEmpty()) {\n        return [];\n      }\n\n      var coordinates = new Array(this.getNumPoints()).fill(null);\n      var k = -1;\n\n      var shellCoordinates = this._shell.getCoordinates();\n\n      for (var x = 0; x < shellCoordinates.length; x++) {\n        k++;\n        coordinates[k] = shellCoordinates[x];\n      }\n\n      for (var i = 0; i < this._holes.length; i++) {\n        var childCoordinates = this._holes[i].getCoordinates();\n\n        for (var j = 0; j < childCoordinates.length; j++) {\n          k++;\n          coordinates[k] = childCoordinates[j];\n        }\n      }\n\n      return coordinates;\n    },\n    getArea: function getArea() {\n      var area = 0.0;\n      area += Area.ofRing(this._shell.getCoordinateSequence());\n\n      for (var i = 0; i < this._holes.length; i++) {\n        area -= Area.ofRing(this._holes[i].getCoordinateSequence());\n      }\n\n      return area;\n    },\n    isRectangle: function isRectangle() {\n      if (this.getNumInteriorRing() !== 0) return false;\n      if (this._shell === null) return false;\n      if (this._shell.getNumPoints() !== 5) return false;\n\n      var seq = this._shell.getCoordinateSequence();\n\n      var env = this.getEnvelopeInternal();\n\n      for (var i = 0; i < 5; i++) {\n        var x = seq.getX(i);\n        if (!(x === env.getMinX() || x === env.getMaxX())) return false;\n        var y = seq.getY(i);\n        if (!(y === env.getMinY() || y === env.getMaxY())) return false;\n      }\n\n      var prevX = seq.getX(0);\n      var prevY = seq.getY(0);\n\n      for (var i = 1; i <= 4; i++) {\n        var x = seq.getX(i);\n        var y = seq.getY(i);\n        var xChanged = x !== prevX;\n        var yChanged = y !== prevY;\n        if (xChanged === yChanged) return false;\n        prevX = x;\n        prevY = y;\n      }\n\n      return true;\n    },\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        var otherPolygon = other;\n        var thisShell = this._shell;\n        var otherPolygonShell = otherPolygon._shell;\n\n        if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n          return false;\n        }\n\n        if (this._holes.length !== otherPolygon._holes.length) {\n          return false;\n        }\n\n        for (var i = 0; i < this._holes.length; i++) {\n          if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n            return false;\n          }\n        }\n\n        return true;\n      } else return Geometry.prototype.equalsExact.apply(this, arguments);\n    },\n    normalize: function normalize() {\n      if (arguments.length === 0) {\n        this.normalize(this._shell, true);\n\n        for (var i = 0; i < this._holes.length; i++) {\n          this.normalize(this._holes[i], false);\n        }\n\n        Arrays.sort(this._holes);\n      } else if (arguments.length === 2) {\n        var ring = arguments[0],\n            clockwise = arguments[1];\n\n        if (ring.isEmpty()) {\n          return null;\n        }\n\n        var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n        System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n        var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n        CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n        System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n        ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\n        if (Orientation.isCCW(ring.getCoordinates()) === clockwise) {\n          CoordinateArrays.reverse(ring.getCoordinates());\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this._shell.getCoordinate();\n    },\n    getNumInteriorRing: function getNumInteriorRing() {\n      return this._holes.length;\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return 1;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_POLYGON;\n    },\n    getDimension: function getDimension() {\n      return 2;\n    },\n    getLength: function getLength() {\n      var len = 0.0;\n      len += this._shell.getLength();\n\n      for (var i = 0; i < this._holes.length; i++) {\n        len += this._holes[i].getLength();\n      }\n\n      return len;\n    },\n    getNumPoints: function getNumPoints() {\n      var numPoints = this._shell.getNumPoints();\n\n      for (var i = 0; i < this._holes.length; i++) {\n        numPoints += this._holes[i].getNumPoints();\n      }\n\n      return numPoints;\n    },\n    reverse: function reverse() {\n      var poly = this.copy();\n      poly._shell = this._shell.copy().reverse();\n      poly._holes = new Array(this._holes.length).fill(null);\n\n      for (var i = 0; i < this._holes.length; i++) {\n        poly._holes[i] = this._holes[i].copy().reverse();\n      }\n\n      return poly;\n    },\n    convexHull: function convexHull() {\n      return this.getExteriorRing().convexHull();\n    },\n    compareToSameClass: function compareToSameClass() {\n      if (arguments.length === 1) {\n        var o = arguments[0];\n        var thisShell = this._shell;\n        var otherShell = o._shell;\n        return thisShell.compareToSameClass(otherShell);\n      } else if (arguments.length === 2) {\n        var _o = arguments[0],\n            comp = arguments[1];\n        var poly = _o;\n        var thisShell = this._shell;\n        var otherShell = poly._shell;\n        var shellComp = thisShell.compareToSameClass(otherShell, comp);\n        if (shellComp !== 0) return shellComp;\n        var nHole1 = this.getNumInteriorRing();\n        var nHole2 = poly.getNumInteriorRing();\n        var i = 0;\n\n        while (i < nHole1 && i < nHole2) {\n          var thisHole = this.getInteriorRingN(i);\n          var otherHole = poly.getInteriorRingN(i);\n          var holeComp = thisHole.compareToSameClass(otherHole, comp);\n          if (holeComp !== 0) return holeComp;\n          i++;\n        }\n\n        if (i < nHole1) return 1;\n        if (i < nHole2) return -1;\n        return 0;\n      }\n    },\n    apply: function apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        var filter = arguments[0];\n\n        this._shell.apply(filter);\n\n        for (var i = 0; i < this._holes.length; i++) {\n          this._holes[i].apply(filter);\n        }\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        var _filter = arguments[0];\n\n        this._shell.apply(_filter);\n\n        if (!_filter.isDone()) {\n          for (var i = 0; i < this._holes.length; i++) {\n            this._holes[i].apply(_filter);\n\n            if (_filter.isDone()) break;\n          }\n        }\n\n        if (_filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        var _filter2 = arguments[0];\n\n        _filter2.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        var _filter3 = arguments[0];\n\n        _filter3.filter(this);\n\n        this._shell.apply(_filter3);\n\n        for (var i = 0; i < this._holes.length; i++) {\n          this._holes[i].apply(_filter3);\n        }\n      }\n    },\n    getBoundary: function getBoundary() {\n      if (this.isEmpty()) {\n        return this.getFactory().createMultiLineString();\n      }\n\n      var rings = new Array(this._holes.length + 1).fill(null);\n      rings[0] = this._shell;\n\n      for (var i = 0; i < this._holes.length; i++) {\n        rings[i + 1] = this._holes[i];\n      }\n\n      if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n      return this.getFactory().createMultiLineString(rings);\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_POLYGON;\n    },\n    copy: function copy() {\n      var shellCopy = this._shell.copy();\n\n      var holeCopies = new Array(this._holes.length).fill(null);\n\n      for (var i = 0; i < this._holes.length; i++) {\n        holeCopies[i] = this._holes[i].copy();\n      }\n\n      return new Polygon(shellCopy, holeCopies, this._factory);\n    },\n    getExteriorRing: function getExteriorRing() {\n      return this._shell;\n    },\n    isEmpty: function isEmpty() {\n      return this._shell.isEmpty();\n    },\n    getInteriorRingN: function getInteriorRingN(n) {\n      return this._holes[n];\n    },\n    interfaces_: function interfaces_() {\n      return [Polygonal];\n    },\n    getClass: function getClass() {\n      return Polygon;\n    }\n  });\n  Polygon.serialVersionUID = -3494792200821764533;\n\n  function MultiPoint() {\n    var points = arguments[0],\n        factory = arguments[1];\n    GeometryCollection.call(this, points, factory);\n  }\n  inherits(MultiPoint, GeometryCollection);\n  extend(MultiPoint.prototype, {\n    isValid: function isValid() {\n      return true;\n    },\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n    },\n    getCoordinate: function getCoordinate() {\n      if (arguments.length === 1 && Number.isInteger(arguments[0])) {\n        var n = arguments[0];\n        return this._geometries[n].getCoordinate();\n      } else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return Dimension.FALSE;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_MULTIPOINT;\n    },\n    getDimension: function getDimension() {\n      return 0;\n    },\n    getBoundary: function getBoundary() {\n      return this.getFactory().createGeometryCollection();\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_MULTIPOINT;\n    },\n    copy: function copy() {\n      var points = new Array(this._geometries.length).fill(null);\n\n      for (var i = 0; i < points.length; i++) {\n        points[i] = this._geometries[i].copy();\n      }\n\n      return new MultiPoint(points, this._factory);\n    },\n    interfaces_: function interfaces_() {\n      return [Puntal];\n    },\n    getClass: function getClass() {\n      return MultiPoint;\n    }\n  });\n  MultiPoint.serialVersionUID = -8048474874175355449;\n\n  function LinearRing() {\n    if (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {\n      var points = arguments[0],\n          factory = arguments[1];\n      LinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n    } else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n      var _points = arguments[0],\n          _factory = arguments[1];\n      LineString.call(this, _points, _factory);\n      this.validateConstruction();\n    }\n  }\n  inherits(LinearRing, LineString);\n  extend(LinearRing.prototype, {\n    getBoundaryDimension: function getBoundaryDimension() {\n      return Dimension.FALSE;\n    },\n    isClosed: function isClosed() {\n      if (this.isEmpty()) {\n        return true;\n      }\n\n      return LineString.prototype.isClosed.call(this);\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_LINEARRING;\n    },\n    reverse: function reverse() {\n      var seq = this._points.copy();\n\n      CoordinateSequences.reverse(seq);\n      var rev = this.getFactory().createLinearRing(seq);\n      return rev;\n    },\n    validateConstruction: function validateConstruction() {\n      if (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n        throw new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n      }\n\n      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n        throw new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n      }\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_LINEARRING;\n    },\n    copy: function copy() {\n      return new LinearRing(this._points.copy(), this._factory);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LinearRing;\n    }\n  });\n  LinearRing.MINIMUM_VALID_SIZE = 4;\n  LinearRing.serialVersionUID = -4261142084085851829;\n\n  function MultiPolygon() {\n    var polygons = arguments[0],\n        factory = arguments[1];\n    GeometryCollection.call(this, polygons, factory);\n  }\n  inherits(MultiPolygon, GeometryCollection);\n  extend(MultiPolygon.prototype, {\n    equalsExact: function equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === \"number\" && arguments[0] instanceof Geometry) {\n        var other = arguments[0],\n            tolerance = arguments[1];\n\n        if (!this.isEquivalentClass(other)) {\n          return false;\n        }\n\n        return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n      } else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n    },\n    getBoundaryDimension: function getBoundaryDimension() {\n      return 1;\n    },\n    getTypeCode: function getTypeCode() {\n      return Geometry.TYPECODE_MULTIPOLYGON;\n    },\n    getDimension: function getDimension() {\n      return 2;\n    },\n    reverse: function reverse() {\n      var n = this._geometries.length;\n      var revGeoms = new Array(n).fill(null);\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        revGeoms[i] = this._geometries[i].reverse();\n      }\n\n      return this.getFactory().createMultiPolygon(revGeoms);\n    },\n    getBoundary: function getBoundary() {\n      if (this.isEmpty()) {\n        return this.getFactory().createMultiLineString();\n      }\n\n      var allRings = new ArrayList();\n\n      for (var i = 0; i < this._geometries.length; i++) {\n        var polygon = this._geometries[i];\n        var rings = polygon.getBoundary();\n\n        for (var j = 0; j < rings.getNumGeometries(); j++) {\n          allRings.add(rings.getGeometryN(j));\n        }\n      }\n\n      var allRingsArray = new Array(allRings.size()).fill(null);\n      return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n    },\n    getGeometryType: function getGeometryType() {\n      return Geometry.TYPENAME_MULTIPOLYGON;\n    },\n    copy: function copy() {\n      var polygons = new Array(this._geometries.length).fill(null);\n\n      for (var i = 0; i < polygons.length; i++) {\n        polygons[i] = this._geometries[i].copy();\n      }\n\n      return new MultiPolygon(polygons, this._factory);\n    },\n    interfaces_: function interfaces_() {\n      return [Polygonal];\n    },\n    getClass: function getClass() {\n      return MultiPolygon;\n    }\n  });\n  MultiPolygon.serialVersionUID = -551033529766975875;\n\n  function GeometryEditor() {\n    this._factory = null;\n    this._isUserDataCopied = false;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var factory = arguments[0];\n      this._factory = factory;\n    }\n  }\n  extend(GeometryEditor.prototype, {\n    setCopyUserData: function setCopyUserData(isUserDataCopied) {\n      this._isUserDataCopied = isUserDataCopied;\n    },\n    edit: function edit(geometry, operation) {\n      if (geometry === null) return null;\n      var result = this.editInternal(geometry, operation);\n\n      if (this._isUserDataCopied) {\n        result.setUserData(geometry.getUserData());\n      }\n\n      return result;\n    },\n    editInternal: function editInternal(geometry, operation) {\n      if (this._factory === null) this._factory = geometry.getFactory();\n\n      if (geometry instanceof GeometryCollection) {\n        return this.editGeometryCollection(geometry, operation);\n      }\n\n      if (geometry instanceof Polygon) {\n        return this.editPolygon(geometry, operation);\n      }\n\n      if (geometry instanceof Point) {\n        return operation.edit(geometry, this._factory);\n      }\n\n      if (geometry instanceof LineString) {\n        return operation.edit(geometry, this._factory);\n      }\n\n      Assert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n      return null;\n    },\n    editGeometryCollection: function editGeometryCollection(collection, operation) {\n      var collectionForType = operation.edit(collection, this._factory);\n      var geometries = new ArrayList();\n\n      for (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n        var geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\n        if (geometry === null || geometry.isEmpty()) {\n          continue;\n        }\n\n        geometries.add(geometry);\n      }\n\n      if (collectionForType.getClass() === MultiPoint) {\n        return this._factory.createMultiPoint(geometries.toArray([]));\n      }\n\n      if (collectionForType.getClass() === MultiLineString) {\n        return this._factory.createMultiLineString(geometries.toArray([]));\n      }\n\n      if (collectionForType.getClass() === MultiPolygon) {\n        return this._factory.createMultiPolygon(geometries.toArray([]));\n      }\n\n      return this._factory.createGeometryCollection(geometries.toArray([]));\n    },\n    editPolygon: function editPolygon(polygon, operation) {\n      var newPolygon = operation.edit(polygon, this._factory);\n      if (newPolygon === null) newPolygon = this._factory.createPolygon();\n\n      if (newPolygon.isEmpty()) {\n        return newPolygon;\n      }\n\n      var shell = this.edit(newPolygon.getExteriorRing(), operation);\n\n      if (shell === null || shell.isEmpty()) {\n        return this._factory.createPolygon();\n      }\n\n      var holes = new ArrayList();\n\n      for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n        var hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\n        if (hole === null || hole.isEmpty()) {\n          continue;\n        }\n\n        holes.add(hole);\n      }\n\n      return this._factory.createPolygon(shell, holes.toArray([]));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryEditor;\n    }\n  });\n\n  function GeometryEditorOperation() {}\n\n  GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\n\n  function NoOpGeometryOperation() {}\n\n  extend(NoOpGeometryOperation.prototype, {\n    edit: function edit(geometry, factory) {\n      return geometry;\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryEditorOperation];\n    },\n    getClass: function getClass() {\n      return NoOpGeometryOperation;\n    }\n  });\n\n  function CoordinateOperation() {}\n\n  extend(CoordinateOperation.prototype, {\n    edit: function edit(geometry, factory) {\n      var coordinates = this.edit(geometry.getCoordinates(), geometry);\n\n      if (geometry instanceof LinearRing) {\n        if (coordinates === null) return factory.createLinearRing();else return factory.createLinearRing(coordinates);\n      }\n\n      if (geometry instanceof LineString) {\n        if (coordinates === null) return factory.createLineString();else return factory.createLineString(coordinates);\n      }\n\n      if (geometry instanceof Point) {\n        if (coordinates === null || coordinates.length === 0) return factory.createPoint();else return factory.createPoint(coordinates[0]);\n      }\n\n      return geometry;\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryEditorOperation];\n    },\n    getClass: function getClass() {\n      return CoordinateOperation;\n    }\n  });\n\n  function CoordinateSequenceOperation() {}\n\n  extend(CoordinateSequenceOperation.prototype, {\n    edit: function edit(geometry, factory) {\n      if (geometry instanceof LinearRing) {\n        return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n      }\n\n      if (geometry instanceof LineString) {\n        return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n      }\n\n      if (geometry instanceof Point) {\n        return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n      }\n\n      return geometry;\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryEditorOperation];\n    },\n    getClass: function getClass() {\n      return CoordinateSequenceOperation;\n    }\n  });\n  GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\n  GeometryEditor.CoordinateOperation = CoordinateOperation;\n  GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\n  function CoordinateArraySequence() {\n    this._dimension = 3;\n    this._coordinates = null;\n\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        var coordinates = arguments[0];\n        CoordinateArraySequence.call(this, coordinates, 3);\n      } else if (Number.isInteger(arguments[0])) {\n        var size = arguments[0];\n        this._coordinates = new Array(size).fill(null);\n\n        for (var i = 0; i < size; i++) {\n          this._coordinates[i] = new Coordinate();\n        }\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        var coordSeq = arguments[0];\n\n        if (coordSeq === null) {\n          this._coordinates = new Array(0).fill(null);\n          return null;\n        }\n\n        this._dimension = coordSeq.getDimension();\n        this._coordinates = new Array(coordSeq.size()).fill(null);\n\n        for (var i = 0; i < this._coordinates.length; i++) {\n          this._coordinates[i] = coordSeq.getCoordinateCopy(i);\n        }\n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n        var _coordinates = arguments[0],\n            dimension = arguments[1];\n        this._coordinates = _coordinates;\n        this._dimension = dimension;\n        if (_coordinates === null) this._coordinates = new Array(0).fill(null);\n      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n        var _size = arguments[0],\n            _dimension = arguments[1];\n        this._coordinates = new Array(_size).fill(null);\n        this._dimension = _dimension;\n\n        for (var i = 0; i < _size; i++) {\n          this._coordinates[i] = new Coordinate();\n        }\n      }\n    }\n  }\n  extend(CoordinateArraySequence.prototype, {\n    setOrdinate: function setOrdinate(index, ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case CoordinateSequence.X:\n          this._coordinates[index].x = value;\n          break;\n\n        case CoordinateSequence.Y:\n          this._coordinates[index].y = value;\n          break;\n\n        case CoordinateSequence.Z:\n          this._coordinates[index].z = value;\n          break;\n\n        default:\n          throw new IllegalArgumentException(\"invalid ordinateIndex\");\n      }\n    },\n    size: function size() {\n      return this._coordinates.length;\n    },\n    getOrdinate: function getOrdinate(index, ordinateIndex) {\n      switch (ordinateIndex) {\n        case CoordinateSequence.X:\n          return this._coordinates[index].x;\n\n        case CoordinateSequence.Y:\n          return this._coordinates[index].y;\n\n        case CoordinateSequence.Z:\n          return this._coordinates[index].z;\n      }\n\n      return Double.NaN;\n    },\n    getCoordinate: function getCoordinate() {\n      if (arguments.length === 1) {\n        var i = arguments[0];\n        return this._coordinates[i];\n      } else if (arguments.length === 2) {\n        var index = arguments[0],\n            coord = arguments[1];\n        coord.x = this._coordinates[index].x;\n        coord.y = this._coordinates[index].y;\n        coord.z = this._coordinates[index].z;\n      }\n    },\n    getCoordinateCopy: function getCoordinateCopy(i) {\n      return new Coordinate(this._coordinates[i]);\n    },\n    getDimension: function getDimension() {\n      return this._dimension;\n    },\n    getX: function getX(index) {\n      return this._coordinates[index].x;\n    },\n    expandEnvelope: function expandEnvelope(env) {\n      for (var i = 0; i < this._coordinates.length; i++) {\n        env.expandToInclude(this._coordinates[i]);\n      }\n\n      return env;\n    },\n    copy: function copy() {\n      var cloneCoordinates = new Array(this.size()).fill(null);\n\n      for (var i = 0; i < this._coordinates.length; i++) {\n        cloneCoordinates[i] = this._coordinates[i].copy();\n      }\n\n      return new CoordinateArraySequence(cloneCoordinates, this._dimension);\n    },\n    toString: function toString() {\n      if (this._coordinates.length > 0) {\n        var strBuilder = new StringBuilder(17 * this._coordinates.length);\n        strBuilder.append('(');\n        strBuilder.append(this._coordinates[0]);\n\n        for (var i = 1; i < this._coordinates.length; i++) {\n          strBuilder.append(\", \");\n          strBuilder.append(this._coordinates[i]);\n        }\n\n        strBuilder.append(')');\n        return strBuilder.toString();\n      } else {\n        return \"()\";\n      }\n    },\n    getY: function getY(index) {\n      return this._coordinates[index].y;\n    },\n    toCoordinateArray: function toCoordinateArray() {\n      return this._coordinates;\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateSequence, Serializable];\n    },\n    getClass: function getClass() {\n      return CoordinateArraySequence;\n    }\n  });\n  CoordinateArraySequence.serialVersionUID = -915438501601840650;\n\n  function CoordinateArraySequenceFactory() {}\n  extend(CoordinateArraySequenceFactory.prototype, {\n    readResolve: function readResolve() {\n      return CoordinateArraySequenceFactory.instance();\n    },\n    create: function create() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          var coordinates = arguments[0];\n          return new CoordinateArraySequence(coordinates);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          var coordSeq = arguments[0];\n          return new CoordinateArraySequence(coordSeq);\n        }\n      } else if (arguments.length === 2) {\n        var size = arguments[0],\n            dimension = arguments[1];\n        if (dimension > 3) dimension = 3;\n        if (dimension < 2) return new CoordinateArraySequence(size);\n        return new CoordinateArraySequence(size, dimension);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateSequenceFactory, Serializable];\n    },\n    getClass: function getClass() {\n      return CoordinateArraySequenceFactory;\n    }\n  });\n\n  CoordinateArraySequenceFactory.instance = function () {\n    return CoordinateArraySequenceFactory.instanceObject;\n  };\n\n  CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\n  CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n  // shared pointer\n  var i; // shortcuts\n\n  var defineProperty = Object.defineProperty;\n\n  function is(a, b) {\n    return a === b || a !== a && b !== b;\n  } // eslint-disable-line\n\n\n  var MapPolyfill = createCollection({\n    // WeakMap#delete(key:void*):boolean\n    'delete': sharedDelete,\n    // :was Map#get(key:void*[, d3fault:void*]):void*\n    // Map#has(key:void*):boolean\n    has: mapHas,\n    // Map#get(key:void*):boolean\n    get: sharedGet,\n    // Map#set(key:void*, value:void*):void\n    set: sharedSet,\n    // Map#keys(void):Iterator\n    keys: sharedKeys,\n    // Map#values(void):Iterator\n    values: sharedValues,\n    // Map#entries(void):Iterator\n    entries: mapEntries,\n    // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n    forEach: sharedForEach,\n    // Map#clear():\n    clear: sharedClear\n  });\n\n  function createCollection(proto, objectOnly) {\n    function Collection(a) {\n      if (!this || this.constructor !== Collection) return new Collection(a);\n      this._keys = [];\n      this._values = [];\n      this._itp = []; // iteration pointers\n\n      this.objectOnly = objectOnly; // parse initial iterable argument passed\n\n      if (a) init.call(this, a);\n    } // define size for non object-only collections\n\n\n    if (!objectOnly) {\n      defineProperty(proto, 'size', {\n        get: sharedSize\n      });\n    } // set prototype\n\n\n    proto.constructor = Collection;\n    Collection.prototype = proto;\n    return Collection;\n  }\n\n  function init(a) {\n    // init Set argument, like `[1,2,3,{}]`\n    if (this.add) a.forEach(this.add, this); // init Map argument like `[[1,2], [{}, 4]]`\n    else a.forEach(function (a) {\n        this.set(a[0], a[1]);\n      }, this);\n  }\n\n  function sharedDelete(key) {\n    if (this.has(key)) {\n      this._keys.splice(i, 1);\n\n      this._values.splice(i, 1); // update iteration pointers\n\n\n      this._itp.forEach(function (p) {\n        if (i < p[0]) p[0]--;\n      });\n    } // Aurora here does it while Canary doesn't\n\n\n    return i > -1;\n  }\n\n  function sharedGet(key) {\n    return this.has(key) ? this._values[i] : undefined;\n  }\n\n  function has(list, key) {\n    if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key'); // NaN or 0 passed\n\n    if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n    else i = list.indexOf(key);\n    return i > -1;\n  }\n\n  function mapHas(value) {\n    return has.call(this, this._keys, value);\n  }\n\n  function sharedSet(key, value) {\n    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n    return this;\n  }\n\n  function sharedClear() {\n    (this._keys || 0).length = this._values.length = 0;\n  }\n\n  function sharedKeys() {\n    return sharedIterator(this._itp, this._keys);\n  }\n\n  function sharedValues() {\n    return sharedIterator(this._itp, this._values);\n  }\n\n  function mapEntries() {\n    return sharedIterator(this._itp, this._keys, this._values);\n  }\n\n  function sharedIterator(itp, array, array2) {\n    var p = [0];\n    var done = false;\n    itp.push(p);\n    return {\n      next: function next() {\n        var v;\n        var k = p[0];\n\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n\n        return {\n          done: done,\n          value: v\n        };\n      }\n    };\n  }\n\n  function sharedSize() {\n    return this._values.length;\n  }\n\n  function sharedForEach(callback, context) {\n    var it = this.entries();\n\n    for (;;) {\n      var r = it.next();\n      if (r.done) break;\n      callback.call(context, r.value[1], r.value[0], this);\n    }\n  }\n\n  var MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map;\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n   *\n   * @extends {javascript.util.Map}\n   * @constructor\n   * @private\n   */\n\n  function HashMap() {\n    /**\n     * @type {Object}\n     * @private\n    */\n    this.map_ = new MapImpl();\n  }\n  HashMap.prototype = new Map$1();\n  /**\n   * @override\n   */\n\n  HashMap.prototype.get = function (key) {\n    return this.map_.get(key) || null;\n  };\n  /**\n   * @override\n   */\n\n\n  HashMap.prototype.put = function (key, value) {\n    this.map_.set(key, value);\n    return value;\n  };\n  /**\n   * @override\n   */\n\n\n  HashMap.prototype.values = function () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n\n    return arrayList;\n  };\n  /**\n   * @override\n   */\n\n\n  HashMap.prototype.entrySet = function () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) {\n      return hashSet.add(entry);\n    });\n    return hashSet;\n  };\n  /**\n   * @override\n   */\n\n\n  HashMap.prototype.size = function () {\n    return this.map_.size();\n  };\n\n  function PrecisionModel() {\n    this._modelType = null;\n    this._scale = null;\n\n    if (arguments.length === 0) {\n      this._modelType = PrecisionModel.FLOATING;\n    } else if (arguments.length === 1) {\n      if (arguments[0] instanceof Type) {\n        var modelType = arguments[0];\n        this._modelType = modelType;\n\n        if (modelType === PrecisionModel.FIXED) {\n          this.setScale(1.0);\n        }\n      } else if (typeof arguments[0] === \"number\") {\n        var scale = arguments[0];\n        this._modelType = PrecisionModel.FIXED;\n        this.setScale(scale);\n      } else if (arguments[0] instanceof PrecisionModel) {\n        var pm = arguments[0];\n        this._modelType = pm._modelType;\n        this._scale = pm._scale;\n      }\n    }\n  }\n  extend(PrecisionModel.prototype, {\n    equals: function equals(other) {\n      if (!(other instanceof PrecisionModel)) {\n        return false;\n      }\n\n      var otherPrecisionModel = other;\n      return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n    },\n    compareTo: function compareTo(o) {\n      var other = o;\n      var sigDigits = this.getMaximumSignificantDigits();\n      var otherSigDigits = other.getMaximumSignificantDigits();\n      return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n    },\n    getScale: function getScale() {\n      return this._scale;\n    },\n    isFloating: function isFloating() {\n      return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n    },\n    getType: function getType() {\n      return this._modelType;\n    },\n    toString: function toString() {\n      var description = \"UNKNOWN\";\n\n      if (this._modelType === PrecisionModel.FLOATING) {\n        description = \"Floating\";\n      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n        description = \"Floating-Single\";\n      } else if (this._modelType === PrecisionModel.FIXED) {\n        description = \"Fixed (Scale=\" + this.getScale() + \")\";\n      }\n\n      return description;\n    },\n    makePrecise: function makePrecise() {\n      if (typeof arguments[0] === \"number\") {\n        var val = arguments[0];\n        if (Double.isNaN(val)) return val;\n\n        if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n          var floatSingleVal = val;\n          return floatSingleVal;\n        }\n\n        if (this._modelType === PrecisionModel.FIXED) {\n          return Math.round(val * this._scale) / this._scale;\n        }\n\n        return val;\n      } else if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        if (this._modelType === PrecisionModel.FLOATING) return null;\n        coord.x = this.makePrecise(coord.x);\n        coord.y = this.makePrecise(coord.y);\n      }\n    },\n    getMaximumSignificantDigits: function getMaximumSignificantDigits() {\n      var maxSigDigits = 16;\n\n      if (this._modelType === PrecisionModel.FLOATING) {\n        maxSigDigits = 16;\n      } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n        maxSigDigits = 6;\n      } else if (this._modelType === PrecisionModel.FIXED) {\n        maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n      }\n\n      return maxSigDigits;\n    },\n    setScale: function setScale(scale) {\n      this._scale = Math.abs(scale);\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable, Comparable];\n    },\n    getClass: function getClass() {\n      return PrecisionModel;\n    }\n  });\n\n  PrecisionModel.mostPrecise = function (pm1, pm2) {\n    if (pm1.compareTo(pm2) >= 0) return pm1;\n    return pm2;\n  };\n\n  function Type() {\n    this._name = null;\n    var name = arguments[0];\n    this._name = name;\n    Type.nameToTypeMap.put(name, this);\n  }\n\n  extend(Type.prototype, {\n    readResolve: function readResolve() {\n      return Type.nameToTypeMap.get(this._name);\n    },\n    toString: function toString() {\n      return this._name;\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable];\n    },\n    getClass: function getClass() {\n      return Type;\n    }\n  });\n  Type.serialVersionUID = -5528602631731589822;\n  Type.nameToTypeMap = new HashMap();\n  PrecisionModel.Type = Type;\n  PrecisionModel.serialVersionUID = 7777263578777803835;\n  PrecisionModel.FIXED = new Type(\"FIXED\");\n  PrecisionModel.FLOATING = new Type(\"FLOATING\");\n  PrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\n  PrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\n  function GeometryFactory() {\n    this._precisionModel = null;\n    this._coordinateSequenceFactory = null;\n    this._SRID = null;\n\n    if (arguments.length === 0) {\n      GeometryFactory.call(this, new PrecisionModel(), 0);\n    } else if (arguments.length === 1) {\n      if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n        var coordinateSequenceFactory = arguments[0];\n        GeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n      } else if (arguments[0] instanceof PrecisionModel) {\n        var precisionModel = arguments[0];\n        GeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n      }\n    } else if (arguments.length === 2) {\n      var _precisionModel = arguments[0],\n          SRID = arguments[1];\n      GeometryFactory.call(this, _precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n    } else if (arguments.length === 3) {\n      var _precisionModel2 = arguments[0],\n          _SRID = arguments[1],\n          _coordinateSequenceFactory = arguments[2];\n      this._precisionModel = _precisionModel2;\n      this._coordinateSequenceFactory = _coordinateSequenceFactory;\n      this._SRID = _SRID;\n    }\n  }\n  extend(GeometryFactory.prototype, {\n    toGeometry: function toGeometry(envelope) {\n      if (envelope.isNull()) {\n        return this.createPoint();\n      }\n\n      if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n        return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n      }\n\n      if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n        return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n      }\n\n      return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n    },\n    createLineString: function createLineString() {\n      if (arguments.length === 0) {\n        return this.createLineString(this.getCoordinateSequenceFactory().create([]));\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          var coordinates = arguments[0];\n          return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          var _coordinates = arguments[0];\n          return new LineString(_coordinates, this);\n        }\n      }\n    },\n    createMultiLineString: function createMultiLineString() {\n      if (arguments.length === 0) {\n        return new MultiLineString(null, this);\n      } else if (arguments.length === 1) {\n        var lineStrings = arguments[0];\n        return new MultiLineString(lineStrings, this);\n      }\n    },\n    buildGeometry: function buildGeometry(geomList) {\n      var geomClass = null;\n      var isHeterogeneous = false;\n      var hasGeometryCollection = false;\n\n      for (var i = geomList.iterator(); i.hasNext();) {\n        var geom = i.next();\n        var partClass = geom.getClass();\n\n        if (geomClass === null) {\n          geomClass = partClass;\n        }\n\n        if (partClass !== geomClass) {\n          isHeterogeneous = true;\n        }\n\n        if (geom instanceof GeometryCollection) hasGeometryCollection = true;\n      }\n\n      if (geomClass === null) {\n        return this.createGeometryCollection();\n      }\n\n      if (isHeterogeneous || hasGeometryCollection) {\n        return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n      }\n\n      var geom0 = geomList.iterator().next();\n      var isCollection = geomList.size() > 1;\n\n      if (isCollection) {\n        if (geom0 instanceof Polygon) {\n          return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n        } else if (geom0 instanceof LineString) {\n          return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n        } else if (geom0 instanceof Point) {\n          return this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n        }\n\n        Assert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n      }\n\n      return geom0;\n    },\n    createMultiPointFromCoords: function createMultiPointFromCoords(coordinates) {\n      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n    },\n    createPoint: function createPoint() {\n      if (arguments.length === 0) {\n        return this.createPoint(this.getCoordinateSequenceFactory().create([]));\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          var coordinate = arguments[0];\n          return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          var coordinates = arguments[0];\n          return new Point(coordinates, this);\n        }\n      }\n    },\n    getCoordinateSequenceFactory: function getCoordinateSequenceFactory() {\n      return this._coordinateSequenceFactory;\n    },\n    createPolygon: function createPolygon() {\n      if (arguments.length === 0) {\n        return this.createPolygon(null, null);\n      } else if (arguments.length === 1) {\n        if (hasInterface(arguments[0], CoordinateSequence)) {\n          var shell = arguments[0];\n          return this.createPolygon(this.createLinearRing(shell));\n        } else if (arguments[0] instanceof Array) {\n          var _shell = arguments[0];\n          return this.createPolygon(this.createLinearRing(_shell));\n        } else if (arguments[0] instanceof LinearRing) {\n          var _shell2 = arguments[0];\n          return this.createPolygon(_shell2, null);\n        }\n      } else if (arguments.length === 2) {\n        var _shell3 = arguments[0],\n            holes = arguments[1];\n        return new Polygon(_shell3, holes, this);\n      }\n    },\n    getSRID: function getSRID() {\n      return this._SRID;\n    },\n    createGeometryCollection: function createGeometryCollection() {\n      if (arguments.length === 0) {\n        return new GeometryCollection(null, this);\n      } else if (arguments.length === 1) {\n        var geometries = arguments[0];\n        return new GeometryCollection(geometries, this);\n      }\n    },\n    createGeometry: function createGeometry(g) {\n      var editor = new GeometryEditor(this);\n      return editor.edit(g, {\n        edit: function edit() {\n          if (arguments.length === 2 && arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence)) {\n            var coordSeq = arguments[0];\n            return this._coordinateSequenceFactory.create(coordSeq);\n          }\n        }\n      });\n    },\n    getPrecisionModel: function getPrecisionModel() {\n      return this._precisionModel;\n    },\n    createLinearRing: function createLinearRing() {\n      if (arguments.length === 0) {\n        return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          var coordinates = arguments[0];\n          return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          var _coordinates2 = arguments[0];\n          return new LinearRing(_coordinates2, this);\n        }\n      }\n    },\n    createMultiPolygon: function createMultiPolygon() {\n      if (arguments.length === 0) {\n        return new MultiPolygon(null, this);\n      } else if (arguments.length === 1) {\n        var polygons = arguments[0];\n        return new MultiPolygon(polygons, this);\n      }\n    },\n    createMultiPoint: function createMultiPoint() {\n      if (arguments.length === 0) {\n        return new MultiPoint(null, this);\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          var point = arguments[0];\n          return new MultiPoint(point, this);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          var coordinates = arguments[0];\n\n          if (coordinates === null) {\n            return this.createMultiPoint(new Array(0).fill(null));\n          }\n\n          var points = new Array(coordinates.size()).fill(null);\n\n          for (var i = 0; i < coordinates.size(); i++) {\n            var ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n            CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n            points[i] = this.createPoint(ptSeq);\n          }\n\n          return this.createMultiPoint(points);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable];\n    },\n    getClass: function getClass() {\n      return GeometryFactory;\n    }\n  });\n\n  GeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n    var multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n    return multiPolygons.toArray(multiPolygonArray);\n  };\n\n  GeometryFactory.toGeometryArray = function (geometries) {\n    if (geometries === null) return null;\n    var geometryArray = new Array(geometries.size()).fill(null);\n    return geometries.toArray(geometryArray);\n  };\n\n  GeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n    return CoordinateArraySequenceFactory.instance();\n  };\n\n  GeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n    var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n    return multiLineStrings.toArray(multiLineStringArray);\n  };\n\n  GeometryFactory.toLineStringArray = function (lineStrings) {\n    var lineStringArray = new Array(lineStrings.size()).fill(null);\n    return lineStrings.toArray(lineStringArray);\n  };\n\n  GeometryFactory.toMultiPointArray = function (multiPoints) {\n    var multiPointArray = new Array(multiPoints.size()).fill(null);\n    return multiPoints.toArray(multiPointArray);\n  };\n\n  GeometryFactory.toLinearRingArray = function (linearRings) {\n    var linearRingArray = new Array(linearRings.size()).fill(null);\n    return linearRings.toArray(linearRingArray);\n  };\n\n  GeometryFactory.toPointArray = function (points) {\n    var pointArray = new Array(points.size()).fill(null);\n    return points.toArray(pointArray);\n  };\n\n  GeometryFactory.toPolygonArray = function (polygons) {\n    var polygonArray = new Array(polygons.size()).fill(null);\n    return polygons.toArray(polygonArray);\n  };\n\n  GeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n    exemplar.getPrecisionModel().makePrecise(coord);\n    return exemplar.getFactory().createPoint(coord);\n  };\n\n  GeometryFactory.serialVersionUID = -6820524753094095635;\n\n  var regExes = {\n    'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n    'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n    'spaces': /\\s+/,\n    'parenComma': /\\)\\s*,\\s*\\(/,\n    'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/,\n    // can't use {2} here\n    'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n    /**\n     * Class for reading and writing Well-Known Text.\n     *\n     * NOTE: Adapted from OpenLayers 2.11 implementation.\n     */\n\n    /** Create a new parser for WKT\n     *\n     * @param {GeometryFactory} geometryFactory\n     * @return An instance of WKTParser.\n     * @constructor\n     * @private\n     */\n\n  };\n  function WKTParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.precisionModel = this.geometryFactory.getPrecisionModel();\n  }\n  extend(WKTParser.prototype, {\n    /**\n     * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n     * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n     * and GEOMETRYCOLLECTION.\n     *\n     * @param {String} wkt A WKT string.\n     * @return {Geometry} A geometry instance.\n     * @private\n     */\n    read: function read(wkt) {\n      var geometry, type, str;\n      wkt = wkt.replace(/[\\n\\r]/g, ' ');\n      var matches = regExes.typeStr.exec(wkt);\n\n      if (wkt.search('EMPTY') !== -1) {\n        matches = regExes.emptyTypeStr.exec(wkt);\n        matches[2] = undefined;\n      }\n\n      if (matches) {\n        type = matches[1].toLowerCase();\n        str = matches[2];\n\n        if (parse[type]) {\n          geometry = parse[type].call(this, str);\n        }\n      }\n\n      if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);\n      return geometry;\n    },\n\n    /**\n     * Serialize a geometry into a WKT string.\n     *\n     * @param {Geometry} geometry A feature or array of features.\n     * @return {String} The WKT string representation of the input geometries.\n     * @private\n     */\n    write: function write(geometry) {\n      return this.extractGeometry(geometry);\n    },\n\n    /**\n     * Entry point to construct the WKT for a single Geometry object.\n     *\n     * @param {Geometry} geometry\n     * @return {String} A WKT string of representing the geometry.\n     * @private\n     */\n    extractGeometry: function extractGeometry(geometry) {\n      var type = geometry.getGeometryType().toLowerCase();\n\n      if (!extract[type]) {\n        return null;\n      }\n\n      var wktType = type.toUpperCase();\n      var data;\n\n      if (geometry.isEmpty()) {\n        data = wktType + ' EMPTY';\n      } else {\n        data = wktType + '(' + extract[type].call(this, geometry) + ')';\n      }\n\n      return data;\n    }\n  });\n  /**\n   * Object with properties corresponding to the geometry types. Property values\n   * are functions that do the actual data extraction.\n   * @private\n   */\n\n  var extract = {\n    coordinate: function coordinate(_coordinate) {\n      return _coordinate.x + ' ' + _coordinate.y;\n    },\n\n    /**\n     * Return a space delimited string of point coordinates.\n     *\n     * @param {Point}\n     *          point\n     * @return {String} A string of coordinates representing the point.\n     */\n    point: function point(_point) {\n      return extract.coordinate.call(this, _point._coordinates._coordinates[0]);\n    },\n\n    /**\n     * Return a comma delimited string of point coordinates from a multipoint.\n     *\n     * @param {MultiPoint}\n     *          multipoint\n     * @return {String} A string of point coordinate strings representing the\n     *         multipoint.\n     */\n    multipoint: function multipoint(_multipoint) {\n      var array = [];\n\n      for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {\n        array.push('(' + extract.point.call(this, _multipoint._geometries[i]) + ')');\n      }\n\n      return array.join(',');\n    },\n\n    /**\n     * Return a comma delimited string of point coordinates from a line.\n     *\n     * @param {LineString} linestring\n     * @return {String} A string of point coordinate strings representing the linestring.\n     */\n    linestring: function linestring(_linestring) {\n      var array = [];\n\n      for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {\n        array.push(extract.coordinate.call(this, _linestring._points._coordinates[i]));\n      }\n\n      return array.join(',');\n    },\n    linearring: function linearring(_linearring) {\n      var array = [];\n\n      for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {\n        array.push(extract.coordinate.call(this, _linearring._points._coordinates[i]));\n      }\n\n      return array.join(',');\n    },\n\n    /**\n     * Return a comma delimited string of linestring strings from a\n     * multilinestring.\n     *\n     * @param {MultiLineString} multilinestring\n     * @return {String} A string of of linestring strings representing the multilinestring.\n     */\n    multilinestring: function multilinestring(_multilinestring) {\n      var array = [];\n\n      for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {\n        array.push('(' + extract.linestring.call(this, _multilinestring._geometries[i]) + ')');\n      }\n\n      return array.join(',');\n    },\n\n    /**\n     * Return a comma delimited string of linear ring arrays from a polygon.\n     *\n     * @param {Polygon} polygon\n     * @return {String} An array of linear ring arrays representing the polygon.\n     */\n    polygon: function polygon(_polygon) {\n      var array = [];\n      array.push('(' + extract.linestring.call(this, _polygon._shell) + ')');\n\n      for (var i = 0, len = _polygon._holes.length; i < len; ++i) {\n        array.push('(' + extract.linestring.call(this, _polygon._holes[i]) + ')');\n      }\n\n      return array.join(',');\n    },\n\n    /**\n     * Return an array of polygon arrays from a multipolygon.\n     *\n     * @param {MultiPolygon} multipolygon\n     * @return {String} An array of polygon arrays representing the multipolygon.\n     */\n    multipolygon: function multipolygon(_multipolygon) {\n      var array = [];\n\n      for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {\n        array.push('(' + extract.polygon.call(this, _multipolygon._geometries[i]) + ')');\n      }\n\n      return array.join(',');\n    },\n\n    /**\n     * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n     * geometrycollection.\n     *\n     * @param {GeometryCollection} collection\n     * @return {String} internal WKT representation of the collection.\n     */\n    geometrycollection: function geometrycollection(collection) {\n      var array = [];\n\n      for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n        array.push(this.extractGeometry(collection._geometries[i]));\n      }\n\n      return array.join(',');\n    }\n  };\n  /**\n   * Object with properties corresponding to the geometry types. Property values\n   * are functions that do the actual parsing.\n   * @private\n   */\n\n  var parse = {\n    coord: function coord(str) {\n      var coords = str.trim().split(regExes.spaces);\n      var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]));\n      this.precisionModel.makePrecise(coord);\n      return coord;\n    },\n\n    /**\n     * Return point geometry given a point WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the point.\n     * @return {Point} A point geometry.\n     * @private\n     */\n    point: function point(str) {\n      if (str === undefined) return this.geometryFactory.createPoint();\n      return this.geometryFactory.createPoint(parse.coord.call(this, str));\n    },\n\n    /**\n     * Return a multipoint geometry given a multipoint WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the multipoint.\n     * @return {Point} A multipoint feature.\n     * @private\n     */\n    multipoint: function multipoint(str) {\n      if (str === undefined) return this.geometryFactory.createMultiPoint();\n      var point;\n      var points = str.trim().split(',');\n      var components = [];\n\n      for (var i = 0, len = points.length; i < len; ++i) {\n        point = points[i].replace(regExes.trimParens, '$1');\n        components.push(parse.point.call(this, point));\n      }\n\n      return this.geometryFactory.createMultiPoint(components);\n    },\n\n    /**\n     * Return a linestring geometry given a linestring WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the linestring.\n     * @return {LineString} A linestring geometry.\n     * @private\n     */\n    linestring: function linestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLineString();\n      }\n\n      var points = str.trim().split(',');\n      var components = [];\n\n      for (var i = 0, len = points.length; i < len; ++i) {\n        components.push(parse.coord.call(this, points[i]));\n      }\n\n      return this.geometryFactory.createLineString(components);\n    },\n\n    /**\n     * Return a linearring geometry given a linearring WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the linearring.\n     * @return {LinearRing} A linearring geometry.\n     * @private\n     */\n    linearring: function linearring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createLinearRing();\n      }\n\n      var points = str.trim().split(',');\n      var components = [];\n\n      for (var i = 0, len = points.length; i < len; ++i) {\n        components.push(parse.coord.call(this, points[i]));\n      }\n\n      return this.geometryFactory.createLinearRing(components);\n    },\n\n    /**\n     * Return a multilinestring geometry given a multilinestring WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the multilinestring.\n     * @return {MultiLineString} A multilinestring geometry.\n     * @private\n     */\n    multilinestring: function multilinestring(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiLineString();\n      }\n\n      var line;\n      var lines = str.trim().split(regExes.parenComma);\n      var components = [];\n\n      for (var i = 0, len = lines.length; i < len; ++i) {\n        line = lines[i].replace(regExes.trimParens, '$1');\n        components.push(parse.linestring.call(this, line));\n      }\n\n      return this.geometryFactory.createMultiLineString(components);\n    },\n\n    /**\n     * Return a polygon geometry given a polygon WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the polygon.\n     * @return {Polygon} A polygon geometry.\n     * @private\n     */\n    polygon: function polygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createPolygon();\n      }\n\n      var ring, linestring, linearring;\n      var rings = str.trim().split(regExes.parenComma);\n      var shell;\n      var holes = [];\n\n      for (var i = 0, len = rings.length; i < len; ++i) {\n        ring = rings[i].replace(regExes.trimParens, '$1');\n        linestring = parse.linestring.call(this, ring);\n        linearring = this.geometryFactory.createLinearRing(linestring._points);\n\n        if (i === 0) {\n          shell = linearring;\n        } else {\n          holes.push(linearring);\n        }\n      }\n\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n\n    /**\n     * Return a multipolygon geometry given a multipolygon WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the multipolygon.\n     * @return {MultiPolygon} A multipolygon geometry.\n     * @private\n     */\n    multipolygon: function multipolygon(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createMultiPolygon();\n      }\n\n      var polygon;\n      var polygons = str.trim().split(regExes.doubleParenComma);\n      var components = [];\n\n      for (var i = 0, len = polygons.length; i < len; ++i) {\n        polygon = polygons[i].replace(regExes.trimParens, '$1');\n        components.push(parse.polygon.call(this, polygon));\n      }\n\n      return this.geometryFactory.createMultiPolygon(components);\n    },\n\n    /**\n     * Return a geometrycollection given a geometrycollection WKT fragment.\n     *\n     * @param {String} str A WKT fragment representing the geometrycollection.\n     * @return {GeometryCollection}\n     * @private\n     */\n    geometrycollection: function geometrycollection(str) {\n      if (str === undefined) {\n        return this.geometryFactory.createGeometryCollection();\n      } // separate components of the collection with |\n\n\n      str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n      var wktArray = str.trim().split('|');\n      var components = [];\n\n      for (var i = 0, len = wktArray.length; i < len; ++i) {\n        components.push(this.read(wktArray[i]));\n      }\n\n      return this.geometryFactory.createGeometryCollection(components);\n    }\n  };\n\n  /**\n   * @module org/locationtech/jts/io/WKTWriter\n   */\n  /**\n   * Writes the Well-Known Text representation of a {@link Geometry}. The\n   * Well-Known Text format is defined in the <A\n   * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n   * Specification for SQL</A>.\n   * <p>\n   * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n   * model. Only the maximum number of decimal places necessary to represent the\n   * ordinates to the required precision will be output.\n   * <p>\n   * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n   * Under the spec, rings are output as <code>LINESTRING</code>s.\n   */\n\n  /**\n   * @param {GeometryFactory} geometryFactory\n   * @constructor\n   */\n\n  function WKTWriter(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory);\n  }\n  extend(WKTWriter.prototype, {\n    /**\n     * Converts a <code>Geometry</code> to its Well-known Text representation.\n     *\n     * @param {Geometry} geometry a <code>Geometry</code> to process.\n     * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n     *         Features Specification).\n     * @memberof module:org/locationtech/jts/io/WKTWriter#\n     */\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n  extend(WKTWriter, {\n    /**\n     * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n     * {@link Coordinate}s.\n     *\n     * @param p0 the first coordinate.\n     * @param p1 the second coordinate.\n     *\n     * @return the WKT.\n     * @private\n     */\n    toLineString: function toLineString(p0, p1) {\n      if (arguments.length !== 2) {\n        throw new Error('Not implemented');\n      }\n\n      return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';\n    }\n  });\n\n  function LineIntersector() {\n    this._result = null;\n    this._inputLines = Array(2).fill().map(function () {\n      return Array(2);\n    });\n    this._intPt = new Array(2).fill(null);\n    this._intLineIndex = null;\n    this._isProper = null;\n    this._pa = null;\n    this._pb = null;\n    this._precisionModel = null;\n    this._intPt[0] = new Coordinate();\n    this._intPt[1] = new Coordinate();\n    this._pa = this._intPt[0];\n    this._pb = this._intPt[1];\n    this._result = 0;\n  }\n  extend(LineIntersector.prototype, {\n    getIndexAlongSegment: function getIndexAlongSegment(segmentIndex, intIndex) {\n      this.computeIntLineIndex();\n      return this._intLineIndex[segmentIndex][intIndex];\n    },\n    getTopologySummary: function getTopologySummary() {\n      var catBuilder = new StringBuilder();\n      if (this.isEndPoint()) catBuilder.append(\" endpoint\");\n      if (this._isProper) catBuilder.append(\" proper\");\n      if (this.isCollinear()) catBuilder.append(\" collinear\");\n      return catBuilder.toString();\n    },\n    computeIntersection: function computeIntersection(p1, p2, p3, p4) {\n      this._inputLines[0][0] = p1;\n      this._inputLines[0][1] = p2;\n      this._inputLines[1][0] = p3;\n      this._inputLines[1][1] = p4;\n      this._result = this.computeIntersect(p1, p2, p3, p4);\n    },\n    getIntersectionNum: function getIntersectionNum() {\n      return this._result;\n    },\n    computeIntLineIndex: function computeIntLineIndex() {\n      if (arguments.length === 0) {\n        if (this._intLineIndex === null) {\n          this._intLineIndex = Array(2).fill().map(function () {\n            return Array(2);\n          });\n          this.computeIntLineIndex(0);\n          this.computeIntLineIndex(1);\n        }\n      } else if (arguments.length === 1) {\n        var segmentIndex = arguments[0];\n        var dist0 = this.getEdgeDistance(segmentIndex, 0);\n        var dist1 = this.getEdgeDistance(segmentIndex, 1);\n\n        if (dist0 > dist1) {\n          this._intLineIndex[segmentIndex][0] = 0;\n          this._intLineIndex[segmentIndex][1] = 1;\n        } else {\n          this._intLineIndex[segmentIndex][0] = 1;\n          this._intLineIndex[segmentIndex][1] = 0;\n        }\n      }\n    },\n    isProper: function isProper() {\n      return this.hasIntersection() && this._isProper;\n    },\n    setPrecisionModel: function setPrecisionModel(precisionModel) {\n      this._precisionModel = precisionModel;\n    },\n    isInteriorIntersection: function isInteriorIntersection() {\n      if (arguments.length === 0) {\n        if (this.isInteriorIntersection(0)) return true;\n        if (this.isInteriorIntersection(1)) return true;\n        return false;\n      } else if (arguments.length === 1) {\n        var inputLineIndex = arguments[0];\n\n        for (var i = 0; i < this._result; i++) {\n          if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    },\n    getIntersection: function getIntersection(intIndex) {\n      return this._intPt[intIndex];\n    },\n    isEndPoint: function isEndPoint() {\n      return this.hasIntersection() && !this._isProper;\n    },\n    hasIntersection: function hasIntersection() {\n      return this._result !== LineIntersector.NO_INTERSECTION;\n    },\n    getEdgeDistance: function getEdgeDistance(segmentIndex, intIndex) {\n      var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n      return dist;\n    },\n    isCollinear: function isCollinear() {\n      return this._result === LineIntersector.COLLINEAR_INTERSECTION;\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n    },\n    getEndpoint: function getEndpoint(segmentIndex, ptIndex) {\n      return this._inputLines[segmentIndex][ptIndex];\n    },\n    isIntersection: function isIntersection(pt) {\n      for (var i = 0; i < this._result; i++) {\n        if (this._intPt[i].equals2D(pt)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    getIntersectionAlongSegment: function getIntersectionAlongSegment(segmentIndex, intIndex) {\n      this.computeIntLineIndex();\n      return this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineIntersector;\n    }\n  });\n\n  LineIntersector.computeEdgeDistance = function (p, p0, p1) {\n    var dx = Math.abs(p1.x - p0.x);\n    var dy = Math.abs(p1.y - p0.y);\n    var dist = -1.0;\n\n    if (p.equals(p0)) {\n      dist = 0.0;\n    } else if (p.equals(p1)) {\n      if (dx > dy) dist = dx;else dist = dy;\n    } else {\n      var pdx = Math.abs(p.x - p0.x);\n      var pdy = Math.abs(p.y - p0.y);\n      if (dx > dy) dist = pdx;else dist = pdy;\n\n      if (dist === 0.0 && !p.equals(p0)) {\n        dist = Math.max(pdx, pdy);\n      }\n    }\n\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n    return dist;\n  };\n\n  LineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n    var dx = p.x - p1.x;\n    var dy = p.y - p1.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n    return dist;\n  };\n\n  LineIntersector.DONT_INTERSECT = 0;\n  LineIntersector.DO_INTERSECT = 1;\n  LineIntersector.COLLINEAR = 2;\n  LineIntersector.NO_INTERSECTION = 0;\n  LineIntersector.POINT_INTERSECTION = 1;\n  LineIntersector.COLLINEAR_INTERSECTION = 2;\n\n  function RobustLineIntersector() {\n    LineIntersector.apply(this);\n  }\n  inherits(RobustLineIntersector, LineIntersector);\n  extend(RobustLineIntersector.prototype, {\n    isInSegmentEnvelopes: function isInSegmentEnvelopes(intPt) {\n      var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n      var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n      return env0.contains(intPt) && env1.contains(intPt);\n    },\n    computeIntersection: function computeIntersection() {\n      if (arguments.length === 3) {\n        var p = arguments[0],\n            p1 = arguments[1],\n            p2 = arguments[2];\n        this._isProper = false;\n\n        if (Envelope.intersects(p1, p2, p)) {\n          if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n            this._isProper = true;\n\n            if (p.equals(p1) || p.equals(p2)) {\n              this._isProper = false;\n            }\n\n            this._result = LineIntersector.POINT_INTERSECTION;\n            return null;\n          }\n        }\n\n        this._result = LineIntersector.NO_INTERSECTION;\n      } else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n    },\n    normalizeToMinimum: function normalizeToMinimum(n1, n2, n3, n4, normPt) {\n      normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n      normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n      n1.x -= normPt.x;\n      n1.y -= normPt.y;\n      n2.x -= normPt.x;\n      n2.y -= normPt.y;\n      n3.x -= normPt.x;\n      n3.y -= normPt.y;\n      n4.x -= normPt.x;\n      n4.y -= normPt.y;\n    },\n    safeHCoordinateIntersection: function safeHCoordinateIntersection(p1, p2, q1, q2) {\n      var intPt = null;\n\n      try {\n        intPt = HCoordinate.intersection(p1, p2, q1, q2);\n      } catch (e) {\n        if (e instanceof NotRepresentableException) {\n          intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n        } else throw e;\n      } finally {}\n\n      return intPt;\n    },\n    intersection: function intersection(p1, p2, q1, q2) {\n      var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\n      if (!this.isInSegmentEnvelopes(intPt)) {\n        intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n      }\n\n      if (this._precisionModel !== null) {\n        this._precisionModel.makePrecise(intPt);\n      }\n\n      return intPt;\n    },\n    smallestInAbsValue: function smallestInAbsValue(x1, x2, x3, x4) {\n      var x = x1;\n      var xabs = Math.abs(x);\n\n      if (Math.abs(x2) < xabs) {\n        x = x2;\n        xabs = Math.abs(x2);\n      }\n\n      if (Math.abs(x3) < xabs) {\n        x = x3;\n        xabs = Math.abs(x3);\n      }\n\n      if (Math.abs(x4) < xabs) {\n        x = x4;\n      }\n\n      return x;\n    },\n    checkDD: function checkDD(p1, p2, q1, q2, intPt) {\n      var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n      var isIn = this.isInSegmentEnvelopes(intPtDD);\n      System.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\n      if (intPt.distance(intPtDD) > 0.0001) {\n        System.out.println(\"Distance = \" + intPt.distance(intPtDD));\n      }\n    },\n    intersectionWithNormalization: function intersectionWithNormalization(p1, p2, q1, q2) {\n      var n1 = new Coordinate(p1);\n      var n2 = new Coordinate(p2);\n      var n3 = new Coordinate(q1);\n      var n4 = new Coordinate(q2);\n      var normPt = new Coordinate();\n      this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n      var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n      intPt.x += normPt.x;\n      intPt.y += normPt.y;\n      return intPt;\n    },\n    computeCollinearIntersection: function computeCollinearIntersection(p1, p2, q1, q2) {\n      var p1q1p2 = Envelope.intersects(p1, p2, q1);\n      var p1q2p2 = Envelope.intersects(p1, p2, q2);\n      var q1p1q2 = Envelope.intersects(q1, q2, p1);\n      var q1p2q2 = Envelope.intersects(q1, q2, p2);\n\n      if (p1q1p2 && p1q2p2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = q2;\n        return LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (q1p1q2 && q1p2q2) {\n        this._intPt[0] = p1;\n        this._intPt[1] = p2;\n        return LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q1p2 && q1p1q2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = p1;\n        return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q1p2 && q1p2q2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = p2;\n        return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q2p2 && q1p1q2) {\n        this._intPt[0] = q2;\n        this._intPt[1] = p1;\n        return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q2p2 && q1p2q2) {\n        this._intPt[0] = q2;\n        this._intPt[1] = p2;\n        return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      return LineIntersector.NO_INTERSECTION;\n    },\n    normalizeToEnvCentre: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {\n      var minX0 = n00.x < n01.x ? n00.x : n01.x;\n      var minY0 = n00.y < n01.y ? n00.y : n01.y;\n      var maxX0 = n00.x > n01.x ? n00.x : n01.x;\n      var maxY0 = n00.y > n01.y ? n00.y : n01.y;\n      var minX1 = n10.x < n11.x ? n10.x : n11.x;\n      var minY1 = n10.y < n11.y ? n10.y : n11.y;\n      var maxX1 = n10.x > n11.x ? n10.x : n11.x;\n      var maxY1 = n10.y > n11.y ? n10.y : n11.y;\n      var intMinX = minX0 > minX1 ? minX0 : minX1;\n      var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n      var intMinY = minY0 > minY1 ? minY0 : minY1;\n      var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n      var intMidX = (intMinX + intMaxX) / 2.0;\n      var intMidY = (intMinY + intMaxY) / 2.0;\n      normPt.x = intMidX;\n      normPt.y = intMidY;\n      n00.x -= normPt.x;\n      n00.y -= normPt.y;\n      n01.x -= normPt.x;\n      n01.y -= normPt.y;\n      n10.x -= normPt.x;\n      n10.y -= normPt.y;\n      n11.x -= normPt.x;\n      n11.y -= normPt.y;\n    },\n    computeIntersect: function computeIntersect(p1, p2, q1, q2) {\n      this._isProper = false;\n      if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n      var Pq1 = Orientation.index(p1, p2, q1);\n      var Pq2 = Orientation.index(p1, p2, q2);\n\n      if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n        return LineIntersector.NO_INTERSECTION;\n      }\n\n      var Qp1 = Orientation.index(q1, q2, p1);\n      var Qp2 = Orientation.index(q1, q2, p2);\n\n      if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n        return LineIntersector.NO_INTERSECTION;\n      }\n\n      var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\n      if (collinear) {\n        return this.computeCollinearIntersection(p1, p2, q1, q2);\n      }\n\n      if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n        this._isProper = false;\n\n        if (p1.equals2D(q1) || p1.equals2D(q2)) {\n          this._intPt[0] = p1;\n        } else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n          this._intPt[0] = p2;\n        } else if (Pq1 === 0) {\n          this._intPt[0] = new Coordinate(q1);\n        } else if (Pq2 === 0) {\n          this._intPt[0] = new Coordinate(q2);\n        } else if (Qp1 === 0) {\n          this._intPt[0] = new Coordinate(p1);\n        } else if (Qp2 === 0) {\n          this._intPt[0] = new Coordinate(p2);\n        }\n      } else {\n        this._isProper = true;\n        this._intPt[0] = this.intersection(p1, p2, q1, q2);\n      }\n\n      return LineIntersector.POINT_INTERSECTION;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RobustLineIntersector;\n    }\n  });\n\n  RobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n    var nearestPt = p1;\n    var minDist = Distance.pointToSegment(p1, q1, q2);\n    var dist = Distance.pointToSegment(p2, q1, q2);\n\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = p2;\n    }\n\n    dist = Distance.pointToSegment(q1, p1, p2);\n\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q1;\n    }\n\n    dist = Distance.pointToSegment(q2, p1, p2);\n\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q2;\n    }\n\n    return nearestPt;\n  };\n\n  function LineSegment() {\n    this.p0 = null;\n    this.p1 = null;\n\n    if (arguments.length === 0) {\n      LineSegment.call(this, new Coordinate(), new Coordinate());\n    } else if (arguments.length === 1) {\n      var ls = arguments[0];\n      LineSegment.call(this, ls.p0, ls.p1);\n    } else if (arguments.length === 2) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      this.p0 = p0;\n      this.p1 = p1;\n    } else if (arguments.length === 4) {\n      var x0 = arguments[0],\n          y0 = arguments[1],\n          x1 = arguments[2],\n          y1 = arguments[3];\n      LineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n    }\n  }\n  extend(LineSegment.prototype, {\n    minX: function minX() {\n      return Math.min(this.p0.x, this.p1.x);\n    },\n    orientationIndex: function orientationIndex() {\n      if (arguments[0] instanceof LineSegment) {\n        var seg = arguments[0];\n        var orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n        var orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n        if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n        if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n        return 0;\n      } else if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        return Orientation.index(this.p0, this.p1, p);\n      }\n    },\n    toGeometry: function toGeometry(geomFactory) {\n      return geomFactory.createLineString([this.p0, this.p1]);\n    },\n    isVertical: function isVertical() {\n      return this.p0.x === this.p1.x;\n    },\n    equals: function equals(o) {\n      if (!(o instanceof LineSegment)) {\n        return false;\n      }\n\n      var other = o;\n      return this.p0.equals(other.p0) && this.p1.equals(other.p1);\n    },\n    intersection: function intersection(line) {\n      var li = new RobustLineIntersector();\n      li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n      if (li.hasIntersection()) return li.getIntersection(0);\n      return null;\n    },\n    project: function project() {\n      if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n        var r = this.projectionFactor(p);\n        var coord = new Coordinate();\n        coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n        coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n        return coord;\n      } else if (arguments[0] instanceof LineSegment) {\n        var seg = arguments[0];\n        var pf0 = this.projectionFactor(seg.p0);\n        var pf1 = this.projectionFactor(seg.p1);\n        if (pf0 >= 1.0 && pf1 >= 1.0) return null;\n        if (pf0 <= 0.0 && pf1 <= 0.0) return null;\n        var newp0 = this.project(seg.p0);\n        if (pf0 < 0.0) newp0 = this.p0;\n        if (pf0 > 1.0) newp0 = this.p1;\n        var newp1 = this.project(seg.p1);\n        if (pf1 < 0.0) newp1 = this.p0;\n        if (pf1 > 1.0) newp1 = this.p1;\n        return new LineSegment(newp0, newp1);\n      }\n    },\n    normalize: function normalize() {\n      if (this.p1.compareTo(this.p0) < 0) this.reverse();\n    },\n    angle: function angle() {\n      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n    },\n    getCoordinate: function getCoordinate(i) {\n      if (i === 0) return this.p0;\n      return this.p1;\n    },\n    distancePerpendicular: function distancePerpendicular(p) {\n      return Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n    },\n    minY: function minY() {\n      return Math.min(this.p0.y, this.p1.y);\n    },\n    midPoint: function midPoint() {\n      return LineSegment.midPoint(this.p0, this.p1);\n    },\n    projectionFactor: function projectionFactor(p) {\n      if (p.equals(this.p0)) return 0.0;\n      if (p.equals(this.p1)) return 1.0;\n      var dx = this.p1.x - this.p0.x;\n      var dy = this.p1.y - this.p0.y;\n      var len = dx * dx + dy * dy;\n      if (len <= 0.0) return Double.NaN;\n      var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n      return r;\n    },\n    closestPoints: function closestPoints(line) {\n      var intPt = this.intersection(line);\n\n      if (intPt !== null) {\n        return [intPt, intPt];\n      }\n\n      var closestPt = new Array(2).fill(null);\n      var minDistance = Double.MAX_VALUE;\n      var dist = null;\n      var close00 = this.closestPoint(line.p0);\n      minDistance = close00.distance(line.p0);\n      closestPt[0] = close00;\n      closestPt[1] = line.p0;\n      var close01 = this.closestPoint(line.p1);\n      dist = close01.distance(line.p1);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = close01;\n        closestPt[1] = line.p1;\n      }\n\n      var close10 = line.closestPoint(this.p0);\n      dist = close10.distance(this.p0);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p0;\n        closestPt[1] = close10;\n      }\n\n      var close11 = line.closestPoint(this.p1);\n      dist = close11.distance(this.p1);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p1;\n        closestPt[1] = close11;\n      }\n\n      return closestPt;\n    },\n    closestPoint: function closestPoint(p) {\n      var factor = this.projectionFactor(p);\n\n      if (factor > 0 && factor < 1) {\n        return this.project(p);\n      }\n\n      var dist0 = this.p0.distance(p);\n      var dist1 = this.p1.distance(p);\n      if (dist0 < dist1) return this.p0;\n      return this.p1;\n    },\n    maxX: function maxX() {\n      return Math.max(this.p0.x, this.p1.x);\n    },\n    getLength: function getLength() {\n      return this.p0.distance(this.p1);\n    },\n    compareTo: function compareTo(o) {\n      var other = o;\n      var comp0 = this.p0.compareTo(other.p0);\n      if (comp0 !== 0) return comp0;\n      return this.p1.compareTo(other.p1);\n    },\n    reverse: function reverse() {\n      var temp = this.p0;\n      this.p0 = this.p1;\n      this.p1 = temp;\n    },\n    equalsTopo: function equalsTopo(other) {\n      return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n    },\n    lineIntersection: function lineIntersection(line) {\n      try {\n        var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n        return intPt;\n      } catch (ex) {\n        if (ex instanceof NotRepresentableException) ; else throw ex;\n      } finally {}\n\n      return null;\n    },\n    maxY: function maxY() {\n      return Math.max(this.p0.y, this.p1.y);\n    },\n    pointAlongOffset: function pointAlongOffset(segmentLengthFraction, offsetDistance) {\n      var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n      var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n      var dx = this.p1.x - this.p0.x;\n      var dy = this.p1.y - this.p0.y;\n      var len = Math.sqrt(dx * dx + dy * dy);\n      var ux = 0.0;\n      var uy = 0.0;\n\n      if (offsetDistance !== 0.0) {\n        if (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n        ux = offsetDistance * dx / len;\n        uy = offsetDistance * dy / len;\n      }\n\n      var offsetx = segx - uy;\n      var offsety = segy + ux;\n      var coord = new Coordinate(offsetx, offsety);\n      return coord;\n    },\n    setCoordinates: function setCoordinates() {\n      if (arguments.length === 1) {\n        var ls = arguments[0];\n        this.setCoordinates(ls.p0, ls.p1);\n      } else if (arguments.length === 2) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n        this.p0.x = p0.x;\n        this.p0.y = p0.y;\n        this.p1.x = p1.x;\n        this.p1.y = p1.y;\n      }\n    },\n    segmentFraction: function segmentFraction(inputPt) {\n      var segFrac = this.projectionFactor(inputPt);\n      if (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n      return segFrac;\n    },\n    toString: function toString() {\n      return \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n    },\n    isHorizontal: function isHorizontal() {\n      return this.p0.y === this.p1.y;\n    },\n    distance: function distance() {\n      if (arguments[0] instanceof LineSegment) {\n        var ls = arguments[0];\n        return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n      } else if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        return Distance.pointToSegment(p, this.p0, this.p1);\n      }\n    },\n    pointAlong: function pointAlong(segmentLengthFraction) {\n      var coord = new Coordinate();\n      coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n      coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n      return coord;\n    },\n    hashCode: function hashCode() {\n      var bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n      bits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n      var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n      var bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n      bits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n      var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n      return hash0 ^ hash1;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable, Serializable];\n    },\n    getClass: function getClass() {\n      return LineSegment;\n    }\n  });\n\n  LineSegment.midPoint = function (p0, p1) {\n    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  };\n\n  LineSegment.serialVersionUID = 3252005833466256227;\n\n  function Location() {}\n  extend(Location.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Location;\n    }\n  });\n\n  Location.toLocationSymbol = function (locationValue) {\n    switch (locationValue) {\n      case Location.EXTERIOR:\n        return 'e';\n\n      case Location.BOUNDARY:\n        return 'b';\n\n      case Location.INTERIOR:\n        return 'i';\n\n      case Location.NONE:\n        return '-';\n    }\n\n    throw new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n  };\n\n  Location.INTERIOR = 0;\n  Location.BOUNDARY = 1;\n  Location.EXTERIOR = 2;\n  Location.NONE = -1;\n\n  function IntersectionMatrix() {\n    this._matrix = null;\n\n    if (arguments.length === 0) {\n      this._matrix = Array(3).fill().map(function () {\n        return Array(3);\n      });\n      this.setAll(Dimension.FALSE);\n    } else if (arguments.length === 1) {\n      if (typeof arguments[0] === \"string\") {\n        var elements = arguments[0];\n        IntersectionMatrix.call(this);\n        this.set(elements);\n      } else if (arguments[0] instanceof IntersectionMatrix) {\n        var other = arguments[0];\n        IntersectionMatrix.call(this);\n        this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n        this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n        this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n        this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n        this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n        this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n        this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n        this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n        this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n      }\n    }\n  }\n  extend(IntersectionMatrix.prototype, {\n    isIntersects: function isIntersects() {\n      return !this.isDisjoint();\n    },\n    isCovers: function isCovers() {\n      var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n      return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    },\n    isCoveredBy: function isCoveredBy() {\n      var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n      return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n    },\n    set: function set() {\n      if (arguments.length === 1) {\n        var dimensionSymbols = arguments[0];\n\n        for (var i = 0; i < dimensionSymbols.length; i++) {\n          var row = Math.trunc(i / 3);\n          var col = i % 3;\n          this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n        }\n      } else if (arguments.length === 3) {\n        var _row = arguments[0],\n            column = arguments[1],\n            dimensionValue = arguments[2];\n        this._matrix[_row][column] = dimensionValue;\n      }\n    },\n    isContains: function isContains() {\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    },\n    setAtLeast: function setAtLeast() {\n      if (arguments.length === 1) {\n        var minimumDimensionSymbols = arguments[0];\n\n        for (var i = 0; i < minimumDimensionSymbols.length; i++) {\n          var row = Math.trunc(i / 3);\n          var col = i % 3;\n          this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n        }\n      } else if (arguments.length === 3) {\n        var _row2 = arguments[0],\n            column = arguments[1],\n            minimumDimensionValue = arguments[2];\n\n        if (this._matrix[_row2][column] < minimumDimensionValue) {\n          this._matrix[_row2][column] = minimumDimensionValue;\n        }\n      }\n    },\n    setAtLeastIfValid: function setAtLeastIfValid(row, column, minimumDimensionValue) {\n      if (row >= 0 && column >= 0) {\n        this.setAtLeast(row, column, minimumDimensionValue);\n      }\n    },\n    isWithin: function isWithin() {\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n    },\n    isTouches: function isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA > dimensionOfGeometryB) {\n        return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n      }\n\n      if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n        return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n      }\n\n      return false;\n    },\n    isOverlaps: function isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n        return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      }\n\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n        return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      }\n\n      return false;\n    },\n    isEquals: function isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA !== dimensionOfGeometryB) {\n        return false;\n      }\n\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    },\n    toString: function toString() {\n      var builder = new StringBuilder(\"123456789\");\n\n      for (var ai = 0; ai < 3; ai++) {\n        for (var bi = 0; bi < 3; bi++) {\n          builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n        }\n      }\n\n      return builder.toString();\n    },\n    setAll: function setAll(dimensionValue) {\n      for (var ai = 0; ai < 3; ai++) {\n        for (var bi = 0; bi < 3; bi++) {\n          this._matrix[ai][bi] = dimensionValue;\n        }\n      }\n    },\n    get: function get(row, column) {\n      return this._matrix[row][column];\n    },\n    transpose: function transpose() {\n      var temp = this._matrix[1][0];\n      this._matrix[1][0] = this._matrix[0][1];\n      this._matrix[0][1] = temp;\n      temp = this._matrix[2][0];\n      this._matrix[2][0] = this._matrix[0][2];\n      this._matrix[0][2] = temp;\n      temp = this._matrix[2][1];\n      this._matrix[2][1] = this._matrix[1][2];\n      this._matrix[1][2] = temp;\n      return this;\n    },\n    matches: function matches(requiredDimensionSymbols) {\n      if (requiredDimensionSymbols.length !== 9) {\n        throw new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n      }\n\n      for (var ai = 0; ai < 3; ai++) {\n        for (var bi = 0; bi < 3; bi++) {\n          if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    add: function add(im) {\n      for (var i = 0; i < 3; i++) {\n        for (var j = 0; j < 3; j++) {\n          this.setAtLeast(i, j, im.get(i, j));\n        }\n      }\n    },\n    isDisjoint: function isDisjoint() {\n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n    },\n    isCrosses: function isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n        return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n      }\n\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n        return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      }\n\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n        return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [Clonable];\n    },\n    getClass: function getClass() {\n      return IntersectionMatrix;\n    }\n  });\n\n  IntersectionMatrix.matches = function () {\n    if (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n      var actualDimensionValue = arguments[0],\n          requiredDimensionSymbol = arguments[1];\n\n      if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n        return true;\n      }\n\n      if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n        return true;\n      }\n\n      if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n        return true;\n      }\n\n      if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n        return true;\n      }\n\n      if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n        return true;\n      }\n\n      if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n        return true;\n      }\n\n      return false;\n    } else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n      var actualDimensionSymbols = arguments[0],\n          requiredDimensionSymbols = arguments[1];\n      var m = new IntersectionMatrix(actualDimensionSymbols);\n      return m.matches(requiredDimensionSymbols);\n    }\n  };\n\n  IntersectionMatrix.isTrue = function (actualDimensionValue) {\n    if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n      return true;\n    }\n\n    return false;\n  };\n\n  function Angle() {}\n  extend(Angle.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Angle;\n    }\n  });\n\n  Angle.toDegrees = function (radians) {\n    return radians * 180 / Math.PI;\n  };\n\n  Angle.normalize = function (angle) {\n    while (angle > Math.PI) {\n      angle -= Angle.PI_TIMES_2;\n    }\n\n    while (angle <= -Math.PI) {\n      angle += Angle.PI_TIMES_2;\n    }\n\n    return angle;\n  };\n\n  Angle.angle = function () {\n    if (arguments.length === 1) {\n      var p = arguments[0];\n      return Math.atan2(p.y, p.x);\n    } else if (arguments.length === 2) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      var dx = p1.x - p0.x;\n      var dy = p1.y - p0.y;\n      return Math.atan2(dy, dx);\n    }\n  };\n\n  Angle.isAcute = function (p0, p1, p2) {\n    var dx0 = p0.x - p1.x;\n    var dy0 = p0.y - p1.y;\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dotprod = dx0 * dx1 + dy0 * dy1;\n    return dotprod > 0;\n  };\n\n  Angle.isObtuse = function (p0, p1, p2) {\n    var dx0 = p0.x - p1.x;\n    var dy0 = p0.y - p1.y;\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dotprod = dx0 * dx1 + dy0 * dy1;\n    return dotprod < 0;\n  };\n\n  Angle.interiorAngle = function (p0, p1, p2) {\n    var anglePrev = Angle.angle(p1, p0);\n    var angleNext = Angle.angle(p1, p2);\n    return Math.abs(angleNext - anglePrev);\n  };\n\n  Angle.normalizePositive = function (angle) {\n    if (angle < 0.0) {\n      while (angle < 0.0) {\n        angle += Angle.PI_TIMES_2;\n      }\n\n      if (angle >= Angle.PI_TIMES_2) angle = 0.0;\n    } else {\n      while (angle >= Angle.PI_TIMES_2) {\n        angle -= Angle.PI_TIMES_2;\n      }\n\n      if (angle < 0.0) angle = 0.0;\n    }\n\n    return angle;\n  };\n\n  Angle.angleBetween = function (tip1, tail, tip2) {\n    var a1 = Angle.angle(tail, tip1);\n    var a2 = Angle.angle(tail, tip2);\n    return Angle.diff(a1, a2);\n  };\n\n  Angle.diff = function (ang1, ang2) {\n    var delAngle = null;\n\n    if (ang1 < ang2) {\n      delAngle = ang2 - ang1;\n    } else {\n      delAngle = ang1 - ang2;\n    }\n\n    if (delAngle > Math.PI) {\n      delAngle = 2 * Math.PI - delAngle;\n    }\n\n    return delAngle;\n  };\n\n  Angle.toRadians = function (angleDegrees) {\n    return angleDegrees * Math.PI / 180.0;\n  };\n\n  Angle.getTurn = function (ang1, ang2) {\n    var crossproduct = Math.sin(ang2 - ang1);\n\n    if (crossproduct > 0) {\n      return Angle.COUNTERCLOCKWISE;\n    }\n\n    if (crossproduct < 0) {\n      return Angle.CLOCKWISE;\n    }\n\n    return Angle.NONE;\n  };\n\n  Angle.angleBetweenOriented = function (tip1, tail, tip2) {\n    var a1 = Angle.angle(tail, tip1);\n    var a2 = Angle.angle(tail, tip2);\n    var angDel = a2 - a1;\n    if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n    if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n    return angDel;\n  };\n\n  Angle.PI_TIMES_2 = 2.0 * Math.PI;\n  Angle.PI_OVER_2 = Math.PI / 2.0;\n  Angle.PI_OVER_4 = Math.PI / 4.0;\n  Angle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE;\n  Angle.CLOCKWISE = Orientation.CLOCKWISE;\n  Angle.NONE = Orientation.COLLINEAR;\n\n  function Triangle() {\n    this.p0 = null;\n    this.p1 = null;\n    this.p2 = null;\n    var p0 = arguments[0],\n        p1 = arguments[1],\n        p2 = arguments[2];\n    this.p0 = p0;\n    this.p1 = p1;\n    this.p2 = p2;\n  }\n  extend(Triangle.prototype, {\n    area: function area() {\n      return Triangle.area(this.p0, this.p1, this.p2);\n    },\n    signedArea: function signedArea() {\n      return Triangle.signedArea(this.p0, this.p1, this.p2);\n    },\n    interpolateZ: function interpolateZ(p) {\n      if (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n      return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);\n    },\n    longestSideLength: function longestSideLength() {\n      return Triangle.longestSideLength(this.p0, this.p1, this.p2);\n    },\n    isAcute: function isAcute() {\n      return Triangle.isAcute(this.p0, this.p1, this.p2);\n    },\n    circumcentre: function circumcentre() {\n      return Triangle.circumcentre(this.p0, this.p1, this.p2);\n    },\n    area3D: function area3D() {\n      return Triangle.area3D(this.p0, this.p1, this.p2);\n    },\n    centroid: function centroid() {\n      return Triangle.centroid(this.p0, this.p1, this.p2);\n    },\n    inCentre: function inCentre() {\n      return Triangle.inCentre(this.p0, this.p1, this.p2);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Triangle;\n    }\n  });\n\n  Triangle.area = function (a, b, c) {\n    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n  };\n\n  Triangle.signedArea = function (a, b, c) {\n    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n  };\n\n  Triangle.det = function (m00, m01, m10, m11) {\n    return m00 * m11 - m01 * m10;\n  };\n\n  Triangle.interpolateZ = function (p, v0, v1, v2) {\n    var x0 = v0.x;\n    var y0 = v0.y;\n    var a = v1.x - x0;\n    var b = v2.x - x0;\n    var c = v1.y - y0;\n    var d = v2.y - y0;\n    var det = a * d - b * c;\n    var dx = p.x - x0;\n    var dy = p.y - y0;\n    var t = (d * dx - b * dy) / det;\n    var u = (-c * dx + a * dy) / det;\n    var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n    return z;\n  };\n\n  Triangle.longestSideLength = function (a, b, c) {\n    var lenAB = a.distance(b);\n    var lenBC = b.distance(c);\n    var lenCA = c.distance(a);\n    var maxLen = lenAB;\n    if (lenBC > maxLen) maxLen = lenBC;\n    if (lenCA > maxLen) maxLen = lenCA;\n    return maxLen;\n  };\n\n  Triangle.isAcute = function (a, b, c) {\n    if (!Angle.isAcute(a, b, c)) return false;\n    if (!Angle.isAcute(b, c, a)) return false;\n    if (!Angle.isAcute(c, a, b)) return false;\n    return true;\n  };\n\n  Triangle.circumcentre = function (a, b, c) {\n    var cx = c.x;\n    var cy = c.y;\n    var ax = a.x - cx;\n    var ay = a.y - cy;\n    var bx = b.x - cx;\n    var by = b.y - cy;\n    var denom = 2 * Triangle.det(ax, ay, bx, by);\n    var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n    var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n    var ccx = cx - numx / denom;\n    var ccy = cy + numy / denom;\n    return new Coordinate(ccx, ccy);\n  };\n\n  Triangle.perpendicularBisector = function (a, b) {\n    var dx = b.x - a.x;\n    var dy = b.y - a.y;\n    var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n    var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n    return new HCoordinate(l1, l2);\n  };\n\n  Triangle.angleBisector = function (a, b, c) {\n    var len0 = b.distance(a);\n    var len2 = b.distance(c);\n    var frac = len0 / (len0 + len2);\n    var dx = c.x - a.x;\n    var dy = c.y - a.y;\n    var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n    return splitPt;\n  };\n\n  Triangle.area3D = function (a, b, c) {\n    var ux = b.x - a.x;\n    var uy = b.y - a.y;\n    var uz = b.z - a.z;\n    var vx = c.x - a.x;\n    var vy = c.y - a.y;\n    var vz = c.z - a.z;\n    var crossx = uy * vz - uz * vy;\n    var crossy = uz * vx - ux * vz;\n    var crossz = ux * vy - uy * vx;\n    var absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n    var area3D = Math.sqrt(absSq) / 2;\n    return area3D;\n  };\n\n  Triangle.centroid = function (a, b, c) {\n    var x = (a.x + b.x + c.x) / 3;\n    var y = (a.y + b.y + c.y) / 3;\n    return new Coordinate(x, y);\n  };\n\n  Triangle.inCentre = function (a, b, c) {\n    var len0 = b.distance(c);\n    var len1 = a.distance(c);\n    var len2 = a.distance(b);\n    var circum = len0 + len1 + len2;\n    var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n    var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n    return new Coordinate(inCentreX, inCentreY);\n  };\n\n\n\n  var geom = /*#__PURE__*/Object.freeze({\n    Coordinate: Coordinate,\n    CoordinateList: CoordinateList,\n    Envelope: Envelope,\n    LineSegment: LineSegment,\n    GeometryFactory: GeometryFactory,\n    Geometry: Geometry,\n    Point: Point,\n    LineString: LineString,\n    LinearRing: LinearRing,\n    Polygon: Polygon,\n    GeometryCollection: GeometryCollection,\n    MultiPoint: MultiPoint,\n    MultiLineString: MultiLineString,\n    MultiPolygon: MultiPolygon,\n    Dimension: Dimension,\n    IntersectionMatrix: IntersectionMatrix,\n    PrecisionModel: PrecisionModel,\n    Location: Location,\n    Triangle: Triangle\n  });\n\n  function PointPairDistance() {\n    this._pt = [new Coordinate(), new Coordinate()];\n    this._distance = Double.NaN;\n    this._isNull = true;\n  }\n  extend(PointPairDistance.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this._pt;\n    },\n    getCoordinate: function getCoordinate(i) {\n      return this._pt[i];\n    },\n    setMinimum: function setMinimum() {\n      if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n      } else if (arguments.length === 2) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n\n        if (this._isNull) {\n          this.initialize(p0, p1);\n          return null;\n        }\n\n        var dist = p0.distance(p1);\n        if (dist < this._distance) this.initialize(p0, p1, dist);\n      }\n    },\n    initialize: function initialize() {\n      if (arguments.length === 0) {\n        this._isNull = true;\n      } else if (arguments.length === 2) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n\n        this._pt[0].setCoordinate(p0);\n\n        this._pt[1].setCoordinate(p1);\n\n        this._distance = p0.distance(p1);\n        this._isNull = false;\n      } else if (arguments.length === 3) {\n        var _p = arguments[0],\n            _p2 = arguments[1],\n            distance = arguments[2];\n\n        this._pt[0].setCoordinate(_p);\n\n        this._pt[1].setCoordinate(_p2);\n\n        this._distance = distance;\n        this._isNull = false;\n      }\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(this._pt[0], this._pt[1]);\n    },\n    getDistance: function getDistance() {\n      return this._distance;\n    },\n    setMaximum: function setMaximum() {\n      if (arguments.length === 1) {\n        var ptDist = arguments[0];\n        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n      } else if (arguments.length === 2) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n\n        if (this._isNull) {\n          this.initialize(p0, p1);\n          return null;\n        }\n\n        var dist = p0.distance(p1);\n        if (dist > this._distance) this.initialize(p0, p1, dist);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointPairDistance;\n    }\n  });\n\n  function DistanceToPoint() {}\n  extend(DistanceToPoint.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DistanceToPoint;\n    }\n  });\n\n  DistanceToPoint.computeDistance = function () {\n    if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {\n      var line = arguments[0],\n          pt = arguments[1],\n          ptDist = arguments[2];\n      var tempSegment = new LineSegment();\n      var coords = line.getCoordinates();\n\n      for (var i = 0; i < coords.length - 1; i++) {\n        tempSegment.setCoordinates(coords[i], coords[i + 1]);\n        var closestPt = tempSegment.closestPoint(pt);\n        ptDist.setMinimum(closestPt, pt);\n      }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {\n      var poly = arguments[0],\n          _pt = arguments[1],\n          _ptDist = arguments[2];\n      DistanceToPoint.computeDistance(poly.getExteriorRing(), _pt, _ptDist);\n\n      for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n        DistanceToPoint.computeDistance(poly.getInteriorRingN(i), _pt, _ptDist);\n      }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {\n      var geom = arguments[0],\n          _pt2 = arguments[1],\n          _ptDist2 = arguments[2];\n\n      if (geom instanceof LineString) {\n        DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);\n      } else if (geom instanceof Polygon) {\n        DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);\n      } else if (geom instanceof GeometryCollection) {\n        var gc = geom;\n\n        for (var i = 0; i < gc.getNumGeometries(); i++) {\n          var g = gc.getGeometryN(i);\n          DistanceToPoint.computeDistance(g, _pt2, _ptDist2);\n        }\n      } else {\n        _ptDist2.setMinimum(geom.getCoordinate(), _pt2);\n      }\n    } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {\n      var segment = arguments[0],\n          _pt3 = arguments[1],\n          _ptDist3 = arguments[2];\n      var closestPt = segment.closestPoint(_pt3);\n\n      _ptDist3.setMinimum(closestPt, _pt3);\n    }\n  };\n\n  function DiscreteHausdorffDistance() {\n    this._g0 = null;\n    this._g1 = null;\n    this._ptDist = new PointPairDistance();\n    this._densifyFrac = 0.0;\n    var g0 = arguments[0],\n        g1 = arguments[1];\n    this._g0 = g0;\n    this._g1 = g1;\n  }\n  extend(DiscreteHausdorffDistance.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this._ptDist.getCoordinates();\n    },\n    setDensifyFraction: function setDensifyFraction(densifyFrac) {\n      if (densifyFrac > 1.0 || densifyFrac <= 0.0) throw new IllegalArgumentException(\"Fraction is not in range (0.0 - 1.0]\");\n      this._densifyFrac = densifyFrac;\n    },\n    compute: function compute(g0, g1) {\n      this.computeOrientedDistance(g0, g1, this._ptDist);\n      this.computeOrientedDistance(g1, g0, this._ptDist);\n    },\n    distance: function distance() {\n      this.compute(this._g0, this._g1);\n      return this._ptDist.getDistance();\n    },\n    computeOrientedDistance: function computeOrientedDistance(discreteGeom, geom, ptDist) {\n      var distFilter = new MaxPointDistanceFilter(geom);\n      discreteGeom.apply(distFilter);\n      ptDist.setMaximum(distFilter.getMaxPointDistance());\n\n      if (this._densifyFrac > 0) {\n        var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n        discreteGeom.apply(fracFilter);\n        ptDist.setMaximum(fracFilter.getMaxPointDistance());\n      }\n    },\n    orientedDistance: function orientedDistance() {\n      this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n      return this._ptDist.getDistance();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DiscreteHausdorffDistance;\n    }\n  });\n\n  DiscreteHausdorffDistance.distance = function () {\n    if (arguments.length === 2) {\n      var g0 = arguments[0],\n          g1 = arguments[1];\n      var dist = new DiscreteHausdorffDistance(g0, g1);\n      return dist.distance();\n    } else if (arguments.length === 3) {\n      var _g = arguments[0],\n          _g2 = arguments[1],\n          densifyFrac = arguments[2];\n      var dist = new DiscreteHausdorffDistance(_g, _g2);\n      dist.setDensifyFraction(densifyFrac);\n      return dist.distance();\n    }\n  };\n\n  function MaxPointDistanceFilter() {\n    this._maxPtDist = new PointPairDistance();\n    this._minPtDist = new PointPairDistance();\n    this._euclideanDist = new DistanceToPoint();\n    this._geom = null;\n    var geom = arguments[0];\n    this._geom = geom;\n  }\n\n  extend(MaxPointDistanceFilter.prototype, {\n    filter: function filter(pt) {\n      this._minPtDist.initialize();\n\n      DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n\n      this._maxPtDist.setMaximum(this._minPtDist);\n    },\n    getMaxPointDistance: function getMaxPointDistance() {\n      return this._maxPtDist;\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateFilter];\n    },\n    getClass: function getClass() {\n      return MaxPointDistanceFilter;\n    }\n  });\n\n  function MaxDensifiedByFractionDistanceFilter() {\n    this._maxPtDist = new PointPairDistance();\n    this._minPtDist = new PointPairDistance();\n    this._geom = null;\n    this._numSubSegs = 0;\n    var geom = arguments[0],\n        fraction = arguments[1];\n    this._geom = geom;\n    this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n  }\n\n  extend(MaxDensifiedByFractionDistanceFilter.prototype, {\n    filter: function filter(seq, index) {\n      if (index === 0) return null;\n      var p0 = seq.getCoordinate(index - 1);\n      var p1 = seq.getCoordinate(index);\n      var delx = (p1.x - p0.x) / this._numSubSegs;\n      var dely = (p1.y - p0.y) / this._numSubSegs;\n\n      for (var i = 0; i < this._numSubSegs; i++) {\n        var x = p0.x + i * delx;\n        var y = p0.y + i * dely;\n        var pt = new Coordinate(x, y);\n\n        this._minPtDist.initialize();\n\n        DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n\n        this._maxPtDist.setMaximum(this._minPtDist);\n      }\n    },\n    isDone: function isDone() {\n      return false;\n    },\n    isGeometryChanged: function isGeometryChanged() {\n      return false;\n    },\n    getMaxPointDistance: function getMaxPointDistance() {\n      return this._maxPtDist;\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateSequenceFilter];\n    },\n    getClass: function getClass() {\n      return MaxDensifiedByFractionDistanceFilter;\n    }\n  });\n  DiscreteHausdorffDistance.MaxPointDistanceFilter = MaxPointDistanceFilter;\n  DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter = MaxDensifiedByFractionDistanceFilter;\n\n\n\n  var distance_module = /*#__PURE__*/Object.freeze({\n    DiscreteHausdorffDistance: DiscreteHausdorffDistance,\n    DistanceToPoint: DistanceToPoint,\n    PointPairDistance: PointPairDistance\n  });\n\n  function ItemVisitor() {}\n  extend(ItemVisitor.prototype, {\n    visitItem: function visitItem(item) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ItemVisitor;\n    }\n  });\n\n  function PointOnGeometryLocator() {}\n  extend(PointOnGeometryLocator.prototype, {\n    locate: function locate(p) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointOnGeometryLocator;\n    }\n  });\n\n  function IntervalRTreeNode() {\n    this._min = Double.POSITIVE_INFINITY;\n    this._max = Double.NEGATIVE_INFINITY;\n  }\n  extend(IntervalRTreeNode.prototype, {\n    getMin: function getMin() {\n      return this._min;\n    },\n    intersects: function intersects(queryMin, queryMax) {\n      if (this._min > queryMax || this._max < queryMin) return false;\n      return true;\n    },\n    getMax: function getMax() {\n      return this._max;\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IntervalRTreeNode;\n    }\n  });\n\n  function NodeComparator() {}\n\n  extend(NodeComparator.prototype, {\n    compare: function compare(o1, o2) {\n      var n1 = o1;\n      var n2 = o2;\n      var mid1 = (n1._min + n1._max) / 2;\n      var mid2 = (n2._min + n2._max) / 2;\n      if (mid1 < mid2) return -1;\n      if (mid1 > mid2) return 1;\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return NodeComparator;\n    }\n  });\n  IntervalRTreeNode.NodeComparator = NodeComparator;\n\n  function IntervalRTreeLeafNode() {\n    IntervalRTreeNode.apply(this);\n    this._item = null;\n    var min = arguments[0],\n        max = arguments[1],\n        item = arguments[2];\n    this._min = min;\n    this._max = max;\n    this._item = item;\n  }\n  inherits(IntervalRTreeLeafNode, IntervalRTreeNode);\n  extend(IntervalRTreeLeafNode.prototype, {\n    query: function query(queryMin, queryMax, visitor) {\n      if (!this.intersects(queryMin, queryMax)) return null;\n      visitor.visitItem(this._item);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IntervalRTreeLeafNode;\n    }\n  });\n\n  var Collections = {\n    reverseOrder: function reverseOrder() {\n      return {\n        compare: function compare(a, b) {\n          return b.compareTo(a);\n        }\n      };\n    },\n    min: function min(l) {\n      Collections.sort(l);\n      return l.get(0);\n    },\n    sort: function sort(l, c) {\n      var a = l.toArray();\n\n      if (c) {\n        Arrays.sort(a, c);\n      } else {\n        Arrays.sort(a);\n      }\n\n      var i = l.iterator();\n\n      for (var pos = 0, alen = a.length; pos < alen; pos++) {\n        i.next();\n        i.set(a[pos]);\n      }\n    },\n    singletonList: function singletonList(o) {\n      var arrayList = new ArrayList();\n      arrayList.add(o);\n      return arrayList;\n    }\n  };\n\n  function IntervalRTreeBranchNode() {\n    IntervalRTreeNode.apply(this);\n    this._node1 = null;\n    this._node2 = null;\n    var n1 = arguments[0],\n        n2 = arguments[1];\n    this._node1 = n1;\n    this._node2 = n2;\n    this.buildExtent(this._node1, this._node2);\n  }\n  inherits(IntervalRTreeBranchNode, IntervalRTreeNode);\n  extend(IntervalRTreeBranchNode.prototype, {\n    buildExtent: function buildExtent(n1, n2) {\n      this._min = Math.min(n1._min, n2._min);\n      this._max = Math.max(n1._max, n2._max);\n    },\n    query: function query(queryMin, queryMax, visitor) {\n      if (!this.intersects(queryMin, queryMax)) {\n        return null;\n      }\n\n      if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n      if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IntervalRTreeBranchNode;\n    }\n  });\n\n  function SortedPackedIntervalRTree() {\n    this._leaves = new ArrayList();\n    this._root = null;\n    this._level = 0;\n  }\n  extend(SortedPackedIntervalRTree.prototype, {\n    buildTree: function buildTree() {\n      Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n      var src = this._leaves;\n      var temp = null;\n      var dest = new ArrayList();\n\n      while (true) {\n        this.buildLevel(src, dest);\n        if (dest.size() === 1) return dest.get(0);\n        temp = src;\n        src = dest;\n        dest = temp;\n      }\n    },\n    insert: function insert(min, max, item) {\n      if (this._root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\n      this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n    },\n    query: function query(min, max, visitor) {\n      this.init();\n\n      this._root.query(min, max, visitor);\n    },\n    buildRoot: function buildRoot() {\n      if (this._root !== null) return null;\n      this._root = this.buildTree();\n    },\n    printNode: function printNode(node) {\n      System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n    },\n    init: function init() {\n      if (this._root !== null) return null;\n      this.buildRoot();\n    },\n    buildLevel: function buildLevel(src, dest) {\n      this._level++;\n      dest.clear();\n\n      for (var i = 0; i < src.size(); i += 2) {\n        var n1 = src.get(i);\n        var n2 = i + 1 < src.size() ? src.get(i) : null;\n\n        if (n2 === null) {\n          dest.add(n1);\n        } else {\n          var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n          dest.add(node);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SortedPackedIntervalRTree;\n    }\n  });\n\n  function LinearComponentExtracter() {\n    this._lines = null;\n    this._isForcedToLineString = false;\n\n    if (arguments.length === 1) {\n      var lines = arguments[0];\n      this._lines = lines;\n    } else if (arguments.length === 2) {\n      var _lines = arguments[0],\n          isForcedToLineString = arguments[1];\n      this._lines = _lines;\n      this._isForcedToLineString = isForcedToLineString;\n    }\n  }\n  extend(LinearComponentExtracter.prototype, {\n    filter: function filter(geom) {\n      if (this._isForcedToLineString && geom instanceof LinearRing) {\n        var line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\n        this._lines.add(line);\n\n        return null;\n      }\n\n      if (geom instanceof LineString) this._lines.add(geom);\n    },\n    setForceToLineString: function setForceToLineString(isForcedToLineString) {\n      this._isForcedToLineString = isForcedToLineString;\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryComponentFilter];\n    },\n    getClass: function getClass() {\n      return LinearComponentExtracter;\n    }\n  });\n\n  LinearComponentExtracter.getGeometry = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n    } else if (arguments.length === 2) {\n      var _geom = arguments[0],\n          forceToLineString = arguments[1];\n      return _geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(_geom, forceToLineString));\n    }\n  };\n\n  LinearComponentExtracter.getLines = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      return LinearComponentExtracter.getLines(geom, false);\n    } else if (arguments.length === 2) {\n      if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n        var geoms = arguments[0],\n            _lines2 = arguments[1];\n\n        for (var i = geoms.iterator(); i.hasNext();) {\n          var g = i.next();\n          LinearComponentExtracter.getLines(g, _lines2);\n        }\n\n        return _lines2;\n      } else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n        var _geom2 = arguments[0],\n            forceToLineString = arguments[1];\n        var lines = new ArrayList();\n\n        _geom2.apply(new LinearComponentExtracter(lines, forceToLineString));\n\n        return lines;\n      } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n        var _geom3 = arguments[0],\n            _lines3 = arguments[1];\n\n        if (_geom3 instanceof LineString) {\n          _lines3.add(_geom3);\n        } else {\n          _geom3.apply(new LinearComponentExtracter(_lines3));\n        }\n\n        return _lines3;\n      }\n    } else if (arguments.length === 3) {\n      if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n        var _geoms = arguments[0],\n            _lines4 = arguments[1],\n            _forceToLineString = arguments[2];\n\n        for (var i = _geoms.iterator(); i.hasNext();) {\n          var g = i.next();\n          LinearComponentExtracter.getLines(g, _lines4, _forceToLineString);\n        }\n\n        return _lines4;\n      } else if (typeof arguments[2] === \"boolean\" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n        var _geom4 = arguments[0],\n            _lines5 = arguments[1],\n            _forceToLineString2 = arguments[2];\n\n        _geom4.apply(new LinearComponentExtracter(_lines5, _forceToLineString2));\n\n        return _lines5;\n      }\n    }\n  };\n\n  function ArrayListVisitor() {\n    this._items = new ArrayList();\n  }\n  extend(ArrayListVisitor.prototype, {\n    visitItem: function visitItem(item) {\n      this._items.add(item);\n    },\n    getItems: function getItems() {\n      return this._items;\n    },\n    interfaces_: function interfaces_() {\n      return [ItemVisitor];\n    },\n    getClass: function getClass() {\n      return ArrayListVisitor;\n    }\n  });\n\n  function RayCrossingCounter() {\n    this._p = null;\n    this._crossingCount = 0;\n    this._isPointOnSegment = false;\n    var p = arguments[0];\n    this._p = p;\n  }\n  extend(RayCrossingCounter.prototype, {\n    countSegment: function countSegment(p1, p2) {\n      if (p1.x < this._p.x && p2.x < this._p.x) return null;\n\n      if (this._p.x === p2.x && this._p.y === p2.y) {\n        this._isPointOnSegment = true;\n        return null;\n      }\n\n      if (p1.y === this._p.y && p2.y === this._p.y) {\n        var minx = p1.x;\n        var maxx = p2.x;\n\n        if (minx > maxx) {\n          minx = p2.x;\n          maxx = p1.x;\n        }\n\n        if (this._p.x >= minx && this._p.x <= maxx) {\n          this._isPointOnSegment = true;\n        }\n\n        return null;\n      }\n\n      if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n        var orient = Orientation.index(p1, p2, this._p);\n\n        if (orient === Orientation.COLLINEAR) {\n          this._isPointOnSegment = true;\n          return null;\n        }\n\n        if (p2.y < p1.y) {\n          orient = -orient;\n        }\n\n        if (orient === Orientation.LEFT) {\n          this._crossingCount++;\n        }\n      }\n    },\n    isPointInPolygon: function isPointInPolygon() {\n      return this.getLocation() !== Location.EXTERIOR;\n    },\n    getLocation: function getLocation() {\n      if (this._isPointOnSegment) return Location.BOUNDARY;\n\n      if (this._crossingCount % 2 === 1) {\n        return Location.INTERIOR;\n      }\n\n      return Location.EXTERIOR;\n    },\n    isOnSegment: function isOnSegment() {\n      return this._isPointOnSegment;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RayCrossingCounter;\n    }\n  });\n\n  RayCrossingCounter.locatePointInRing = function () {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      var p = arguments[0],\n          ring = arguments[1];\n      var counter = new RayCrossingCounter(p);\n      var p1 = new Coordinate();\n      var p2 = new Coordinate();\n\n      for (var i = 1; i < ring.size(); i++) {\n        ring.getCoordinate(i, p1);\n        ring.getCoordinate(i - 1, p2);\n        counter.countSegment(p1, p2);\n        if (counter.isOnSegment()) return counter.getLocation();\n      }\n\n      return counter.getLocation();\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      var _p = arguments[0],\n          _ring = arguments[1];\n      var counter = new RayCrossingCounter(_p);\n\n      for (var i = 1; i < _ring.length; i++) {\n        var p1 = _ring[i];\n        var p2 = _ring[i - 1];\n        counter.countSegment(p1, p2);\n        if (counter.isOnSegment()) return counter.getLocation();\n      }\n\n      return counter.getLocation();\n    }\n  };\n\n  function IndexedPointInAreaLocator() {\n    this._index = null;\n    var g = arguments[0];\n    if (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException(\"Argument must be Polygonal or LinearRing\");\n    this._index = new IntervalIndexedGeometry(g);\n  }\n  extend(IndexedPointInAreaLocator.prototype, {\n    locate: function locate(p) {\n      var rcc = new RayCrossingCounter(p);\n      var visitor = new SegmentVisitor(rcc);\n\n      this._index.query(p.y, p.y, visitor);\n\n      return rcc.getLocation();\n    },\n    interfaces_: function interfaces_() {\n      return [PointOnGeometryLocator];\n    },\n    getClass: function getClass() {\n      return IndexedPointInAreaLocator;\n    }\n  });\n\n  function SegmentVisitor() {\n    this._counter = null;\n    var counter = arguments[0];\n    this._counter = counter;\n  }\n\n  extend(SegmentVisitor.prototype, {\n    visitItem: function visitItem(item) {\n      var seg = item;\n\n      this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n    },\n    interfaces_: function interfaces_() {\n      return [ItemVisitor];\n    },\n    getClass: function getClass() {\n      return SegmentVisitor;\n    }\n  });\n\n  function IntervalIndexedGeometry() {\n    this._index = new SortedPackedIntervalRTree();\n    var geom = arguments[0];\n    this.init(geom);\n  }\n\n  extend(IntervalIndexedGeometry.prototype, {\n    init: function init(geom) {\n      var lines = LinearComponentExtracter.getLines(geom);\n\n      for (var i = lines.iterator(); i.hasNext();) {\n        var line = i.next();\n        var pts = line.getCoordinates();\n        this.addLine(pts);\n      }\n    },\n    addLine: function addLine(pts) {\n      for (var i = 1; i < pts.length; i++) {\n        var seg = new LineSegment(pts[i - 1], pts[i]);\n        var min = Math.min(seg.p0.y, seg.p1.y);\n        var max = Math.max(seg.p0.y, seg.p1.y);\n\n        this._index.insert(min, max, seg);\n      }\n    },\n    query: function query() {\n      if (arguments.length === 2) {\n        var min = arguments[0],\n            max = arguments[1];\n        var visitor = new ArrayListVisitor();\n\n        this._index.query(min, max, visitor);\n\n        return visitor.getItems();\n      } else if (arguments.length === 3) {\n        var _min = arguments[0],\n            _max = arguments[1],\n            _visitor = arguments[2];\n\n        this._index.query(_min, _max, _visitor);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IntervalIndexedGeometry;\n    }\n  });\n  IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\n  IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\n  function PointLocation() {}\n  extend(PointLocation.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointLocation;\n    }\n  });\n\n  PointLocation.isOnLine = function () {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      var p = arguments[0],\n          line = arguments[1];\n      var lineIntersector = new RobustLineIntersector();\n      var p0 = new Coordinate();\n      var p1 = new Coordinate();\n      var n = line.size();\n\n      for (var i = 1; i < n; i++) {\n        line.getCoordinate(i - 1, p0);\n        line.getCoordinate(i, p1);\n        lineIntersector.computeIntersection(p, p0, p1);\n\n        if (lineIntersector.hasIntersection()) {\n          return true;\n        }\n      }\n\n      return false;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      var _p = arguments[0],\n          _line = arguments[1];\n      var lineIntersector = new RobustLineIntersector();\n\n      for (var i = 1; i < _line.length; i++) {\n        var p0 = _line[i - 1];\n        var p1 = _line[i];\n        lineIntersector.computeIntersection(_p, p0, p1);\n\n        if (lineIntersector.hasIntersection()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  PointLocation.locateInRing = function (p, ring) {\n    return RayCrossingCounter.locatePointInRing(p, ring);\n  };\n\n  PointLocation.isInRing = function (p, ring) {\n    return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n  };\n\n  function GeometryCollectionIterator() {\n    this._parent = null;\n    this._atStart = null;\n    this._max = null;\n    this._index = null;\n    this._subcollectionIterator = null;\n    var parent = arguments[0];\n    this._parent = parent;\n    this._atStart = true;\n    this._index = 0;\n    this._max = parent.getNumGeometries();\n  }\n  extend(GeometryCollectionIterator.prototype, {\n    next: function next() {\n      if (this._atStart) {\n        this._atStart = false;\n        if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n        return this._parent;\n      }\n\n      if (this._subcollectionIterator !== null) {\n        if (this._subcollectionIterator.hasNext()) {\n          return this._subcollectionIterator.next();\n        } else {\n          this._subcollectionIterator = null;\n        }\n      }\n\n      if (this._index >= this._max) {\n        throw new NoSuchElementException();\n      }\n\n      var obj = this._parent.getGeometryN(this._index++);\n\n      if (obj instanceof GeometryCollection) {\n        this._subcollectionIterator = new GeometryCollectionIterator(obj);\n        return this._subcollectionIterator.next();\n      }\n\n      return obj;\n    },\n    remove: function remove() {\n      throw new UnsupportedOperationException(this.getClass().getName());\n    },\n    hasNext: function hasNext() {\n      if (this._atStart) {\n        return true;\n      }\n\n      if (this._subcollectionIterator !== null) {\n        if (this._subcollectionIterator.hasNext()) {\n          return true;\n        }\n\n        this._subcollectionIterator = null;\n      }\n\n      if (this._index >= this._max) {\n        return false;\n      }\n\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [Iterator];\n    },\n    getClass: function getClass() {\n      return GeometryCollectionIterator;\n    }\n  });\n\n  GeometryCollectionIterator.isAtomic = function (geom) {\n    return !(geom instanceof GeometryCollection);\n  };\n\n  function SimplePointInAreaLocator() {\n    this._geom = null;\n    var geom = arguments[0];\n    this._geom = geom;\n  }\n  extend(SimplePointInAreaLocator.prototype, {\n    locate: function locate(p) {\n      return SimplePointInAreaLocator.locate(p, this._geom);\n    },\n    interfaces_: function interfaces_() {\n      return [PointOnGeometryLocator];\n    },\n    getClass: function getClass() {\n      return SimplePointInAreaLocator;\n    }\n  });\n\n  SimplePointInAreaLocator.locatePointInPolygon = function (p, poly) {\n    if (poly.isEmpty()) return Location.EXTERIOR;\n    var shell = poly.getExteriorRing();\n    var shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n    if (shellLoc !== Location.INTERIOR) return shellLoc;\n\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      var hole = poly.getInteriorRingN(i);\n      var holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n      if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n      if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n    }\n\n    return Location.INTERIOR;\n  };\n\n  SimplePointInAreaLocator.locatePointInRing = function (p, ring) {\n    if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n    return PointLocation.locateInRing(p, ring.getCoordinates());\n  };\n\n  SimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n    return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n  };\n\n  SimplePointInAreaLocator.locateInGeometry = function (p, geom) {\n    if (geom instanceof Polygon) {\n      return SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n    } else if (geom instanceof GeometryCollection) {\n      var geomi = new GeometryCollectionIterator(geom);\n\n      while (geomi.hasNext()) {\n        var g2 = geomi.next();\n\n        if (g2 !== geom) {\n          var loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n          if (loc !== Location.EXTERIOR) return loc;\n        }\n      }\n    }\n\n    return Location.EXTERIOR;\n  };\n\n  SimplePointInAreaLocator.locate = function (p, geom) {\n    if (geom.isEmpty()) return Location.EXTERIOR;\n    return SimplePointInAreaLocator.locateInGeometry(p, geom);\n  };\n\n\n\n  var locate = /*#__PURE__*/Object.freeze({\n    IndexedPointInAreaLocator: IndexedPointInAreaLocator,\n    PointOnGeometryLocator: PointOnGeometryLocator,\n    SimplePointInAreaLocator: SimplePointInAreaLocator\n  });\n\n  function SimilarityMeasure() {}\n  extend(SimilarityMeasure.prototype, {\n    measure: function measure(g1, g2) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SimilarityMeasure;\n    }\n  });\n\n  function AreaSimilarityMeasure() {}\n  extend(AreaSimilarityMeasure.prototype, {\n    measure: function measure(g1, g2) {\n      var areaInt = g1.intersection(g2).getArea();\n      var areaUnion = g1.union(g2).getArea();\n      return areaInt / areaUnion;\n    },\n    interfaces_: function interfaces_() {\n      return [SimilarityMeasure];\n    },\n    getClass: function getClass() {\n      return AreaSimilarityMeasure;\n    }\n  });\n\n  function HausdorffSimilarityMeasure() {}\n  extend(HausdorffSimilarityMeasure.prototype, {\n    measure: function measure(g1, g2) {\n      var distance = DiscreteHausdorffDistance.distance(g1, g2, HausdorffSimilarityMeasure.DENSIFY_FRACTION);\n      var env = new Envelope(g1.getEnvelopeInternal());\n      env.expandToInclude(g2.getEnvelopeInternal());\n      var envSize = HausdorffSimilarityMeasure.diagonalSize(env);\n      var measure = 1 - distance / envSize;\n      return measure;\n    },\n    interfaces_: function interfaces_() {\n      return [SimilarityMeasure];\n    },\n    getClass: function getClass() {\n      return HausdorffSimilarityMeasure;\n    }\n  });\n\n  HausdorffSimilarityMeasure.diagonalSize = function (env) {\n    if (env.isNull()) return 0.0;\n    var width = env.getWidth();\n    var hgt = env.getHeight();\n    return Math.sqrt(width * width + hgt * hgt);\n  };\n\n  HausdorffSimilarityMeasure.DENSIFY_FRACTION = 0.25;\n\n  function SimilarityMeasureCombiner() {}\n  extend(SimilarityMeasureCombiner.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SimilarityMeasureCombiner;\n    }\n  });\n\n  SimilarityMeasureCombiner.combine = function (measure1, measure2) {\n    return Math.min(measure1, measure2);\n  };\n\n\n\n  var match = /*#__PURE__*/Object.freeze({\n    AreaSimilarityMeasure: AreaSimilarityMeasure,\n    HausdorffSimilarityMeasure: HausdorffSimilarityMeasure,\n    SimilarityMeasure: SimilarityMeasure,\n    SimilarityMeasureCombiner: SimilarityMeasureCombiner\n  });\n\n  function Centroid() {\n    this._areaBasePt = null;\n    this._triangleCent3 = new Coordinate();\n    this._areasum2 = 0;\n    this._cg3 = new Coordinate();\n    this._lineCentSum = new Coordinate();\n    this._totalLength = 0.0;\n    this._ptCount = 0;\n    this._ptCentSum = new Coordinate();\n    var geom = arguments[0];\n    this._areaBasePt = null;\n    this.add(geom);\n  }\n  extend(Centroid.prototype, {\n    setAreaBasePoint: function setAreaBasePoint(basePt) {\n      this._areaBasePt = basePt;\n    },\n    addPoint: function addPoint(pt) {\n      this._ptCount += 1;\n      this._ptCentSum.x += pt.x;\n      this._ptCentSum.y += pt.y;\n    },\n    addLineSegments: function addLineSegments(pts) {\n      var lineLen = 0.0;\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        var segmentLen = pts[i].distance(pts[i + 1]);\n        if (segmentLen === 0.0) continue;\n        lineLen += segmentLen;\n        var midx = (pts[i].x + pts[i + 1].x) / 2;\n        this._lineCentSum.x += segmentLen * midx;\n        var midy = (pts[i].y + pts[i + 1].y) / 2;\n        this._lineCentSum.y += segmentLen * midy;\n      }\n\n      this._totalLength += lineLen;\n      if (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n    },\n    addHole: function addHole(pts) {\n      var isPositiveArea = Orientation.isCCW(pts);\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n      }\n\n      this.addLineSegments(pts);\n    },\n    getCentroid: function getCentroid() {\n      var cent = new Coordinate();\n\n      if (Math.abs(this._areasum2) > 0.0) {\n        cent.x = this._cg3.x / 3 / this._areasum2;\n        cent.y = this._cg3.y / 3 / this._areasum2;\n      } else if (this._totalLength > 0.0) {\n        cent.x = this._lineCentSum.x / this._totalLength;\n        cent.y = this._lineCentSum.y / this._totalLength;\n      } else if (this._ptCount > 0) {\n        cent.x = this._ptCentSum.x / this._ptCount;\n        cent.y = this._ptCentSum.y / this._ptCount;\n      } else {\n        return null;\n      }\n\n      return cent;\n    },\n    addShell: function addShell(pts) {\n      if (pts.length > 0) this.setAreaBasePoint(pts[0]);\n      var isPositiveArea = !Orientation.isCCW(pts);\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n      }\n\n      this.addLineSegments(pts);\n    },\n    addTriangle: function addTriangle(p0, p1, p2, isPositiveArea) {\n      var sign = isPositiveArea ? 1.0 : -1.0;\n      Centroid.centroid3(p0, p1, p2, this._triangleCent3);\n      var area2 = Centroid.area2(p0, p1, p2);\n      this._cg3.x += sign * area2 * this._triangleCent3.x;\n      this._cg3.y += sign * area2 * this._triangleCent3.y;\n      this._areasum2 += sign * area2;\n    },\n    add: function add() {\n      if (arguments[0] instanceof Polygon) {\n        var _poly = arguments[0];\n        this.addShell(_poly.getExteriorRing().getCoordinates());\n\n        for (var i = 0; i < _poly.getNumInteriorRing(); i++) {\n          this.addHole(_poly.getInteriorRingN(i).getCoordinates());\n        }\n      } else if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n        if (geom.isEmpty()) return null;\n\n        if (geom instanceof Point) {\n          this.addPoint(geom.getCoordinate());\n        } else if (geom instanceof LineString) {\n          this.addLineSegments(geom.getCoordinates());\n        } else if (geom instanceof Polygon) {\n          var poly = geom;\n          this.add(poly);\n        } else if (geom instanceof GeometryCollection) {\n          var gc = geom;\n\n          for (var i = 0; i < gc.getNumGeometries(); i++) {\n            this.add(gc.getGeometryN(i));\n          }\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Centroid;\n    }\n  });\n\n  Centroid.area2 = function (p1, p2, p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n  };\n\n  Centroid.centroid3 = function (p1, p2, p3, c) {\n    c.x = p1.x + p2.x + p3.x;\n    c.y = p1.y + p2.y + p3.y;\n    return null;\n  };\n\n  Centroid.getCentroid = function (geom) {\n    var cent = new Centroid(geom);\n    return cent.getCentroid();\n  };\n\n  function CGAlgorithms() {}\n  extend(CGAlgorithms.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CGAlgorithms;\n    }\n  });\n\n  CGAlgorithms.orientationIndex = function (p1, p2, q) {\n    return CGAlgorithmsDD.orientationIndex(p1, p2, q);\n  };\n\n  CGAlgorithms.signedArea = function () {\n    if (arguments[0] instanceof Array) {\n      var ring = arguments[0];\n      if (ring.length < 3) return 0.0;\n      var sum = 0.0;\n      var x0 = ring[0].x;\n\n      for (var i = 1; i < ring.length - 1; i++) {\n        var x = ring[i].x - x0;\n        var y1 = ring[i + 1].y;\n        var y2 = ring[i - 1].y;\n        sum += x * (y2 - y1);\n      }\n\n      return sum / 2.0;\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var _ring = arguments[0];\n\n      var n = _ring.size();\n\n      if (n < 3) return 0.0;\n      var p0 = new Coordinate();\n      var p1 = new Coordinate();\n      var p2 = new Coordinate();\n\n      _ring.getCoordinate(0, p1);\n\n      _ring.getCoordinate(1, p2);\n\n      var x0 = p1.x;\n      p2.x -= x0;\n      var sum = 0.0;\n\n      for (var i = 1; i < n - 1; i++) {\n        p0.y = p1.y;\n        p1.x = p2.x;\n        p1.y = p2.y;\n\n        _ring.getCoordinate(i + 1, p2);\n\n        p2.x -= x0;\n        sum += p1.x * (p0.y - p2.y);\n      }\n\n      return sum / 2.0;\n    }\n  };\n\n  CGAlgorithms.distanceLineLine = function (A, B, C, D) {\n    if (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);\n    if (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);\n    var noIntersection = false;\n\n    if (!Envelope.intersects(A, B, C, D)) {\n      noIntersection = true;\n    } else {\n      var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\n      if (denom === 0) {\n        noIntersection = true;\n      } else {\n        var r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n        var s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n        var s = s_num / denom;\n        var r = r_num / denom;\n\n        if (r < 0 || r > 1 || s < 0 || s > 1) {\n          noIntersection = true;\n        }\n      }\n    }\n\n    if (noIntersection) {\n      return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n    }\n\n    return 0.0;\n  };\n\n  CGAlgorithms.isPointInRing = function (p, ring) {\n    return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n  };\n\n  CGAlgorithms.computeLength = function (pts) {\n    var n = pts.size();\n    if (n <= 1) return 0.0;\n    var len = 0.0;\n    var p = new Coordinate();\n    pts.getCoordinate(0, p);\n    var x0 = p.x;\n    var y0 = p.y;\n\n    for (var i = 1; i < n; i++) {\n      pts.getCoordinate(i, p);\n      var x1 = p.x;\n      var y1 = p.y;\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      len += Math.sqrt(dx * dx + dy * dy);\n      x0 = x1;\n      y0 = y1;\n    }\n\n    return len;\n  };\n\n  CGAlgorithms.isCCW = function (ring) {\n    var nPts = ring.length - 1;\n    if (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n    var hiPt = ring[0];\n    var hiIndex = 0;\n\n    for (var i = 1; i <= nPts; i++) {\n      var p = ring[i];\n\n      if (p.y > hiPt.y) {\n        hiPt = p;\n        hiIndex = i;\n      }\n    }\n\n    var iPrev = hiIndex;\n\n    do {\n      iPrev = iPrev - 1;\n      if (iPrev < 0) iPrev = nPts;\n    } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\n    var iNext = hiIndex;\n\n    do {\n      iNext = (iNext + 1) % nPts;\n    } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\n    var prev = ring[iPrev];\n    var next = ring[iNext];\n    if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n    var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n    var isCCW = false;\n\n    if (disc === 0) {\n      isCCW = prev.x > next.x;\n    } else {\n      isCCW = disc > 0;\n    }\n\n    return isCCW;\n  };\n\n  CGAlgorithms.locatePointInRing = function (p, ring) {\n    return RayCrossingCounter.locatePointInRing(p, ring);\n  };\n\n  CGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2);\n  };\n\n  CGAlgorithms.computeOrientation = function (p1, p2, q) {\n    return CGAlgorithms.orientationIndex(p1, p2, q);\n  };\n\n  CGAlgorithms.distancePointLine = function () {\n    if (arguments.length === 2) {\n      var p = arguments[0],\n          line = arguments[1];\n      if (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n      var minDistance = p.distance(line[0]);\n\n      for (var i = 0; i < line.length - 1; i++) {\n        var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n\n        if (dist < minDistance) {\n          minDistance = dist;\n        }\n      }\n\n      return minDistance;\n    } else if (arguments.length === 3) {\n      var _p = arguments[0],\n          A = arguments[1],\n          B = arguments[2];\n      if (A.x === B.x && A.y === B.y) return _p.distance(A);\n      var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n      var r = ((_p.x - A.x) * (B.x - A.x) + (_p.y - A.y) * (B.y - A.y)) / len2;\n      if (r <= 0.0) return _p.distance(A);\n      if (r >= 1.0) return _p.distance(B);\n      var s = ((A.y - _p.y) * (B.x - A.x) - (A.x - _p.x) * (B.y - A.y)) / len2;\n      return Math.abs(s) * Math.sqrt(len2);\n    }\n  };\n\n  CGAlgorithms.isOnLine = function (p, pt) {\n    var lineIntersector = new RobustLineIntersector();\n\n    for (var i = 1; i < pt.length; i++) {\n      var p0 = pt[i - 1];\n      var p1 = pt[i];\n      lineIntersector.computeIntersection(p, p0, p1);\n\n      if (lineIntersector.hasIntersection()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  CGAlgorithms.CLOCKWISE = -1;\n  CGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;\n  CGAlgorithms.COUNTERCLOCKWISE = 1;\n  CGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;\n  CGAlgorithms.COLLINEAR = 0;\n  CGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;\n\n  /**\n   * @param {string=} message Optional message\n   * @extends {Error}\n   * @constructor\n   * @private\n   */\n  function EmptyStackException(message) {\n    this.message = message || '';\n  }\n  EmptyStackException.prototype = new Error();\n  /**\n   * @type {string}\n   */\n\n  EmptyStackException.prototype.name = 'EmptyStackException';\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n   *\n   * @extends {List}\n   * @constructor\n   * @private\n   */\n\n  function Stack() {\n    /**\n     * @type {Array}\n     * @private\n     */\n    this.array_ = [];\n  }\n  Stack.prototype = new List();\n  /**\n   * @override\n   */\n\n  Stack.prototype.add = function (e) {\n    this.array_.push(e);\n    return true;\n  };\n  /**\n   * @override\n   */\n\n\n  Stack.prototype.get = function (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException();\n    }\n\n    return this.array_[index];\n  };\n  /**\n   * Pushes an item onto the top of this stack.\n   * @param {Object} e\n   * @return {Object}\n   */\n\n\n  Stack.prototype.push = function (e) {\n    this.array_.push(e);\n    return e;\n  };\n  /**\n   * Pushes an item onto the top of this stack.\n   * @param {Object} e\n   * @return {Object}\n   */\n\n\n  Stack.prototype.pop = function (e) {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n\n    return this.array_.pop();\n  };\n  /**\n   * Looks at the object at the top of this stack without removing it from the\n   * stack.\n   * @return {Object}\n   */\n\n\n  Stack.prototype.peek = function () {\n    if (this.array_.length === 0) {\n      throw new EmptyStackException();\n    }\n\n    return this.array_[this.array_.length - 1];\n  };\n  /**\n   * Tests if this stack is empty.\n   * @return {boolean} true if and only if this stack contains no items; false\n   *         otherwise.\n   */\n\n\n  Stack.prototype.empty = function () {\n    if (this.array_.length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * @return {boolean}\n   */\n\n\n  Stack.prototype.isEmpty = function () {\n    return this.empty();\n  };\n  /**\n   * Returns the 1-based position where an object is on this stack. If the object\n   * o occurs as an item in this stack, this method returns the distance from the\n   * top of the stack of the occurrence nearest the top of the stack; the topmost\n   * item on the stack is considered to be at distance 1. The equals method is\n   * used to compare o to the items in this stack.\n   *\n   * NOTE: does not currently actually use equals. (=== is used)\n   *\n   * @param {Object} o\n   * @return {number} the 1-based position from the top of the stack where the\n   *         object is located; the return value -1 indicates that the object is\n   *         not on the stack.\n   */\n\n\n  Stack.prototype.search = function (o) {\n    return this.array_.indexOf(o);\n  };\n  /**\n   * @return {number}\n   * @export\n   */\n\n\n  Stack.prototype.size = function () {\n    return this.array_.length;\n  };\n  /**\n   * @return {Array}\n   */\n\n\n  Stack.prototype.toArray = function () {\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this.array_[i]);\n    }\n\n    return array;\n  };\n\n  function UniqueCoordinateArrayFilter() {\n    this.treeSet = new TreeSet();\n    this.list = new ArrayList();\n  }\n  extend(UniqueCoordinateArrayFilter.prototype, {\n    filter: function filter(coord) {\n      if (!this.treeSet.contains(coord)) {\n        this.list.add(coord);\n        this.treeSet.add(coord);\n      }\n    },\n    getCoordinates: function getCoordinates() {\n      var coordinates = new Array(this.list.size()).fill(null);\n      return this.list.toArray(coordinates);\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateFilter];\n    },\n    getClass: function getClass() {\n      return UniqueCoordinateArrayFilter;\n    }\n  });\n\n  UniqueCoordinateArrayFilter.filterCoordinates = function (coords) {\n    var filter = new UniqueCoordinateArrayFilter();\n\n    for (var i = 0; i < coords.length; i++) {\n      filter.filter(coords[i]);\n    }\n\n    return filter.getCoordinates();\n  };\n\n  function ConvexHull() {\n    this._geomFactory = null;\n    this._inputPts = null;\n\n    if (arguments.length === 1) {\n      var geometry = arguments[0];\n      ConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n    } else if (arguments.length === 2) {\n      var pts = arguments[0],\n          geomFactory = arguments[1];\n      this._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n      this._geomFactory = geomFactory;\n    }\n  }\n  extend(ConvexHull.prototype, {\n    preSort: function preSort(pts) {\n      var t = null;\n\n      for (var i = 1; i < pts.length; i++) {\n        if (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n          t = pts[0];\n          pts[0] = pts[i];\n          pts[i] = t;\n        }\n      }\n\n      Arrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n      return pts;\n    },\n    computeOctRing: function computeOctRing(inputPts) {\n      var octPts = this.computeOctPts(inputPts);\n      var coordList = new CoordinateList();\n      coordList.add(octPts, false);\n\n      if (coordList.size() < 3) {\n        return null;\n      }\n\n      coordList.closeRing();\n      return coordList.toCoordinateArray();\n    },\n    lineOrPolygon: function lineOrPolygon(coordinates) {\n      coordinates = this.cleanRing(coordinates);\n\n      if (coordinates.length === 3) {\n        return this._geomFactory.createLineString([coordinates[0], coordinates[1]]);\n      }\n\n      var linearRing = this._geomFactory.createLinearRing(coordinates);\n\n      return this._geomFactory.createPolygon(linearRing);\n    },\n    cleanRing: function cleanRing(original) {\n      Assert.equals(original[0], original[original.length - 1]);\n      var cleanedRing = new ArrayList();\n      var previousDistinctCoordinate = null;\n\n      for (var i = 0; i <= original.length - 2; i++) {\n        var currentCoordinate = original[i];\n        var nextCoordinate = original[i + 1];\n\n        if (currentCoordinate.equals(nextCoordinate)) {\n          continue;\n        }\n\n        if (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {\n          continue;\n        }\n\n        cleanedRing.add(currentCoordinate);\n        previousDistinctCoordinate = currentCoordinate;\n      }\n\n      cleanedRing.add(original[original.length - 1]);\n      var cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n      return cleanedRing.toArray(cleanedRingCoordinates);\n    },\n    isBetween: function isBetween(c1, c2, c3) {\n      if (Orientation.index(c1, c2, c3) !== 0) {\n        return false;\n      }\n\n      if (c1.x !== c3.x) {\n        if (c1.x <= c2.x && c2.x <= c3.x) {\n          return true;\n        }\n\n        if (c3.x <= c2.x && c2.x <= c1.x) {\n          return true;\n        }\n      }\n\n      if (c1.y !== c3.y) {\n        if (c1.y <= c2.y && c2.y <= c3.y) {\n          return true;\n        }\n\n        if (c3.y <= c2.y && c2.y <= c1.y) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    reduce: function reduce(inputPts) {\n      var polyPts = this.computeOctRing(inputPts);\n      if (polyPts === null) return inputPts;\n      var reducedSet = new TreeSet();\n\n      for (var i = 0; i < polyPts.length; i++) {\n        reducedSet.add(polyPts[i]);\n      }\n\n      for (var i = 0; i < inputPts.length; i++) {\n        if (!PointLocation.isInRing(inputPts[i], polyPts)) {\n          reducedSet.add(inputPts[i]);\n        }\n      }\n\n      var reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n      if (reducedPts.length < 3) return this.padArray3(reducedPts);\n      return reducedPts;\n    },\n    getConvexHull: function getConvexHull() {\n      if (this._inputPts.length === 0) {\n        return this._geomFactory.createGeometryCollection();\n      }\n\n      if (this._inputPts.length === 1) {\n        return this._geomFactory.createPoint(this._inputPts[0]);\n      }\n\n      if (this._inputPts.length === 2) {\n        return this._geomFactory.createLineString(this._inputPts);\n      }\n\n      var reducedPts = this._inputPts;\n\n      if (this._inputPts.length > 50) {\n        reducedPts = this.reduce(this._inputPts);\n      }\n\n      var sortedPts = this.preSort(reducedPts);\n      var cHS = this.grahamScan(sortedPts);\n      var cH = this.toCoordinateArray(cHS);\n      return this.lineOrPolygon(cH);\n    },\n    padArray3: function padArray3(pts) {\n      var pad = new Array(3).fill(null);\n\n      for (var i = 0; i < pad.length; i++) {\n        if (i < pts.length) {\n          pad[i] = pts[i];\n        } else pad[i] = pts[0];\n      }\n\n      return pad;\n    },\n    computeOctPts: function computeOctPts(inputPts) {\n      var pts = new Array(8).fill(null);\n\n      for (var j = 0; j < pts.length; j++) {\n        pts[j] = inputPts[0];\n      }\n\n      for (var i = 1; i < inputPts.length; i++) {\n        if (inputPts[i].x < pts[0].x) {\n          pts[0] = inputPts[i];\n        }\n\n        if (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {\n          pts[1] = inputPts[i];\n        }\n\n        if (inputPts[i].y > pts[2].y) {\n          pts[2] = inputPts[i];\n        }\n\n        if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {\n          pts[3] = inputPts[i];\n        }\n\n        if (inputPts[i].x > pts[4].x) {\n          pts[4] = inputPts[i];\n        }\n\n        if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {\n          pts[5] = inputPts[i];\n        }\n\n        if (inputPts[i].y < pts[6].y) {\n          pts[6] = inputPts[i];\n        }\n\n        if (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {\n          pts[7] = inputPts[i];\n        }\n      }\n\n      return pts;\n    },\n    toCoordinateArray: function toCoordinateArray(stack) {\n      var coordinates = new Array(stack.size()).fill(null);\n\n      for (var i = 0; i < stack.size(); i++) {\n        var coordinate = stack.get(i);\n        coordinates[i] = coordinate;\n      }\n\n      return coordinates;\n    },\n    grahamScan: function grahamScan(c) {\n      var p = null;\n      var ps = new Stack();\n      ps.push(c[0]);\n      ps.push(c[1]);\n      ps.push(c[2]);\n\n      for (var i = 3; i < c.length; i++) {\n        p = ps.pop();\n\n        while (!ps.empty() && Orientation.index(ps.peek(), p, c[i]) > 0) {\n          p = ps.pop();\n        }\n\n        ps.push(p);\n        ps.push(c[i]);\n      }\n\n      ps.push(c[0]);\n      return ps;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConvexHull;\n    }\n  });\n\n  ConvexHull.extractCoordinates = function (geom) {\n    var filter = new UniqueCoordinateArrayFilter();\n    geom.apply(filter);\n    return filter.getCoordinates();\n  };\n\n  function RadialComparator() {\n    this._origin = null;\n    var origin = arguments[0];\n    this._origin = origin;\n  }\n\n  extend(RadialComparator.prototype, {\n    compare: function compare(o1, o2) {\n      var p1 = o1;\n      var p2 = o2;\n      return RadialComparator.polarCompare(this._origin, p1, p2);\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return RadialComparator;\n    }\n  });\n\n  RadialComparator.polarCompare = function (o, p, q) {\n    var dxp = p.x - o.x;\n    var dyp = p.y - o.y;\n    var dxq = q.x - o.x;\n    var dyq = q.y - o.y;\n    var orient = Orientation.index(o, p, q);\n    if (orient === Orientation.COUNTERCLOCKWISE) return 1;\n    if (orient === Orientation.CLOCKWISE) return -1;\n    var op = dxp * dxp + dyp * dyp;\n    var oq = dxq * dxq + dyq * dyq;\n\n    if (op < oq) {\n      return -1;\n    }\n\n    if (op > oq) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  ConvexHull.RadialComparator = RadialComparator;\n\n  function InteriorPointArea() {\n    this._factory = null;\n    this._interiorPoint = null;\n    this._maxWidth = 0.0;\n    var g = arguments[0];\n    this._factory = g.getFactory();\n    this.add(g);\n  }\n  extend(InteriorPointArea.prototype, {\n    addPolygon: function addPolygon(geometry) {\n      if (geometry.isEmpty()) return null;\n      var intPt = null;\n      var width = null;\n      var bisector = this.horizontalBisector(geometry);\n\n      if (bisector.getLength() === 0.0) {\n        width = 0;\n        intPt = bisector.getCoordinate();\n      } else {\n        var intersections = bisector.intersection(geometry);\n        var widestIntersection = this.widestGeometry(intersections);\n        width = widestIntersection.getEnvelopeInternal().getWidth();\n        intPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());\n      }\n\n      if (this._interiorPoint === null || width > this._maxWidth) {\n        this._interiorPoint = intPt;\n        this._maxWidth = width;\n      }\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      return this._interiorPoint;\n    },\n    widestGeometry: function widestGeometry() {\n      if (arguments[0] instanceof GeometryCollection) {\n        var gc = arguments[0];\n\n        if (gc.isEmpty()) {\n          return gc;\n        }\n\n        var widestGeometry = gc.getGeometryN(0);\n\n        for (var i = 1; i < gc.getNumGeometries(); i++) {\n          if (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\n            widestGeometry = gc.getGeometryN(i);\n          }\n        }\n\n        return widestGeometry;\n      } else if (arguments[0] instanceof Geometry) {\n        var geometry = arguments[0];\n\n        if (!(geometry instanceof GeometryCollection)) {\n          return geometry;\n        }\n\n        return this.widestGeometry(geometry);\n      }\n    },\n    horizontalBisector: function horizontalBisector(geometry) {\n      var envelope = geometry.getEnvelopeInternal();\n      var bisectY = SafeBisectorFinder.getBisectorY(geometry);\n      return this._factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);\n    },\n    add: function add(geom) {\n      if (geom instanceof Polygon) {\n        this.addPolygon(geom);\n      } else if (geom instanceof GeometryCollection) {\n        var gc = geom;\n\n        for (var i = 0; i < gc.getNumGeometries(); i++) {\n          this.add(gc.getGeometryN(i));\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return InteriorPointArea;\n    }\n  });\n\n  InteriorPointArea.centre = function (envelope) {\n    return new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));\n  };\n\n  InteriorPointArea.avg = function (a, b) {\n    return (a + b) / 2.0;\n  };\n\n  function SafeBisectorFinder() {\n    this._poly = null;\n    this._centreY = null;\n    this._hiY = Double.MAX_VALUE;\n    this._loY = -Double.MAX_VALUE;\n    var poly = arguments[0];\n    this._poly = poly;\n    this._hiY = poly.getEnvelopeInternal().getMaxY();\n    this._loY = poly.getEnvelopeInternal().getMinY();\n    this._centreY = InteriorPointArea.avg(this._loY, this._hiY);\n  }\n\n  extend(SafeBisectorFinder.prototype, {\n    updateInterval: function updateInterval(y) {\n      if (y <= this._centreY) {\n        if (y > this._loY) this._loY = y;\n      } else if (y > this._centreY) {\n        if (y < this._hiY) {\n          this._hiY = y;\n        }\n      }\n    },\n    getBisectorY: function getBisectorY() {\n      this.process(this._poly.getExteriorRing());\n\n      for (var i = 0; i < this._poly.getNumInteriorRing(); i++) {\n        this.process(this._poly.getInteriorRingN(i));\n      }\n\n      var bisectY = InteriorPointArea.avg(this._hiY, this._loY);\n      return bisectY;\n    },\n    process: function process(line) {\n      var seq = line.getCoordinateSequence();\n\n      for (var i = 0; i < seq.size(); i++) {\n        var y = seq.getY(i);\n        this.updateInterval(y);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SafeBisectorFinder;\n    }\n  });\n\n  SafeBisectorFinder.getBisectorY = function (poly) {\n    var finder = new SafeBisectorFinder(poly);\n    return finder.getBisectorY();\n  };\n\n  InteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;\n\n  function InteriorPointLine() {\n    this._centroid = null;\n    this._minDistance = Double.MAX_VALUE;\n    this._interiorPoint = null;\n    var g = arguments[0];\n    this._centroid = g.getCentroid().getCoordinate();\n    this.addInterior(g);\n    if (this._interiorPoint === null) this.addEndpoints(g);\n  }\n  extend(InteriorPointLine.prototype, {\n    addEndpoints: function addEndpoints() {\n      if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n\n        if (geom instanceof LineString) {\n          this.addEndpoints(geom.getCoordinates());\n        } else if (geom instanceof GeometryCollection) {\n          var gc = geom;\n\n          for (var i = 0; i < gc.getNumGeometries(); i++) {\n            this.addEndpoints(gc.getGeometryN(i));\n          }\n        }\n      } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n        this.add(pts[0]);\n        this.add(pts[pts.length - 1]);\n      }\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      return this._interiorPoint;\n    },\n    addInterior: function addInterior() {\n      if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n\n        if (geom instanceof LineString) {\n          this.addInterior(geom.getCoordinates());\n        } else if (geom instanceof GeometryCollection) {\n          var gc = geom;\n\n          for (var i = 0; i < gc.getNumGeometries(); i++) {\n            this.addInterior(gc.getGeometryN(i));\n          }\n        }\n      } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n\n        for (var i = 1; i < pts.length - 1; i++) {\n          this.add(pts[i]);\n        }\n      }\n    },\n    add: function add(point) {\n      var dist = point.distance(this._centroid);\n\n      if (dist < this._minDistance) {\n        this._interiorPoint = new Coordinate(point);\n        this._minDistance = dist;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return InteriorPointLine;\n    }\n  });\n\n  function InteriorPointPoint() {\n    this._centroid = null;\n    this._minDistance = Double.MAX_VALUE;\n    this._interiorPoint = null;\n    var g = arguments[0];\n    this._centroid = g.getCentroid().getCoordinate();\n    this.add(g);\n  }\n  extend(InteriorPointPoint.prototype, {\n    getInteriorPoint: function getInteriorPoint() {\n      return this._interiorPoint;\n    },\n    add: function add() {\n      if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n\n        if (geom instanceof Point) {\n          this.add(geom.getCoordinate());\n        } else if (geom instanceof GeometryCollection) {\n          var gc = geom;\n\n          for (var i = 0; i < gc.getNumGeometries(); i++) {\n            this.add(gc.getGeometryN(i));\n          }\n        }\n      } else if (arguments[0] instanceof Coordinate) {\n        var point = arguments[0];\n        var dist = point.distance(this._centroid);\n\n        if (dist < this._minDistance) {\n          this._interiorPoint = new Coordinate(point);\n          this._minDistance = dist;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return InteriorPointPoint;\n    }\n  });\n\n  function MonotoneChainSelectAction() {\n    this.selectedSegment = new LineSegment();\n  }\n  extend(MonotoneChainSelectAction.prototype, {\n    select: function select() {\n      if (arguments.length === 1) ; else if (arguments.length === 2) {\n        var mc = arguments[0],\n            startIndex = arguments[1];\n        mc.getLineSegment(startIndex, this.selectedSegment);\n        this.select(this.selectedSegment);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChainSelectAction;\n    }\n  });\n\n  function NodeBase() {\n    this._items = new ArrayList();\n    this._subnode = new Array(2).fill(null);\n  }\n  extend(NodeBase.prototype, {\n    hasChildren: function hasChildren() {\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) return true;\n      }\n\n      return false;\n    },\n    isPrunable: function isPrunable() {\n      return !(this.hasChildren() || this.hasItems());\n    },\n    addAllItems: function addAllItems(items) {\n      items.addAll(this._items);\n\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) {\n          this._subnode[i].addAllItems(items);\n        }\n      }\n\n      return items;\n    },\n    size: function size() {\n      var subSize = 0;\n\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) {\n          subSize += this._subnode[i].size();\n        }\n      }\n\n      return subSize + this._items.size();\n    },\n    addAllItemsFromOverlapping: function addAllItemsFromOverlapping(interval, resultItems) {\n      if (interval !== null && !this.isSearchMatch(interval)) return null;\n      resultItems.addAll(this._items);\n      if (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);\n      if (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);\n    },\n    hasItems: function hasItems() {\n      return !this._items.isEmpty();\n    },\n    remove: function remove(itemInterval, item) {\n      if (!this.isSearchMatch(itemInterval)) return false;\n      var found = false;\n\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) {\n          found = this._subnode[i].remove(itemInterval, item);\n\n          if (found) {\n            if (this._subnode[i].isPrunable()) this._subnode[i] = null;\n            break;\n          }\n        }\n      }\n\n      if (found) return found;\n      found = this._items.remove(item);\n      return found;\n    },\n    getItems: function getItems() {\n      return this._items;\n    },\n    depth: function depth() {\n      var maxSubDepth = 0;\n\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) {\n          var sqd = this._subnode[i].depth();\n\n          if (sqd > maxSubDepth) maxSubDepth = sqd;\n        }\n      }\n\n      return maxSubDepth + 1;\n    },\n    nodeSize: function nodeSize() {\n      var subSize = 0;\n\n      for (var i = 0; i < 2; i++) {\n        if (this._subnode[i] !== null) {\n          subSize += this._subnode[i].nodeSize();\n        }\n      }\n\n      return subSize + 1;\n    },\n    add: function add(item) {\n      this._items.add(item);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NodeBase;\n    }\n  });\n\n  NodeBase.getSubnodeIndex = function (interval, centre) {\n    var subnodeIndex = -1;\n    if (interval.min >= centre) subnodeIndex = 1;\n    if (interval.max <= centre) subnodeIndex = 0;\n    return subnodeIndex;\n  };\n\n  function Interval() {\n    this.min = null;\n    this.max = null;\n\n    if (arguments.length === 0) {\n      this.min = 0.0;\n      this.max = 0.0;\n    } else if (arguments.length === 1) {\n      var interval = arguments[0];\n      this.init(interval.min, interval.max);\n    } else if (arguments.length === 2) {\n      var min = arguments[0],\n          max = arguments[1];\n      this.init(min, max);\n    }\n  }\n  extend(Interval.prototype, {\n    expandToInclude: function expandToInclude(interval) {\n      if (interval.max > this.max) this.max = interval.max;\n      if (interval.min < this.min) this.min = interval.min;\n    },\n    getWidth: function getWidth() {\n      return this.max - this.min;\n    },\n    overlaps: function overlaps() {\n      if (arguments.length === 1) {\n        var interval = arguments[0];\n        return this.overlaps(interval.min, interval.max);\n      } else if (arguments.length === 2) {\n        var min = arguments[0],\n            max = arguments[1];\n        if (this.min > max || this.max < min) return false;\n        return true;\n      }\n    },\n    getMin: function getMin() {\n      return this.min;\n    },\n    toString: function toString() {\n      return \"[\" + this.min + \", \" + this.max + \"]\";\n    },\n    contains: function contains() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Interval) {\n          var interval = arguments[0];\n          return this.contains(interval.min, interval.max);\n        } else if (typeof arguments[0] === \"number\") {\n          var p = arguments[0];\n          return p >= this.min && p <= this.max;\n        }\n      } else if (arguments.length === 2) {\n        var min = arguments[0],\n            max = arguments[1];\n        return min >= this.min && max <= this.max;\n      }\n    },\n    init: function init(min, max) {\n      this.min = min;\n      this.max = max;\n\n      if (min > max) {\n        this.min = max;\n        this.max = min;\n      }\n    },\n    getMax: function getMax() {\n      return this.max;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Interval;\n    }\n  });\n\n  function DoubleBits() {}\n\n  DoubleBits.exponent = function (d) {\n    return CVTFWD(64, d) - 1023;\n  };\n\n  DoubleBits.powerOf2 = function (exp) {\n    return Math.pow(2, exp);\n  };\n  /**\n   * Calculates the exponent of the bit-pattern for a number. Uses code from:\n   * http://www.merlyn.demon.co.uk/js-exact.htm\n   *\n   * @param {Number}\n   *          NumW 32 or 64 to denote the number of bits.\n   * @param {Number}\n   *          Qty the number to calculate the bit pattern for.\n   * @return {Number} The integer value of the exponent.\n   * @private\n   */\n\n\n  function CVTFWD(NumW, Qty) {\n    var Sign;\n    var Expo;\n    var Mant;\n    var Bin;\n    var Inf = {\n      32: {\n        d: 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      },\n      64: {\n        d: 0x7FF0,\n        c: 0,\n        b: 0,\n        a: 0\n      }\n    };\n    var ExW = {\n      32: 8,\n      64: 11\n    }[NumW];\n\n    if (!Bin) {\n      Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0\n\n      if (!isFinite(Qty)) {\n        Bin = Inf[NumW];\n\n        if (Sign) {\n          Bin.d += 1 << NumW / 4 - 1;\n        }\n\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n\n    if (!Bin) {\n      Expo = {\n        32: 127,\n        64: 1023\n      }[NumW];\n      Mant = Math.abs(Qty);\n\n      while (Mant >= 2) {\n        Expo++;\n        Mant /= 2;\n      }\n\n      while (Mant < 1 && Expo > 0) {\n        Expo--;\n        Mant *= 2;\n      }\n\n      if (Expo <= 0) {\n        Mant /= 2;\n      }\n\n      if (NumW === 32 && Expo > 254) {\n        Bin = {\n          d: Sign ? 0xFF : 0x7F,\n          c: 0x80,\n          b: 0,\n          a: 0\n        };\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n\n    return Expo;\n  }\n\n  function Key() {\n    this._pt = 0.0;\n    this._level = 0;\n    this._interval = null;\n    var interval = arguments[0];\n    this.computeKey(interval);\n  }\n  extend(Key.prototype, {\n    getInterval: function getInterval() {\n      return this._interval;\n    },\n    getLevel: function getLevel() {\n      return this._level;\n    },\n    computeKey: function computeKey(itemInterval) {\n      this._level = Key.computeLevel(itemInterval);\n      this._interval = new Interval();\n      this.computeInterval(this._level, itemInterval);\n\n      while (!this._interval.contains(itemInterval)) {\n        this._level += 1;\n        this.computeInterval(this._level, itemInterval);\n      }\n    },\n    computeInterval: function computeInterval(level, itemInterval) {\n      var size = DoubleBits.powerOf2(level);\n      this._pt = Math.floor(itemInterval.getMin() / size) * size;\n\n      this._interval.init(this._pt, this._pt + size);\n    },\n    getPoint: function getPoint() {\n      return this._pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Key;\n    }\n  });\n\n  Key.computeLevel = function (interval) {\n    var dx = interval.getWidth();\n    var level = DoubleBits.exponent(dx) + 1;\n    return level;\n  };\n\n  function Node() {\n    NodeBase.apply(this);\n    this._interval = null;\n    this._centre = null;\n    this._level = null;\n    var interval = arguments[0],\n        level = arguments[1];\n    this._interval = interval;\n    this._level = level;\n    this._centre = (interval.getMin() + interval.getMax()) / 2;\n  }\n  inherits(Node, NodeBase);\n  extend(Node.prototype, {\n    getInterval: function getInterval() {\n      return this._interval;\n    },\n    find: function find(searchInterval) {\n      var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n      if (subnodeIndex === -1) return this;\n\n      if (this._subnode[subnodeIndex] !== null) {\n        var node = this._subnode[subnodeIndex];\n        return node.find(searchInterval);\n      }\n\n      return this;\n    },\n    insert: function insert(node) {\n      Assert.isTrue(this._interval === null || this._interval.contains(node._interval));\n      var index = NodeBase.getSubnodeIndex(node._interval, this._centre);\n\n      if (node._level === this._level - 1) {\n        this._subnode[index] = node;\n      } else {\n        var childNode = this.createSubnode(index);\n        childNode.insert(node);\n        this._subnode[index] = childNode;\n      }\n    },\n    isSearchMatch: function isSearchMatch(itemInterval) {\n      return itemInterval.overlaps(this._interval);\n    },\n    getSubnode: function getSubnode(index) {\n      if (this._subnode[index] === null) {\n        this._subnode[index] = this.createSubnode(index);\n      }\n\n      return this._subnode[index];\n    },\n    getNode: function getNode(searchInterval) {\n      var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);\n\n      if (subnodeIndex !== -1) {\n        var node = this.getSubnode(subnodeIndex);\n        return node.getNode(searchInterval);\n      } else {\n        return this;\n      }\n    },\n    createSubnode: function createSubnode(index) {\n      var min = 0.0;\n      var max = 0.0;\n\n      switch (index) {\n        case 0:\n          min = this._interval.getMin();\n          max = this._centre;\n          break;\n\n        case 1:\n          min = this._centre;\n          max = this._interval.getMax();\n          break;\n      }\n\n      var subInt = new Interval(min, max);\n      var node = new Node(subInt, this._level - 1);\n      return node;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Node;\n    }\n  });\n\n  Node.createNode = function (itemInterval) {\n    var key = new Key(itemInterval);\n    var node = new Node(key.getInterval(), key.getLevel());\n    return node;\n  };\n\n  Node.createExpanded = function (node, addInterval) {\n    var expandInt = new Interval(addInterval);\n    if (node !== null) expandInt.expandToInclude(node._interval);\n    var largerNode = Node.createNode(expandInt);\n    if (node !== null) largerNode.insert(node);\n    return largerNode;\n  };\n\n  function IntervalSize() {}\n  extend(IntervalSize.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IntervalSize;\n    }\n  });\n\n  IntervalSize.isZeroWidth = function (min, max) {\n    var width = max - min;\n    if (width === 0.0) return true;\n    var maxAbs = Math.max(Math.abs(min), Math.abs(max));\n    var scaledInterval = width / maxAbs;\n    var level = DoubleBits.exponent(scaledInterval);\n    return level <= IntervalSize.MIN_BINARY_EXPONENT;\n  };\n\n  IntervalSize.MIN_BINARY_EXPONENT = -50;\n\n  function Root() {\n    NodeBase.apply(this);\n  }\n  inherits(Root, NodeBase);\n  extend(Root.prototype, {\n    insert: function insert(itemInterval, item) {\n      var index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);\n\n      if (index === -1) {\n        this.add(item);\n        return null;\n      }\n\n      var node = this._subnode[index];\n\n      if (node === null || !node.getInterval().contains(itemInterval)) {\n        var largerNode = Node.createExpanded(node, itemInterval);\n        this._subnode[index] = largerNode;\n      }\n\n      this.insertContained(this._subnode[index], itemInterval, item);\n    },\n    isSearchMatch: function isSearchMatch(interval) {\n      return true;\n    },\n    insertContained: function insertContained(tree, itemInterval, item) {\n      Assert.isTrue(tree.getInterval().contains(itemInterval));\n      var isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\n      var node = null;\n      if (isZeroArea) node = tree.find(itemInterval);else node = tree.getNode(itemInterval);\n      node.add(item);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Root;\n    }\n  });\n  Root.origin = 0.0;\n\n  function Bintree() {\n    this._root = null;\n    this._minExtent = 1.0;\n    this._root = new Root();\n  }\n  extend(Bintree.prototype, {\n    size: function size() {\n      if (this._root !== null) return this._root.size();\n      return 0;\n    },\n    insert: function insert(itemInterval, item) {\n      this.collectStats(itemInterval);\n      var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n\n      this._root.insert(insertInterval, item);\n    },\n    query: function query() {\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n          var x = arguments[0];\n          return this.query(new Interval(x, x));\n        } else if (arguments[0] instanceof Interval) {\n          var interval = arguments[0];\n          var foundItems = new ArrayList();\n          this.query(interval, foundItems);\n          return foundItems;\n        }\n      } else if (arguments.length === 2) {\n        var _interval = arguments[0],\n            _foundItems = arguments[1];\n\n        this._root.addAllItemsFromOverlapping(_interval, _foundItems);\n      }\n    },\n    iterator: function iterator() {\n      var foundItems = new ArrayList();\n\n      this._root.addAllItems(foundItems);\n\n      return foundItems.iterator();\n    },\n    remove: function remove(itemInterval, item) {\n      var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);\n      return this._root.remove(insertInterval, item);\n    },\n    collectStats: function collectStats(interval) {\n      var del = interval.getWidth();\n      if (del < this._minExtent && del > 0.0) this._minExtent = del;\n    },\n    depth: function depth() {\n      if (this._root !== null) return this._root.depth();\n      return 0;\n    },\n    nodeSize: function nodeSize() {\n      if (this._root !== null) return this._root.nodeSize();\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Bintree;\n    }\n  });\n\n  Bintree.ensureExtent = function (itemInterval, minExtent) {\n    var min = itemInterval.getMin();\n    var max = itemInterval.getMax();\n    if (min !== max) return itemInterval;\n\n    if (min === max) {\n      min = min - minExtent / 2.0;\n      max = min + minExtent / 2.0;\n    }\n\n    return new Interval(min, max);\n  };\n\n  function MonotoneChain() {\n    this._pts = null;\n    this._start = null;\n    this._end = null;\n    this._env = null;\n    this._context = null;\n    this._id = null;\n    var pts = arguments[0],\n        start = arguments[1],\n        end = arguments[2],\n        context = arguments[3];\n    this._pts = pts;\n    this._start = start;\n    this._end = end;\n    this._context = context;\n  }\n  extend(MonotoneChain.prototype, {\n    getLineSegment: function getLineSegment(index, ls) {\n      ls.p0 = this._pts[index];\n      ls.p1 = this._pts[index + 1];\n    },\n    computeSelect: function computeSelect(searchEnv, start0, end0, mcs) {\n      var p0 = this._pts[start0];\n      var p1 = this._pts[end0];\n\n      if (end0 - start0 === 1) {\n        mcs.select(this, start0);\n        return null;\n      }\n\n      if (!searchEnv.intersects(p0, p1)) return null;\n      var mid = Math.trunc((start0 + end0) / 2);\n\n      if (start0 < mid) {\n        this.computeSelect(searchEnv, start0, mid, mcs);\n      }\n\n      if (mid < end0) {\n        this.computeSelect(searchEnv, mid, end0, mcs);\n      }\n    },\n    getCoordinates: function getCoordinates() {\n      var coord = new Array(this._end - this._start + 1).fill(null);\n      var index = 0;\n\n      for (var i = this._start; i <= this._end; i++) {\n        coord[index++] = this._pts[i];\n      }\n\n      return coord;\n    },\n    computeOverlaps: function computeOverlaps() {\n      if (arguments.length === 2) {\n        var mc = arguments[0],\n            mco = arguments[1];\n        this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);\n      } else if (arguments.length === 6) {\n        var start0 = arguments[0],\n            end0 = arguments[1],\n            _mc = arguments[2],\n            start1 = arguments[3],\n            end1 = arguments[4],\n            _mco = arguments[5];\n\n        if (end0 - start0 === 1 && end1 - start1 === 1) {\n          _mco.overlap(this, start0, _mc, start1);\n\n          return null;\n        }\n\n        if (!this.overlaps(start0, end0, _mc, start1, end1)) return null;\n        var mid0 = Math.trunc((start0 + end0) / 2);\n        var mid1 = Math.trunc((start1 + end1) / 2);\n\n        if (start0 < mid0) {\n          if (start1 < mid1) this.computeOverlaps(start0, mid0, _mc, start1, mid1, _mco);\n          if (mid1 < end1) this.computeOverlaps(start0, mid0, _mc, mid1, end1, _mco);\n        }\n\n        if (mid0 < end0) {\n          if (start1 < mid1) this.computeOverlaps(mid0, end0, _mc, start1, mid1, _mco);\n          if (mid1 < end1) this.computeOverlaps(mid0, end0, _mc, mid1, end1, _mco);\n        }\n      }\n    },\n    setId: function setId(id) {\n      this._id = id;\n    },\n    select: function select(searchEnv, mcs) {\n      this.computeSelect(searchEnv, this._start, this._end, mcs);\n    },\n    getEnvelope: function getEnvelope() {\n      if (this._env === null) {\n        var p0 = this._pts[this._start];\n        var p1 = this._pts[this._end];\n        this._env = new Envelope(p0, p1);\n      }\n\n      return this._env;\n    },\n    overlaps: function overlaps(start0, end0, mc, start1, end1) {\n      return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);\n    },\n    getEndIndex: function getEndIndex() {\n      return this._end;\n    },\n    getStartIndex: function getStartIndex() {\n      return this._start;\n    },\n    getContext: function getContext() {\n      return this._context;\n    },\n    getId: function getId() {\n      return this._id;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChain;\n    }\n  });\n\n  function Quadrant() {}\n  extend(Quadrant.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Quadrant;\n    }\n  });\n\n  Quadrant.isNorthern = function (quad) {\n    return quad === Quadrant.NE || quad === Quadrant.NW;\n  };\n\n  Quadrant.isOpposite = function (quad1, quad2) {\n    if (quad1 === quad2) return false;\n    var diff = (quad1 - quad2 + 4) % 4;\n    if (diff === 2) return true;\n    return false;\n  };\n\n  Quadrant.commonHalfPlane = function (quad1, quad2) {\n    if (quad1 === quad2) return quad1;\n    var diff = (quad1 - quad2 + 4) % 4;\n    if (diff === 2) return -1;\n    var min = quad1 < quad2 ? quad1 : quad2;\n    var max = quad1 > quad2 ? quad1 : quad2;\n    if (min === 0 && max === 3) return 3;\n    return min;\n  };\n\n  Quadrant.isInHalfPlane = function (quad, halfPlane) {\n    if (halfPlane === Quadrant.SE) {\n      return quad === Quadrant.SE || quad === Quadrant.SW;\n    }\n\n    return quad === halfPlane || quad === halfPlane + 1;\n  };\n\n  Quadrant.quadrant = function () {\n    if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n      var dx = arguments[0],\n          dy = arguments[1];\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\n      if (dx >= 0.0) {\n        if (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;\n      } else {\n        if (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;\n      }\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\n      if (p1.x >= p0.x) {\n        if (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;\n      } else {\n        if (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;\n      }\n    }\n  };\n\n  Quadrant.NE = 0;\n  Quadrant.NW = 1;\n  Quadrant.SW = 2;\n  Quadrant.SE = 3;\n\n  function MonotoneChainBuilder() {}\n  extend(MonotoneChainBuilder.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChainBuilder;\n    }\n  });\n\n  MonotoneChainBuilder.getChainStartIndices = function (pts) {\n    var start = 0;\n    var startIndexList = new ArrayList();\n    startIndexList.add(new Integer(start));\n\n    do {\n      var last = MonotoneChainBuilder.findChainEnd(pts, start);\n      startIndexList.add(new Integer(last));\n      start = last;\n    } while (start < pts.length - 1);\n\n    var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n    return startIndex;\n  };\n\n  MonotoneChainBuilder.findChainEnd = function (pts, start) {\n    var safeStart = start;\n\n    while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n      safeStart++;\n    }\n\n    if (safeStart >= pts.length - 1) {\n      return pts.length - 1;\n    }\n\n    var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n    var last = start + 1;\n\n    while (last < pts.length) {\n      if (!pts[last - 1].equals2D(pts[last])) {\n        var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n        if (quad !== chainQuad) break;\n      }\n\n      last++;\n    }\n\n    return last - 1;\n  };\n\n  MonotoneChainBuilder.getChains = function () {\n    if (arguments.length === 1) {\n      var pts = arguments[0];\n      return MonotoneChainBuilder.getChains(pts, null);\n    } else if (arguments.length === 2) {\n      var _pts = arguments[0],\n          context = arguments[1];\n      var mcList = new ArrayList();\n      var startIndex = MonotoneChainBuilder.getChainStartIndices(_pts);\n\n      for (var i = 0; i < startIndex.length - 1; i++) {\n        var mc = new MonotoneChain(_pts, startIndex[i], startIndex[i + 1], context);\n        mcList.add(mc);\n      }\n\n      return mcList;\n    }\n  };\n\n  MonotoneChainBuilder.toIntArray = function (list) {\n    var array = new Array(list.size()).fill(null);\n\n    for (var i = 0; i < array.length; i++) {\n      array[i] = list.get(i).intValue();\n    }\n\n    return array;\n  };\n\n  function RobustDeterminant() {}\n  extend(RobustDeterminant.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RobustDeterminant;\n    }\n  });\n\n  RobustDeterminant.orientationIndex = function (p1, p2, q) {\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dx2 = q.x - p2.x;\n    var dy2 = q.y - p2.y;\n    return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n  };\n\n  RobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {\n    var sign = null;\n    var swap = null;\n    var k = null;\n    sign = 1;\n\n    if (x1 === 0.0 || y2 === 0.0) {\n      if (y1 === 0.0 || x2 === 0.0) {\n        return 0;\n      } else if (y1 > 0) {\n        if (x2 > 0) {\n          return -sign;\n        } else {\n          return sign;\n        }\n      } else {\n        if (x2 > 0) {\n          return sign;\n        } else {\n          return -sign;\n        }\n      }\n    }\n\n    if (y1 === 0.0 || x2 === 0.0) {\n      if (y2 > 0) {\n        if (x1 > 0) {\n          return sign;\n        } else {\n          return -sign;\n        }\n      } else {\n        if (x1 > 0) {\n          return -sign;\n        } else {\n          return sign;\n        }\n      }\n    }\n\n    if (0.0 < y1) {\n      if (0.0 < y2) {\n        if (y1 <= y2) ; else {\n          sign = -sign;\n          swap = x1;\n          x1 = x2;\n          x2 = swap;\n          swap = y1;\n          y1 = y2;\n          y2 = swap;\n        }\n      } else {\n        if (y1 <= -y2) {\n          sign = -sign;\n          x2 = -x2;\n          y2 = -y2;\n        } else {\n          swap = x1;\n          x1 = -x2;\n          x2 = swap;\n          swap = y1;\n          y1 = -y2;\n          y2 = swap;\n        }\n      }\n    } else {\n      if (0.0 < y2) {\n        if (-y1 <= y2) {\n          sign = -sign;\n          x1 = -x1;\n          y1 = -y1;\n        } else {\n          swap = -x1;\n          x1 = x2;\n          x2 = swap;\n          swap = -y1;\n          y1 = y2;\n          y2 = swap;\n        }\n      } else {\n        if (y1 >= y2) {\n          x1 = -x1;\n          y1 = -y1;\n          x2 = -x2;\n          y2 = -y2;\n        } else {\n          sign = -sign;\n          swap = -x1;\n          x1 = -x2;\n          x2 = swap;\n          swap = -y1;\n          y1 = -y2;\n          y2 = swap;\n        }\n      }\n    }\n\n    if (0.0 < x1) {\n      if (0.0 < x2) {\n        if (x1 <= x2) ; else {\n          return sign;\n        }\n      } else {\n        return sign;\n      }\n    } else {\n      if (0.0 < x2) {\n        return -sign;\n      } else {\n        if (x1 >= x2) {\n          sign = -sign;\n          x1 = -x1;\n          x2 = -x2;\n        } else {\n          return -sign;\n        }\n      }\n    }\n\n    while (true) {\n      k = Math.floor(x2 / x1);\n      x2 = x2 - k * x1;\n      y2 = y2 - k * y1;\n\n      if (y2 < 0.0) {\n        return -sign;\n      }\n\n      if (y2 > y1) {\n        return sign;\n      }\n\n      if (x1 > x2 + x2) {\n        if (y1 < y2 + y2) {\n          return sign;\n        }\n      } else {\n        if (y1 > y2 + y2) {\n          return -sign;\n        } else {\n          x2 = x1 - x2;\n          y2 = y1 - y2;\n          sign = -sign;\n        }\n      }\n\n      if (y2 === 0.0) {\n        if (x2 === 0.0) {\n          return 0;\n        } else {\n          return -sign;\n        }\n      }\n\n      if (x2 === 0.0) {\n        return sign;\n      }\n\n      k = Math.floor(x1 / x2);\n      x1 = x1 - k * x2;\n      y1 = y1 - k * y2;\n\n      if (y1 < 0.0) {\n        return sign;\n      }\n\n      if (y1 > y2) {\n        return -sign;\n      }\n\n      if (x2 > x1 + x1) {\n        if (y2 < y1 + y1) {\n          return -sign;\n        }\n      } else {\n        if (y2 > y1 + y1) {\n          return sign;\n        } else {\n          x1 = x2 - x1;\n          y1 = y2 - y1;\n          sign = -sign;\n        }\n      }\n\n      if (y1 === 0.0) {\n        if (x1 === 0.0) {\n          return 0;\n        } else {\n          return sign;\n        }\n      }\n\n      if (x1 === 0.0) {\n        return -sign;\n      }\n    }\n  };\n\n  function PointInRing() {}\n  extend(PointInRing.prototype, {\n    isInside: function isInside(pt) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointInRing;\n    }\n  });\n\n  function MCPointInRing() {\n    this._ring = null;\n    this._tree = null;\n    this._crossings = 0;\n    this._interval = new Interval();\n    var ring = arguments[0];\n    this._ring = ring;\n    this.buildIndex();\n  }\n  extend(MCPointInRing.prototype, {\n    testLineSegment: function testLineSegment(p, seg) {\n      var xInt = null;\n      var x1 = null;\n      var y1 = null;\n      var x2 = null;\n      var y2 = null;\n      var p1 = seg.p0;\n      var p2 = seg.p1;\n      x1 = p1.x - p.x;\n      y1 = p1.y - p.y;\n      x2 = p2.x - p.x;\n      y2 = p2.y - p.y;\n\n      if (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {\n        xInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);\n\n        if (0.0 < xInt) {\n          this._crossings++;\n        }\n      }\n    },\n    buildIndex: function buildIndex() {\n      this._tree = new Bintree();\n      var pts = CoordinateArrays.removeRepeatedPoints(this._ring.getCoordinates());\n      var mcList = MonotoneChainBuilder.getChains(pts);\n\n      for (var i = 0; i < mcList.size(); i++) {\n        var mc = mcList.get(i);\n        var mcEnv = mc.getEnvelope();\n        this._interval.min = mcEnv.getMinY();\n        this._interval.max = mcEnv.getMaxY();\n\n        this._tree.insert(this._interval, mc);\n      }\n    },\n    testMonotoneChain: function testMonotoneChain(rayEnv, mcSelecter, mc) {\n      mc.select(rayEnv, mcSelecter);\n    },\n    isInside: function isInside(pt) {\n      this._crossings = 0;\n      var rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);\n      this._interval.min = pt.y;\n      this._interval.max = pt.y;\n\n      var segs = this._tree.query(this._interval);\n\n      var mcSelecter = new MCSelecter(this, pt);\n\n      for (var i = segs.iterator(); i.hasNext();) {\n        var mc = i.next();\n        this.testMonotoneChain(rayEnv, mcSelecter, mc);\n      }\n\n      if (this._crossings % 2 === 1) {\n        return true;\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [PointInRing];\n    },\n    getClass: function getClass() {\n      return MCPointInRing;\n    }\n  });\n\n  function MCSelecter() {\n    MonotoneChainSelectAction.apply(this);\n    this.mcp = null;\n    this.p = null;\n    var mcp = arguments[0],\n        p = arguments[1];\n    this.mcp = mcp;\n    this.p = p;\n  }\n\n  inherits(MCSelecter, MonotoneChainSelectAction);\n  extend(MCSelecter.prototype, {\n    select: function select() {\n      if (arguments.length === 1) {\n        var ls = arguments[0];\n        this.mcp.testLineSegment(this.p, ls);\n      } else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MCSelecter;\n    }\n  });\n  MCPointInRing.MCSelecter = MCSelecter;\n\n  function MinimumBoundingCircle() {\n    this._input = null;\n    this._extremalPts = null;\n    this._centre = null;\n    this._radius = 0.0;\n    var geom = arguments[0];\n    this._input = geom;\n  }\n  extend(MinimumBoundingCircle.prototype, {\n    getRadius: function getRadius() {\n      this.compute();\n      return this._radius;\n    },\n    getDiameter: function getDiameter() {\n      this.compute();\n\n      switch (this._extremalPts.length) {\n        case 0:\n          return this._input.getFactory().createLineString();\n\n        case 1:\n          return this._input.getFactory().createPoint(this._centre);\n      }\n\n      var p0 = this._extremalPts[0];\n      var p1 = this._extremalPts[1];\n      return this._input.getFactory().createLineString([p0, p1]);\n    },\n    getExtremalPoints: function getExtremalPoints() {\n      this.compute();\n      return this._extremalPts;\n    },\n    computeCirclePoints: function computeCirclePoints() {\n      if (this._input.isEmpty()) {\n        this._extremalPts = new Array(0).fill(null);\n        return null;\n      }\n\n      if (this._input.getNumPoints() === 1) {\n        var pts = this._input.getCoordinates();\n\n        this._extremalPts = [new Coordinate(pts[0])];\n        return null;\n      }\n\n      var convexHull = this._input.convexHull();\n\n      var hullPts = convexHull.getCoordinates();\n      var pts = hullPts;\n\n      if (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n        pts = new Array(hullPts.length - 1).fill(null);\n        CoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n      }\n\n      if (pts.length <= 2) {\n        this._extremalPts = CoordinateArrays.copyDeep(pts);\n        return null;\n      }\n\n      var P = MinimumBoundingCircle.lowestPoint(pts);\n      var Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n\n      for (var i = 0; i < pts.length; i++) {\n        var R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n\n        if (Angle.isObtuse(P, R, Q)) {\n          this._extremalPts = [new Coordinate(P), new Coordinate(Q)];\n          return null;\n        }\n\n        if (Angle.isObtuse(R, P, Q)) {\n          P = R;\n          continue;\n        }\n\n        if (Angle.isObtuse(R, Q, P)) {\n          Q = R;\n          continue;\n        }\n\n        this._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n        return null;\n      }\n\n      Assert.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n    },\n    compute: function compute() {\n      if (this._extremalPts !== null) return null;\n      this.computeCirclePoints();\n      this.computeCentre();\n      if (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);\n    },\n    getFarthestPoints: function getFarthestPoints() {\n      this.compute();\n\n      switch (this._extremalPts.length) {\n        case 0:\n          return this._input.getFactory().createLineString();\n\n        case 1:\n          return this._input.getFactory().createPoint(this._centre);\n      }\n\n      var p0 = this._extremalPts[0];\n      var p1 = this._extremalPts[this._extremalPts.length - 1];\n      return this._input.getFactory().createLineString([p0, p1]);\n    },\n    getCircle: function getCircle() {\n      this.compute();\n      if (this._centre === null) return this._input.getFactory().createPolygon();\n\n      var centrePoint = this._input.getFactory().createPoint(this._centre);\n\n      if (this._radius === 0.0) return centrePoint;\n      return centrePoint.buffer(this._radius);\n    },\n    getCentre: function getCentre() {\n      this.compute();\n      return this._centre;\n    },\n    computeCentre: function computeCentre() {\n      switch (this._extremalPts.length) {\n        case 0:\n          this._centre = null;\n          break;\n\n        case 1:\n          this._centre = this._extremalPts[0];\n          break;\n\n        case 2:\n          this._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);\n          break;\n\n        case 3:\n          this._centre = Triangle.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);\n          break;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MinimumBoundingCircle;\n    }\n  });\n\n  MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {\n    var minSin = Double.MAX_VALUE;\n    var minAngPt = null;\n\n    for (var i = 0; i < pts.length; i++) {\n      var p = pts[i];\n      if (p === P) continue;\n      var dx = p.x - P.x;\n      var dy = p.y - P.y;\n      if (dy < 0) dy = -dy;\n      var len = Math.sqrt(dx * dx + dy * dy);\n      var sin = dy / len;\n\n      if (sin < minSin) {\n        minSin = sin;\n        minAngPt = p;\n      }\n    }\n\n    return minAngPt;\n  };\n\n  MinimumBoundingCircle.lowestPoint = function (pts) {\n    var min = pts[0];\n\n    for (var i = 1; i < pts.length; i++) {\n      if (pts[i].y < min.y) min = pts[i];\n    }\n\n    return min;\n  };\n\n  MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {\n    var minAng = Double.MAX_VALUE;\n    var minAngPt = null;\n\n    for (var i = 0; i < pts.length; i++) {\n      var p = pts[i];\n      if (p === P) continue;\n      if (p === Q) continue;\n      var ang = Angle.angleBetween(P, p, Q);\n\n      if (ang < minAng) {\n        minAng = ang;\n        minAngPt = p;\n      }\n    }\n\n    return minAngPt;\n  };\n\n  function MinimumDiameter() {\n    this._inputGeom = null;\n    this._isConvex = null;\n    this._convexHullPts = null;\n    this._minBaseSeg = new LineSegment();\n    this._minWidthPt = null;\n    this._minPtIndex = null;\n    this._minWidth = 0.0;\n\n    if (arguments.length === 1) {\n      var inputGeom = arguments[0];\n      MinimumDiameter.call(this, inputGeom, false);\n    } else if (arguments.length === 2) {\n      var _inputGeom = arguments[0],\n          isConvex = arguments[1];\n      this._inputGeom = _inputGeom;\n      this._isConvex = isConvex;\n    }\n  }\n  extend(MinimumDiameter.prototype, {\n    getWidthCoordinate: function getWidthCoordinate() {\n      this.computeMinimumDiameter();\n      return this._minWidthPt;\n    },\n    getSupportingSegment: function getSupportingSegment() {\n      this.computeMinimumDiameter();\n      return this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);\n    },\n    getDiameter: function getDiameter() {\n      this.computeMinimumDiameter();\n      if (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString();\n\n      var basePt = this._minBaseSeg.project(this._minWidthPt);\n\n      return this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);\n    },\n    computeWidthConvex: function computeWidthConvex(convexGeom) {\n      if (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();\n\n      if (this._convexHullPts.length === 0) {\n        this._minWidth = 0.0;\n        this._minWidthPt = null;\n        this._minBaseSeg = null;\n      } else if (this._convexHullPts.length === 1) {\n        this._minWidth = 0.0;\n        this._minWidthPt = this._convexHullPts[0];\n        this._minBaseSeg.p0 = this._convexHullPts[0];\n        this._minBaseSeg.p1 = this._convexHullPts[0];\n      } else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {\n        this._minWidth = 0.0;\n        this._minWidthPt = this._convexHullPts[0];\n        this._minBaseSeg.p0 = this._convexHullPts[0];\n        this._minBaseSeg.p1 = this._convexHullPts[1];\n      } else this.computeConvexRingMinDiameter(this._convexHullPts);\n    },\n    computeConvexRingMinDiameter: function computeConvexRingMinDiameter(pts) {\n      this._minWidth = Double.MAX_VALUE;\n      var currMaxIndex = 1;\n      var seg = new LineSegment();\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        seg.p0 = pts[i];\n        seg.p1 = pts[i + 1];\n        currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n      }\n    },\n    computeMinimumDiameter: function computeMinimumDiameter() {\n      if (this._minWidthPt !== null) return null;\n      if (this._isConvex) this.computeWidthConvex(this._inputGeom);else {\n        var convexGeom = new ConvexHull(this._inputGeom).getConvexHull();\n        this.computeWidthConvex(convexGeom);\n      }\n    },\n    getLength: function getLength() {\n      this.computeMinimumDiameter();\n      return this._minWidth;\n    },\n    findMaxPerpDistance: function findMaxPerpDistance(pts, seg, startIndex) {\n      var maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n      var nextPerpDistance = maxPerpDistance;\n      var maxIndex = startIndex;\n      var nextIndex = maxIndex;\n\n      while (nextPerpDistance >= maxPerpDistance) {\n        maxPerpDistance = nextPerpDistance;\n        maxIndex = nextIndex;\n        nextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n        nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n      }\n\n      if (maxPerpDistance < this._minWidth) {\n        this._minPtIndex = maxIndex;\n        this._minWidth = maxPerpDistance;\n        this._minWidthPt = pts[this._minPtIndex];\n        this._minBaseSeg = new LineSegment(seg);\n      }\n\n      return maxIndex;\n    },\n    getMinimumRectangle: function getMinimumRectangle() {\n      this.computeMinimumDiameter();\n\n      if (this._minWidth === 0.0) {\n        if (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {\n          return this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);\n        }\n\n        return this._minBaseSeg.toGeometry(this._inputGeom.getFactory());\n      }\n\n      var dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;\n      var dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;\n      var minPara = Double.MAX_VALUE;\n      var maxPara = -Double.MAX_VALUE;\n      var minPerp = Double.MAX_VALUE;\n      var maxPerp = -Double.MAX_VALUE;\n\n      for (var i = 0; i < this._convexHullPts.length; i++) {\n        var paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);\n        if (paraC > maxPara) maxPara = paraC;\n        if (paraC < minPara) minPara = paraC;\n        var perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);\n        if (perpC > maxPerp) maxPerp = perpC;\n        if (perpC < minPerp) minPerp = perpC;\n      }\n\n      var maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n      var minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n      var maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n      var minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n      var p0 = maxParaLine.lineIntersection(maxPerpLine);\n      var p1 = minParaLine.lineIntersection(maxPerpLine);\n      var p2 = minParaLine.lineIntersection(minPerpLine);\n      var p3 = maxParaLine.lineIntersection(minPerpLine);\n\n      var shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n\n      return this._inputGeom.getFactory().createPolygon(shell);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MinimumDiameter;\n    }\n  });\n\n  MinimumDiameter.nextIndex = function (pts, index) {\n    index++;\n    if (index >= pts.length) index = 0;\n    return index;\n  };\n\n  MinimumDiameter.computeC = function (a, b, p) {\n    return a * p.y - b * p.x;\n  };\n\n  MinimumDiameter.getMinimumDiameter = function (geom) {\n    return new MinimumDiameter(geom).getDiameter();\n  };\n\n  MinimumDiameter.getMinimumRectangle = function (geom) {\n    return new MinimumDiameter(geom).getMinimumRectangle();\n  };\n\n  MinimumDiameter.computeSegmentForLine = function (a, b, c) {\n    var p0 = null;\n    var p1 = null;\n\n    if (Math.abs(b) > Math.abs(a)) {\n      p0 = new Coordinate(0.0, c / b);\n      p1 = new Coordinate(1.0, c / b - a / b);\n    } else {\n      p0 = new Coordinate(c / a, 0.0);\n      p1 = new Coordinate(c / a - b / a, 1.0);\n    }\n\n    return new LineSegment(p0, p1);\n  };\n\n\n\n  var algorithm = /*#__PURE__*/Object.freeze({\n    distance: distance_module,\n    locate: locate,\n    match: match,\n    Angle: Angle,\n    Centroid: Centroid,\n    CGAlgorithms: CGAlgorithms,\n    ConvexHull: ConvexHull,\n    Distance: Distance,\n    InteriorPointArea: InteriorPointArea,\n    InteriorPointLine: InteriorPointLine,\n    InteriorPointPoint: InteriorPointPoint,\n    RobustLineIntersector: RobustLineIntersector,\n    MCPointInRing: MCPointInRing,\n    MinimumBoundingCircle: MinimumBoundingCircle,\n    MinimumDiameter: MinimumDiameter\n  });\n\n  function GeometryTransformer() {\n    this._inputGeom = null;\n    this._factory = null;\n    this._pruneEmptyGeometry = true;\n    this._preserveGeometryCollectionType = true;\n    this._preserveCollections = false;\n    this._preserveType = false;\n  }\n  extend(GeometryTransformer.prototype, {\n    transformPoint: function transformPoint(geom, parent) {\n      return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n    },\n    transformPolygon: function transformPolygon(geom, parent) {\n      var isAllValidLinearRings = true;\n      var shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n      if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n      var holes = new ArrayList();\n\n      for (var i = 0; i < geom.getNumInteriorRing(); i++) {\n        var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n\n        if (hole === null || hole.isEmpty()) {\n          continue;\n        }\n\n        if (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n        holes.add(hole);\n      }\n\n      if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {\n        var components = new ArrayList();\n        if (shell !== null) components.add(shell);\n        components.addAll(holes);\n        return this._factory.buildGeometry(components);\n      }\n    },\n    createCoordinateSequence: function createCoordinateSequence(coords) {\n      return this._factory.getCoordinateSequenceFactory().create(coords);\n    },\n    getInputGeometry: function getInputGeometry() {\n      return this._inputGeom;\n    },\n    transformMultiLineString: function transformMultiLineString(geom, parent) {\n      var transGeomList = new ArrayList();\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    },\n    transformCoordinates: function transformCoordinates(coords, parent) {\n      return this.copy(coords);\n    },\n    transformLineString: function transformLineString(geom, parent) {\n      return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n    },\n    transformMultiPoint: function transformMultiPoint(geom, parent) {\n      var transGeomList = new ArrayList();\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    },\n    transformMultiPolygon: function transformMultiPolygon(geom, parent) {\n      var transGeomList = new ArrayList();\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    },\n    copy: function copy(seq) {\n      return seq.copy();\n    },\n    transformGeometryCollection: function transformGeometryCollection(geom, parent) {\n      var transGeomList = new ArrayList();\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var transformGeom = this.transform(geom.getGeometryN(i));\n        if (transformGeom === null) continue;\n        if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n      return this._factory.buildGeometry(transGeomList);\n    },\n    transform: function transform(inputGeom) {\n      this._inputGeom = inputGeom;\n      this._factory = inputGeom.getFactory();\n      if (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n      if (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n      if (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n      if (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n      if (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n      if (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n      if (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n      if (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n      throw new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n    },\n    transformLinearRing: function transformLinearRing(geom, parent) {\n      var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n      if (seq === null) return this._factory.createLinearRing(null);\n      var seqSize = seq.size();\n      if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n      return this._factory.createLinearRing(seq);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryTransformer;\n    }\n  });\n\n  function Densifier() {\n    this._inputGeom = null;\n    this._distanceTolerance = null;\n    var inputGeom = arguments[0];\n    this._inputGeom = inputGeom;\n  }\n  extend(Densifier.prototype, {\n    getResultGeometry: function getResultGeometry() {\n      return new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);\n    },\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance <= 0.0) throw new IllegalArgumentException(\"Tolerance must be positive\");\n      this._distanceTolerance = distanceTolerance;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Densifier;\n    }\n  });\n\n  Densifier.densifyPoints = function (pts, distanceTolerance, precModel) {\n    var seg = new LineSegment();\n    var coordList = new CoordinateList();\n\n    for (var i = 0; i < pts.length - 1; i++) {\n      seg.p0 = pts[i];\n      seg.p1 = pts[i + 1];\n      coordList.add(seg.p0, false);\n      var len = seg.getLength();\n      var densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n\n      if (densifiedSegCount > 1) {\n        var densifiedSegLen = len / densifiedSegCount;\n\n        for (var j = 1; j < densifiedSegCount; j++) {\n          var segFract = j * densifiedSegLen / len;\n          var p = seg.pointAlong(segFract);\n          precModel.makePrecise(p);\n          coordList.add(p, false);\n        }\n      }\n    }\n\n    coordList.add(pts[pts.length - 1], false);\n    return coordList.toCoordinateArray();\n  };\n\n  Densifier.densify = function (geom, distanceTolerance) {\n    var densifier = new Densifier(geom);\n    densifier.setDistanceTolerance(distanceTolerance);\n    return densifier.getResultGeometry();\n  };\n\n  function DensifyTransformer() {\n    GeometryTransformer.apply(this);\n    this.distanceTolerance = null;\n    var distanceTolerance = arguments[0];\n    this.distanceTolerance = distanceTolerance;\n  }\n\n  inherits(DensifyTransformer, GeometryTransformer);\n  extend(DensifyTransformer.prototype, {\n    transformMultiPolygon: function transformMultiPolygon(geom, parent) {\n      var roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n      return this.createValidArea(roughGeom);\n    },\n    transformPolygon: function transformPolygon(geom, parent) {\n      var roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\n      if (parent instanceof MultiPolygon) {\n        return roughGeom;\n      }\n\n      return this.createValidArea(roughGeom);\n    },\n    transformCoordinates: function transformCoordinates(coords, parent) {\n      var inputPts = coords.toCoordinateArray();\n      var newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n\n      if (parent instanceof LineString && newPts.length === 1) {\n        newPts = new Array(0).fill(null);\n      }\n\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    },\n    createValidArea: function createValidArea(roughAreaGeom) {\n      return roughAreaGeom.buffer(0.0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DensifyTransformer;\n    }\n  });\n  Densifier.DensifyTransformer = DensifyTransformer;\n\n\n\n  var densify = /*#__PURE__*/Object.freeze({\n    Densifier: Densifier\n  });\n\n  function HalfEdge() {\n    this._orig = null;\n    this._sym = null;\n    this._next = null;\n    var orig = arguments[0];\n    this._orig = orig;\n  }\n  extend(HalfEdge.prototype, {\n    find: function find(dest) {\n      var oNext = this;\n\n      do {\n        if (oNext === null) return null;\n        if (oNext.dest().equals2D(dest)) return oNext;\n        oNext = oNext.oNext();\n      } while (oNext !== this);\n\n      return null;\n    },\n    dest: function dest() {\n      return this._sym._orig;\n    },\n    oNext: function oNext() {\n      return this._sym._next;\n    },\n    insert: function insert(e) {\n      if (this.oNext() === this) {\n        this.insertAfter(e);\n        return null;\n      }\n\n      var ecmp = this.compareTo(e);\n      var ePrev = this;\n\n      do {\n        var oNext = ePrev.oNext();\n        var cmp = oNext.compareTo(e);\n\n        if (cmp !== ecmp || oNext === this) {\n          ePrev.insertAfter(e);\n          return null;\n        }\n\n        ePrev = oNext;\n      } while (ePrev !== this);\n\n      Assert.shouldNeverReachHere();\n    },\n    insertAfter: function insertAfter(e) {\n      Assert.equals(this._orig, e.orig());\n      var save = this.oNext();\n\n      this._sym.setNext(e);\n\n      e.sym().setNext(save);\n    },\n    degree: function degree() {\n      var degree = 0;\n      var e = this;\n\n      do {\n        degree++;\n        e = e.oNext();\n      } while (e !== this);\n\n      return degree;\n    },\n    equals: function equals() {\n      if (arguments.length === 2 && arguments[1] instanceof Coordinate && arguments[0] instanceof Coordinate) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n        return this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n      }\n    },\n    deltaY: function deltaY() {\n      return this._sym._orig.y - this._orig.y;\n    },\n    sym: function sym() {\n      return this._sym;\n    },\n    prev: function prev() {\n      return this._sym.next()._sym;\n    },\n    compareAngularDirection: function compareAngularDirection(e) {\n      var dx = this.deltaX();\n      var dy = this.deltaY();\n      var dx2 = e.deltaX();\n      var dy2 = e.deltaY();\n      if (dx === dx2 && dy === dy2) return 0;\n      var quadrant = Quadrant.quadrant(dx, dy);\n      var quadrant2 = Quadrant.quadrant(dx2, dy2);\n      if (quadrant > quadrant2) return 1;\n      if (quadrant < quadrant2) return -1;\n      return Orientation.index(e._orig, e.dest(), this.dest());\n    },\n    prevNode: function prevNode() {\n      var e = this;\n\n      while (e.degree() === 2) {\n        e = e.prev();\n        if (e === this) return null;\n      }\n\n      return e;\n    },\n    compareTo: function compareTo(obj) {\n      var e = obj;\n      var comp = this.compareAngularDirection(e);\n      return comp;\n    },\n    next: function next() {\n      return this._next;\n    },\n    setSym: function setSym(e) {\n      this._sym = e;\n    },\n    orig: function orig() {\n      return this._orig;\n    },\n    toString: function toString() {\n      return \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n    },\n    setNext: function setNext(e) {\n      this._next = e;\n    },\n    init: function init(e) {\n      this.setSym(e);\n      e.setSym(this);\n      this.setNext(e);\n      e.setNext(this);\n    },\n    deltaX: function deltaX() {\n      return this._sym._orig.x - this._orig.x;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return HalfEdge;\n    }\n  });\n\n  HalfEdge.init = function (e0, e1) {\n    if (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException(\"Edges are already initialized\");\n    e0.init(e1);\n    return e0;\n  };\n\n  HalfEdge.create = function (p0, p1) {\n    var e0 = new HalfEdge(p0);\n    var e1 = new HalfEdge(p1);\n    e0.init(e1);\n    return e0;\n  };\n\n  function MarkHalfEdge() {\n    this._isMarked = false;\n    var orig = arguments[0];\n    HalfEdge.call(this, orig);\n  }\n  inherits(MarkHalfEdge, HalfEdge);\n  extend(MarkHalfEdge.prototype, {\n    mark: function mark() {\n      this._isMarked = true;\n    },\n    setMark: function setMark(isMarked) {\n      this._isMarked = isMarked;\n    },\n    isMarked: function isMarked() {\n      return this._isMarked;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MarkHalfEdge;\n    }\n  });\n\n  MarkHalfEdge.setMarkBoth = function (e, isMarked) {\n    e.setMark(isMarked);\n    e.sym().setMark(isMarked);\n  };\n\n  MarkHalfEdge.isMarked = function (e) {\n    return e.isMarked();\n  };\n\n  MarkHalfEdge.setMark = function (e, isMarked) {\n    e.setMark(isMarked);\n  };\n\n  MarkHalfEdge.markBoth = function (e) {\n    e.mark();\n    e.sym().mark();\n  };\n\n  MarkHalfEdge.mark = function (e) {\n    e.mark();\n  };\n\n  function EdgeGraph() {\n    this._vertexMap = new HashMap();\n  }\n  extend(EdgeGraph.prototype, {\n    insert: function insert(orig, dest, eAdj) {\n      var e = this.create(orig, dest);\n\n      if (eAdj !== null) {\n        eAdj.insert(e);\n      } else {\n        this._vertexMap.put(orig, e);\n      }\n\n      var eAdjDest = this._vertexMap.get(dest);\n\n      if (eAdjDest !== null) {\n        eAdjDest.insert(e.sym());\n      } else {\n        this._vertexMap.put(dest, e.sym());\n      }\n\n      return e;\n    },\n    create: function create(p0, p1) {\n      var e0 = this.createEdge(p0);\n      var e1 = this.createEdge(p1);\n      HalfEdge.init(e0, e1);\n      return e0;\n    },\n    createEdge: function createEdge(orig) {\n      return new HalfEdge(orig);\n    },\n    addEdge: function addEdge(orig, dest) {\n      if (!EdgeGraph.isValidEdge(orig, dest)) return null;\n\n      var eAdj = this._vertexMap.get(orig);\n\n      var eSame = null;\n\n      if (eAdj !== null) {\n        eSame = eAdj.find(dest);\n      }\n\n      if (eSame !== null) {\n        return eSame;\n      }\n\n      var e = this.insert(orig, dest, eAdj);\n      return e;\n    },\n    getVertexEdges: function getVertexEdges() {\n      return this._vertexMap.values();\n    },\n    findEdge: function findEdge(orig, dest) {\n      var e = this._vertexMap.get(orig);\n\n      if (e === null) return null;\n      return e.find(dest);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeGraph;\n    }\n  });\n\n  EdgeGraph.isValidEdge = function (orig, dest) {\n    var cmp = dest.compareTo(orig);\n    return cmp !== 0;\n  };\n\n  function DissolveHalfEdge() {\n    this._isStart = false;\n    var orig = arguments[0];\n    MarkHalfEdge.call(this, orig);\n  }\n  inherits(DissolveHalfEdge, MarkHalfEdge);\n  extend(DissolveHalfEdge.prototype, {\n    setStart: function setStart() {\n      this._isStart = true;\n    },\n    isStart: function isStart() {\n      return this._isStart;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DissolveHalfEdge;\n    }\n  });\n\n  function DissolveEdgeGraph() {\n    EdgeGraph.apply(this);\n  }\n  inherits(DissolveEdgeGraph, EdgeGraph);\n  extend(DissolveEdgeGraph.prototype, {\n    createEdge: function createEdge(p0) {\n      return new DissolveHalfEdge(p0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DissolveEdgeGraph;\n    }\n  });\n\n  function LineDissolver() {\n    this._result = null;\n    this._factory = null;\n    this._graph = null;\n    this._lines = new ArrayList();\n    this._nodeEdgeStack = new Stack();\n    this._ringStartEdge = null;\n    this._graph = new DissolveEdgeGraph();\n  }\n  extend(LineDissolver.prototype, {\n    addLine: function addLine(line) {\n      this._lines.add(this._factory.createLineString(line.toCoordinateArray()));\n    },\n    updateRingStartEdge: function updateRingStartEdge(e) {\n      if (!e.isStart()) {\n        e = e.sym();\n        if (!e.isStart()) return null;\n      }\n\n      if (this._ringStartEdge === null) {\n        this._ringStartEdge = e;\n        return null;\n      }\n\n      if (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {\n        this._ringStartEdge = e;\n      }\n    },\n    getResult: function getResult() {\n      if (this._result === null) this.computeResult();\n      return this._result;\n    },\n    process: function process(e) {\n      var eNode = e.prevNode();\n      if (eNode === null) eNode = e;\n      this.stackEdges(eNode);\n      this.buildLines();\n    },\n    buildRing: function buildRing(eStartRing) {\n      var line = new CoordinateList();\n      var e = eStartRing;\n      line.add(e.orig().copy(), false);\n\n      while (e.sym().degree() === 2) {\n        var eNext = e.next();\n        if (eNext === eStartRing) break;\n        line.add(eNext.orig().copy(), false);\n        e = eNext;\n      }\n\n      line.add(e.dest().copy(), false);\n      this.addLine(line);\n    },\n    buildLine: function buildLine(eStart) {\n      var line = new CoordinateList();\n      var e = eStart;\n      this._ringStartEdge = null;\n      MarkHalfEdge.markBoth(e);\n      line.add(e.orig().copy(), false);\n\n      while (e.sym().degree() === 2) {\n        this.updateRingStartEdge(e);\n        var eNext = e.next();\n\n        if (eNext === eStart) {\n          this.buildRing(this._ringStartEdge);\n          return null;\n        }\n\n        line.add(eNext.orig().copy(), false);\n        e = eNext;\n        MarkHalfEdge.markBoth(e);\n      }\n\n      line.add(e.dest().clone(), false);\n      this.stackEdges(e.sym());\n      this.addLine(line);\n    },\n    stackEdges: function stackEdges(node) {\n      var e = node;\n\n      do {\n        if (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);\n        e = e.oNext();\n      } while (e !== node);\n    },\n    computeResult: function computeResult() {\n      var edges = this._graph.getVertexEdges();\n\n      for (var i = edges.iterator(); i.hasNext();) {\n        var e = i.next();\n        if (MarkHalfEdge.isMarked(e)) continue;\n        this.process(e);\n      }\n\n      this._result = this._factory.buildGeometry(this._lines);\n    },\n    buildLines: function buildLines() {\n      while (!this._nodeEdgeStack.empty()) {\n        var e = this._nodeEdgeStack.pop();\n\n        if (MarkHalfEdge.isMarked(e)) continue;\n        this.buildLine(e);\n      }\n    },\n    add: function add() {\n      if (arguments[0] instanceof Geometry) {\n        var _geometry = arguments[0];\n\n        _geometry.apply({\n          interfaces_: function interfaces_() {\n            return [GeometryComponentFilter];\n          },\n          filter: function filter(component) {\n            if (component instanceof LineString) {\n              this.add(component);\n            }\n          }\n        });\n      } else if (hasInterface(arguments[0], Collection)) {\n        var geometries = arguments[0];\n\n        for (var i = geometries.iterator(); i.hasNext();) {\n          var geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof LineString) {\n        var lineString = arguments[0];\n\n        if (this._factory === null) {\n          this._factory = lineString.getFactory();\n        }\n\n        var seq = lineString.getCoordinateSequence();\n        var doneStart = false;\n\n        for (var i = 1; i < seq.size(); i++) {\n          var e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n\n          if (e === null) continue;\n\n          if (!doneStart) {\n            e.setStart();\n            doneStart = true;\n          }\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineDissolver;\n    }\n  });\n\n  LineDissolver.dissolve = function (g) {\n    var d = new LineDissolver();\n    d.add(g);\n    return d.getResult();\n  };\n\n\n\n  var dissolve = /*#__PURE__*/Object.freeze({\n    LineDissolver: LineDissolver\n  });\n\n  function PointLocator() {\n    this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n    this._isIn = null;\n    this._numBoundaries = null;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var boundaryRule = arguments[0];\n      if (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n      this._boundaryRule = boundaryRule;\n    }\n  }\n  extend(PointLocator.prototype, {\n    locateInPolygonRing: function locateInPolygonRing(p, ring) {\n      if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      return PointLocation.locateInRing(p, ring.getCoordinates());\n    },\n    intersects: function intersects(p, geom) {\n      return this.locate(p, geom) !== Location.EXTERIOR;\n    },\n    updateLocationInfo: function updateLocationInfo(loc) {\n      if (loc === Location.INTERIOR) this._isIn = true;\n      if (loc === Location.BOUNDARY) this._numBoundaries++;\n    },\n    computeLocation: function computeLocation(p, geom) {\n      if (geom instanceof Point) {\n        this.updateLocationInfo(this.locateOnPoint(p, geom));\n      }\n\n      if (geom instanceof LineString) {\n        this.updateLocationInfo(this.locateOnLineString(p, geom));\n      } else if (geom instanceof Polygon) {\n        this.updateLocationInfo(this.locateInPolygon(p, geom));\n      } else if (geom instanceof MultiLineString) {\n        var ml = geom;\n\n        for (var i = 0; i < ml.getNumGeometries(); i++) {\n          var l = ml.getGeometryN(i);\n          this.updateLocationInfo(this.locateOnLineString(p, l));\n        }\n      } else if (geom instanceof MultiPolygon) {\n        var mpoly = geom;\n\n        for (var i = 0; i < mpoly.getNumGeometries(); i++) {\n          var poly = mpoly.getGeometryN(i);\n          this.updateLocationInfo(this.locateInPolygon(p, poly));\n        }\n      } else if (geom instanceof GeometryCollection) {\n        var geomi = new GeometryCollectionIterator(geom);\n\n        while (geomi.hasNext()) {\n          var g2 = geomi.next();\n          if (g2 !== geom) this.computeLocation(p, g2);\n        }\n      }\n    },\n    locateOnPoint: function locateOnPoint(p, pt) {\n      var ptCoord = pt.getCoordinate();\n      if (ptCoord.equals2D(p)) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    },\n    locateOnLineString: function locateOnLineString(p, l) {\n      if (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      var seq = l.getCoordinateSequence();\n\n      if (!l.isClosed()) {\n        if (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {\n          return Location.BOUNDARY;\n        }\n      }\n\n      if (PointLocation.isOnLine(p, seq)) {\n        return Location.INTERIOR;\n      }\n\n      return Location.EXTERIOR;\n    },\n    locateInPolygon: function locateInPolygon(p, poly) {\n      if (poly.isEmpty()) return Location.EXTERIOR;\n      var shell = poly.getExteriorRing();\n      var shellLoc = this.locateInPolygonRing(p, shell);\n      if (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n      if (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\n      for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n        var hole = poly.getInteriorRingN(i);\n        var holeLoc = this.locateInPolygonRing(p, hole);\n        if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n        if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n      }\n\n      return Location.INTERIOR;\n    },\n    locate: function locate(p, geom) {\n      if (geom.isEmpty()) return Location.EXTERIOR;\n\n      if (geom instanceof LineString) {\n        return this.locateOnLineString(p, geom);\n      } else if (geom instanceof Polygon) {\n        return this.locateInPolygon(p, geom);\n      }\n\n      this._isIn = false;\n      this._numBoundaries = 0;\n      this.computeLocation(p, geom);\n      if (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n      if (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointLocator;\n    }\n  });\n\n  function Position() {}\n  extend(Position.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Position;\n    }\n  });\n\n  Position.opposite = function (position) {\n    if (position === Position.LEFT) return Position.RIGHT;\n    if (position === Position.RIGHT) return Position.LEFT;\n    return position;\n  };\n\n  Position.ON = 0;\n  Position.LEFT = 1;\n  Position.RIGHT = 2;\n\n  function MonotoneChain$1() {\n    this.mce = null;\n    this.chainIndex = null;\n    var mce = arguments[0],\n        chainIndex = arguments[1];\n    this.mce = mce;\n    this.chainIndex = chainIndex;\n  }\n  extend(MonotoneChain$1.prototype, {\n    computeIntersections: function computeIntersections(mc, si) {\n      this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChain$1;\n    }\n  });\n\n  function SweepLineEvent() {\n    this._label = null;\n    this._xValue = null;\n    this._eventType = null;\n    this._insertEvent = null;\n    this._deleteEventIndex = null;\n    this._obj = null;\n\n    if (arguments.length === 2) {\n      var x = arguments[0],\n          insertEvent = arguments[1];\n      this._eventType = SweepLineEvent.DELETE;\n      this._xValue = x;\n      this._insertEvent = insertEvent;\n    } else if (arguments.length === 3) {\n      var label = arguments[0],\n          _x = arguments[1],\n          obj = arguments[2];\n      this._eventType = SweepLineEvent.INSERT;\n      this._label = label;\n      this._xValue = _x;\n      this._obj = obj;\n    }\n  }\n  extend(SweepLineEvent.prototype, {\n    isDelete: function isDelete() {\n      return this._eventType === SweepLineEvent.DELETE;\n    },\n    setDeleteEventIndex: function setDeleteEventIndex(deleteEventIndex) {\n      this._deleteEventIndex = deleteEventIndex;\n    },\n    getObject: function getObject() {\n      return this._obj;\n    },\n    compareTo: function compareTo(o) {\n      var pe = o;\n      if (this._xValue < pe._xValue) return -1;\n      if (this._xValue > pe._xValue) return 1;\n      if (this._eventType < pe._eventType) return -1;\n      if (this._eventType > pe._eventType) return 1;\n      return 0;\n    },\n    getInsertEvent: function getInsertEvent() {\n      return this._insertEvent;\n    },\n    isInsert: function isInsert() {\n      return this._eventType === SweepLineEvent.INSERT;\n    },\n    isSameLabel: function isSameLabel(ev) {\n      if (this._label === null) return false;\n      return this._label === ev._label;\n    },\n    getDeleteEventIndex: function getDeleteEventIndex() {\n      return this._deleteEventIndex;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return SweepLineEvent;\n    }\n  });\n  SweepLineEvent.INSERT = 1;\n  SweepLineEvent.DELETE = 2;\n\n  function EdgeSetIntersector() {}\n  extend(EdgeSetIntersector.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeSetIntersector;\n    }\n  });\n\n  function SegmentIntersector() {\n    this._hasIntersection = false;\n    this._hasProper = false;\n    this._hasProperInterior = false;\n    this._properIntersectionPoint = null;\n    this._li = null;\n    this._includeProper = null;\n    this._recordIsolated = null;\n    this._isSelfIntersection = null;\n    this._numIntersections = 0;\n    this.numTests = 0;\n    this._bdyNodes = null;\n    this._isDone = false;\n    this._isDoneWhenProperInt = false;\n    var li = arguments[0],\n        includeProper = arguments[1],\n        recordIsolated = arguments[2];\n    this._li = li;\n    this._includeProper = includeProper;\n    this._recordIsolated = recordIsolated;\n  }\n  extend(SegmentIntersector.prototype, {\n    isTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1) {\n        if (this._li.getIntersectionNum() === 1) {\n          if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\n          if (e0.isClosed()) {\n            var maxSegIndex = e0.getNumPoints() - 1;\n\n            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    },\n    getProperIntersectionPoint: function getProperIntersectionPoint() {\n      return this._properIntersectionPoint;\n    },\n    setIsDoneIfProperInt: function setIsDoneIfProperInt(isDoneWhenProperInt) {\n      this._isDoneWhenProperInt = isDoneWhenProperInt;\n    },\n    hasProperInteriorIntersection: function hasProperInteriorIntersection() {\n      return this._hasProperInterior;\n    },\n    isBoundaryPointInternal: function isBoundaryPointInternal(li, bdyNodes) {\n      for (var i = bdyNodes.iterator(); i.hasNext();) {\n        var node = i.next();\n        var pt = node.getCoordinate();\n        if (li.isIntersection(pt)) return true;\n      }\n\n      return false;\n    },\n    hasProperIntersection: function hasProperIntersection() {\n      return this._hasProper;\n    },\n    hasIntersection: function hasIntersection() {\n      return this._hasIntersection;\n    },\n    isDone: function isDone() {\n      return this._isDone;\n    },\n    isBoundaryPoint: function isBoundaryPoint(li, bdyNodes) {\n      if (bdyNodes === null) return false;\n      if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n      if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n      return false;\n    },\n    setBoundaryNodes: function setBoundaryNodes(bdyNodes0, bdyNodes1) {\n      this._bdyNodes = new Array(2).fill(null);\n      this._bdyNodes[0] = bdyNodes0;\n      this._bdyNodes[1] = bdyNodes1;\n    },\n    addIntersections: function addIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      this.numTests++;\n      var p00 = e0.getCoordinates()[segIndex0];\n      var p01 = e0.getCoordinates()[segIndex0 + 1];\n      var p10 = e1.getCoordinates()[segIndex1];\n      var p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        if (this._recordIsolated) {\n          e0.setIsolated(false);\n          e1.setIsolated(false);\n        }\n\n        this._numIntersections++;\n\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n          this._hasIntersection = true;\n\n          if (this._includeProper || !this._li.isProper()) {\n            e0.addIntersections(this._li, segIndex0, 0);\n            e1.addIntersections(this._li, segIndex1, 1);\n          }\n\n          if (this._li.isProper()) {\n            this._properIntersectionPoint = this._li.getIntersection(0).copy();\n            this._hasProper = true;\n\n            if (this._isDoneWhenProperInt) {\n              this._isDone = true;\n            }\n\n            if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n          }\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentIntersector;\n    }\n  });\n\n  SegmentIntersector.isAdjacentSegments = function (i1, i2) {\n    return Math.abs(i1 - i2) === 1;\n  };\n\n  function SimpleMCSweepLineIntersector() {\n    EdgeSetIntersector.apply(this);\n    this.events = new ArrayList();\n    this.nOverlaps = null;\n  }\n  inherits(SimpleMCSweepLineIntersector, EdgeSetIntersector);\n  extend(SimpleMCSweepLineIntersector.prototype, {\n    prepareEvents: function prepareEvents() {\n      Collections.sort(this.events);\n\n      for (var i = 0; i < this.events.size(); i++) {\n        var ev = this.events.get(i);\n\n        if (ev.isDelete()) {\n          ev.getInsertEvent().setDeleteEventIndex(i);\n        }\n      }\n    },\n    computeIntersections: function computeIntersections() {\n      if (arguments.length === 1) {\n        var si = arguments[0];\n        this.nOverlaps = 0;\n        this.prepareEvents();\n\n        for (var i = 0; i < this.events.size(); i++) {\n          var ev = this.events.get(i);\n\n          if (ev.isInsert()) {\n            this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n          }\n\n          if (si.isDone()) {\n            break;\n          }\n        }\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof SegmentIntersector && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n          var edges0 = arguments[0],\n              edges1 = arguments[1],\n              _si = arguments[2];\n          this.addEdges(edges0, edges0);\n          this.addEdges(edges1, edges1);\n          this.computeIntersections(_si);\n        } else if (typeof arguments[2] === \"boolean\" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector) {\n          var edges = arguments[0],\n              _si2 = arguments[1],\n              testAllSegments = arguments[2];\n          if (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);\n          this.computeIntersections(_si2);\n        }\n      }\n    },\n    addEdge: function addEdge(edge, edgeSet) {\n      var mce = edge.getMonotoneChainEdge();\n      var startIndex = mce.getStartIndexes();\n\n      for (var i = 0; i < startIndex.length - 1; i++) {\n        var mc = new MonotoneChain$1(mce, i);\n        var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n        this.events.add(insertEvent);\n        this.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n      }\n    },\n    processOverlaps: function processOverlaps(start, end, ev0, si) {\n      var mc0 = ev0.getObject();\n\n      for (var i = start; i < end; i++) {\n        var ev1 = this.events.get(i);\n\n        if (ev1.isInsert()) {\n          var mc1 = ev1.getObject();\n\n          if (!ev0.isSameLabel(ev1)) {\n            mc0.computeIntersections(mc1, si);\n            this.nOverlaps++;\n          }\n        }\n      }\n    },\n    addEdges: function addEdges() {\n      if (arguments.length === 1) {\n        var edges = arguments[0];\n\n        for (var i = edges.iterator(); i.hasNext();) {\n          var edge = i.next();\n          this.addEdge(edge, edge);\n        }\n      } else if (arguments.length === 2) {\n        var _edges = arguments[0],\n            edgeSet = arguments[1];\n\n        for (var i = _edges.iterator(); i.hasNext();) {\n          var edge = i.next();\n          this.addEdge(edge, edgeSet);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SimpleMCSweepLineIntersector;\n    }\n  });\n\n  function TopologyLocation() {\n    this.location = null;\n\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        var location = arguments[0];\n        this.init(location.length);\n      } else if (Number.isInteger(arguments[0])) {\n        var on = arguments[0];\n        this.init(1);\n        this.location[Position.ON] = on;\n      } else if (arguments[0] instanceof TopologyLocation) {\n        var gl = arguments[0];\n        this.init(gl.location.length);\n\n        if (gl !== null) {\n          for (var i = 0; i < this.location.length; i++) {\n            this.location[i] = gl.location[i];\n          }\n        }\n      }\n    } else if (arguments.length === 3) {\n      var _on = arguments[0],\n          left = arguments[1],\n          right = arguments[2];\n      this.init(3);\n      this.location[Position.ON] = _on;\n      this.location[Position.LEFT] = left;\n      this.location[Position.RIGHT] = right;\n    }\n  }\n  extend(TopologyLocation.prototype, {\n    setAllLocations: function setAllLocations(locValue) {\n      for (var i = 0; i < this.location.length; i++) {\n        this.location[i] = locValue;\n      }\n    },\n    isNull: function isNull() {\n      for (var i = 0; i < this.location.length; i++) {\n        if (this.location[i] !== Location.NONE) return false;\n      }\n\n      return true;\n    },\n    setAllLocationsIfNull: function setAllLocationsIfNull(locValue) {\n      for (var i = 0; i < this.location.length; i++) {\n        if (this.location[i] === Location.NONE) this.location[i] = locValue;\n      }\n    },\n    isLine: function isLine() {\n      return this.location.length === 1;\n    },\n    merge: function merge(gl) {\n      if (gl.location.length > this.location.length) {\n        var newLoc = new Array(3).fill(null);\n        newLoc[Position.ON] = this.location[Position.ON];\n        newLoc[Position.LEFT] = Location.NONE;\n        newLoc[Position.RIGHT] = Location.NONE;\n        this.location = newLoc;\n      }\n\n      for (var i = 0; i < this.location.length; i++) {\n        if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n      }\n    },\n    getLocations: function getLocations() {\n      return this.location;\n    },\n    flip: function flip() {\n      if (this.location.length <= 1) return null;\n      var temp = this.location[Position.LEFT];\n      this.location[Position.LEFT] = this.location[Position.RIGHT];\n      this.location[Position.RIGHT] = temp;\n    },\n    toString: function toString() {\n      var buf = new StringBuffer();\n      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n      buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n      return buf.toString();\n    },\n    setLocations: function setLocations(on, left, right) {\n      this.location[Position.ON] = on;\n      this.location[Position.LEFT] = left;\n      this.location[Position.RIGHT] = right;\n    },\n    get: function get(posIndex) {\n      if (posIndex < this.location.length) return this.location[posIndex];\n      return Location.NONE;\n    },\n    isArea: function isArea() {\n      return this.location.length > 1;\n    },\n    isAnyNull: function isAnyNull() {\n      for (var i = 0; i < this.location.length; i++) {\n        if (this.location[i] === Location.NONE) return true;\n      }\n\n      return false;\n    },\n    setLocation: function setLocation() {\n      if (arguments.length === 1) {\n        var locValue = arguments[0];\n        this.setLocation(Position.ON, locValue);\n      } else if (arguments.length === 2) {\n        var locIndex = arguments[0],\n            _locValue = arguments[1];\n        this.location[locIndex] = _locValue;\n      }\n    },\n    init: function init(size) {\n      this.location = new Array(size).fill(null);\n      this.setAllLocations(Location.NONE);\n    },\n    isEqualOnSide: function isEqualOnSide(le, locIndex) {\n      return this.location[locIndex] === le.location[locIndex];\n    },\n    allPositionsEqual: function allPositionsEqual(loc) {\n      for (var i = 0; i < this.location.length; i++) {\n        if (this.location[i] !== loc) return false;\n      }\n\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TopologyLocation;\n    }\n  });\n\n  function Label() {\n    this.elt = new Array(2).fill(null);\n\n    if (arguments.length === 1) {\n      if (Number.isInteger(arguments[0])) {\n        var onLoc = arguments[0];\n        this.elt[0] = new TopologyLocation(onLoc);\n        this.elt[1] = new TopologyLocation(onLoc);\n      } else if (arguments[0] instanceof Label) {\n        var lbl = arguments[0];\n        this.elt[0] = new TopologyLocation(lbl.elt[0]);\n        this.elt[1] = new TopologyLocation(lbl.elt[1]);\n      }\n    } else if (arguments.length === 2) {\n      var geomIndex = arguments[0],\n          _onLoc = arguments[1];\n      this.elt[0] = new TopologyLocation(Location.NONE);\n      this.elt[1] = new TopologyLocation(Location.NONE);\n      this.elt[geomIndex].setLocation(_onLoc);\n    } else if (arguments.length === 3) {\n      var _onLoc2 = arguments[0],\n          leftLoc = arguments[1],\n          rightLoc = arguments[2];\n      this.elt[0] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);\n      this.elt[1] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);\n    } else if (arguments.length === 4) {\n      var _geomIndex = arguments[0],\n          _onLoc3 = arguments[1],\n          _leftLoc = arguments[2],\n          _rightLoc = arguments[3];\n      this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n      this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\n      this.elt[_geomIndex].setLocations(_onLoc3, _leftLoc, _rightLoc);\n    }\n  }\n  extend(Label.prototype, {\n    getGeometryCount: function getGeometryCount() {\n      var count = 0;\n      if (!this.elt[0].isNull()) count++;\n      if (!this.elt[1].isNull()) count++;\n      return count;\n    },\n    setAllLocations: function setAllLocations(geomIndex, location) {\n      this.elt[geomIndex].setAllLocations(location);\n    },\n    isNull: function isNull(geomIndex) {\n      return this.elt[geomIndex].isNull();\n    },\n    setAllLocationsIfNull: function setAllLocationsIfNull() {\n      if (arguments.length === 1) {\n        var location = arguments[0];\n        this.setAllLocationsIfNull(0, location);\n        this.setAllLocationsIfNull(1, location);\n      } else if (arguments.length === 2) {\n        var geomIndex = arguments[0],\n            _location = arguments[1];\n        this.elt[geomIndex].setAllLocationsIfNull(_location);\n      }\n    },\n    isLine: function isLine(geomIndex) {\n      return this.elt[geomIndex].isLine();\n    },\n    merge: function merge(lbl) {\n      for (var i = 0; i < 2; i++) {\n        if (this.elt[i] === null && lbl.elt[i] !== null) {\n          this.elt[i] = new TopologyLocation(lbl.elt[i]);\n        } else {\n          this.elt[i].merge(lbl.elt[i]);\n        }\n      }\n    },\n    flip: function flip() {\n      this.elt[0].flip();\n      this.elt[1].flip();\n    },\n    getLocation: function getLocation() {\n      if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this.elt[geomIndex].get(Position.ON);\n      } else if (arguments.length === 2) {\n        var _geomIndex2 = arguments[0],\n            posIndex = arguments[1];\n        return this.elt[_geomIndex2].get(posIndex);\n      }\n    },\n    toString: function toString() {\n      var buf = new StringBuffer();\n\n      if (this.elt[0] !== null) {\n        buf.append(\"A:\");\n        buf.append(this.elt[0].toString());\n      }\n\n      if (this.elt[1] !== null) {\n        buf.append(\" B:\");\n        buf.append(this.elt[1].toString());\n      }\n\n      return buf.toString();\n    },\n    isArea: function isArea() {\n      if (arguments.length === 0) {\n        return this.elt[0].isArea() || this.elt[1].isArea();\n      } else if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this.elt[geomIndex].isArea();\n      }\n    },\n    isAnyNull: function isAnyNull(geomIndex) {\n      return this.elt[geomIndex].isAnyNull();\n    },\n    setLocation: function setLocation() {\n      if (arguments.length === 2) {\n        var geomIndex = arguments[0],\n            location = arguments[1];\n        this.elt[geomIndex].setLocation(Position.ON, location);\n      } else if (arguments.length === 3) {\n        var _geomIndex3 = arguments[0],\n            posIndex = arguments[1],\n            _location2 = arguments[2];\n\n        this.elt[_geomIndex3].setLocation(posIndex, _location2);\n      }\n    },\n    isEqualOnSide: function isEqualOnSide(lbl, side) {\n      return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n    },\n    allPositionsEqual: function allPositionsEqual(geomIndex, loc) {\n      return this.elt[geomIndex].allPositionsEqual(loc);\n    },\n    toLine: function toLine(geomIndex) {\n      if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Label;\n    }\n  });\n\n  Label.toLineLabel = function (label) {\n    var lineLabel = new Label(Location.NONE);\n\n    for (var i = 0; i < 2; i++) {\n      lineLabel.setLocation(i, label.getLocation(i));\n    }\n\n    return lineLabel;\n  };\n\n  function EdgeIntersection() {\n    this.coord = null;\n    this.segmentIndex = null;\n    this.dist = null;\n    var coord = arguments[0],\n        segmentIndex = arguments[1],\n        dist = arguments[2];\n    this.coord = new Coordinate(coord);\n    this.segmentIndex = segmentIndex;\n    this.dist = dist;\n  }\n  extend(EdgeIntersection.prototype, {\n    getSegmentIndex: function getSegmentIndex() {\n      return this.segmentIndex;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.coord;\n    },\n    print: function print(out) {\n      out.print(this.coord);\n      out.print(\" seg # = \" + this.segmentIndex);\n      out.println(\" dist = \" + this.dist);\n    },\n    compareTo: function compareTo(obj) {\n      var other = obj;\n      return this.compare(other.segmentIndex, other.dist);\n    },\n    isEndPoint: function isEndPoint(maxSegmentIndex) {\n      if (this.segmentIndex === 0 && this.dist === 0.0) return true;\n      if (this.segmentIndex === maxSegmentIndex) return true;\n      return false;\n    },\n    toString: function toString() {\n      return this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n    },\n    getDistance: function getDistance() {\n      return this.dist;\n    },\n    compare: function compare(segmentIndex, dist) {\n      if (this.segmentIndex < segmentIndex) return -1;\n      if (this.segmentIndex > segmentIndex) return 1;\n      if (this.dist < dist) return -1;\n      if (this.dist > dist) return 1;\n      return 0;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return EdgeIntersection;\n    }\n  });\n\n  function EdgeIntersectionList() {\n    this._nodeMap = new TreeMap();\n    this.edge = null;\n    var edge = arguments[0];\n    this.edge = edge;\n  }\n  extend(EdgeIntersectionList.prototype, {\n    print: function print(out) {\n      out.println(\"Intersections:\");\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var ei = it.next();\n        ei.print(out);\n      }\n    },\n    iterator: function iterator() {\n      return this._nodeMap.values().iterator();\n    },\n    addSplitEdges: function addSplitEdges(edgeList) {\n      this.addEndpoints();\n      var it = this.iterator();\n      var eiPrev = it.next();\n\n      while (it.hasNext()) {\n        var ei = it.next();\n        var newEdge = this.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n      }\n    },\n    addEndpoints: function addEndpoints() {\n      var maxSegIndex = this.edge.pts.length - 1;\n      this.add(this.edge.pts[0], 0, 0.0);\n      this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n    },\n    createSplitEdge: function createSplitEdge(ei0, ei1) {\n      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n      var lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n      var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\n      if (!useIntPt1) {\n        npts--;\n      }\n\n      var pts = new Array(npts).fill(null);\n      var ipt = 0;\n      pts[ipt++] = new Coordinate(ei0.coord);\n\n      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n        pts[ipt++] = this.edge.pts[i];\n      }\n\n      if (useIntPt1) pts[ipt] = ei1.coord;\n      return new Edge(pts, new Label(this.edge._label));\n    },\n    add: function add(intPt, segmentIndex, dist) {\n      var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\n      var ei = this._nodeMap.get(eiNew);\n\n      if (ei !== null) {\n        return ei;\n      }\n\n      this._nodeMap.put(eiNew, eiNew);\n\n      return eiNew;\n    },\n    isIntersection: function isIntersection(pt) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var ei = it.next();\n        if (ei.coord.equals(pt)) return true;\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeIntersectionList;\n    }\n  });\n\n  function MonotoneChainIndexer() {}\n  extend(MonotoneChainIndexer.prototype, {\n    getChainStartIndices: function getChainStartIndices(pts) {\n      var start = 0;\n      var startIndexList = new ArrayList();\n      startIndexList.add(new Integer(start));\n\n      do {\n        var last = this.findChainEnd(pts, start);\n        startIndexList.add(new Integer(last));\n        start = last;\n      } while (start < pts.length - 1);\n\n      var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n      return startIndex;\n    },\n    findChainEnd: function findChainEnd(pts, start) {\n      var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n      var last = start + 1;\n\n      while (last < pts.length) {\n        var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n        if (quad !== chainQuad) break;\n        last++;\n      }\n\n      return last - 1;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChainIndexer;\n    }\n  });\n\n  MonotoneChainIndexer.toIntArray = function (list) {\n    var array = new Array(list.size()).fill(null);\n\n    for (var i = 0; i < array.length; i++) {\n      array[i] = list.get(i).intValue();\n    }\n\n    return array;\n  };\n\n  function MonotoneChainEdge() {\n    this.e = null;\n    this.pts = null;\n    this.startIndex = null;\n    var e = arguments[0];\n    this.e = e;\n    this.pts = e.getCoordinates();\n    var mcb = new MonotoneChainIndexer();\n    this.startIndex = mcb.getChainStartIndices(this.pts);\n  }\n  extend(MonotoneChainEdge.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    getMaxX: function getMaxX(chainIndex) {\n      var x1 = this.pts[this.startIndex[chainIndex]].x;\n      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n      return x1 > x2 ? x1 : x2;\n    },\n    getMinX: function getMinX(chainIndex) {\n      var x1 = this.pts[this.startIndex[chainIndex]].x;\n      var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n      return x1 < x2 ? x1 : x2;\n    },\n    computeIntersectsForChain: function computeIntersectsForChain() {\n      if (arguments.length === 4) {\n        var chainIndex0 = arguments[0],\n            mce = arguments[1],\n            chainIndex1 = arguments[2],\n            si = arguments[3];\n        this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n      } else if (arguments.length === 6) {\n        var start0 = arguments[0],\n            end0 = arguments[1],\n            _mce = arguments[2],\n            start1 = arguments[3],\n            end1 = arguments[4],\n            ei = arguments[5];\n\n        if (end0 - start0 === 1 && end1 - start1 === 1) {\n          ei.addIntersections(this.e, start0, _mce.e, start1);\n          return null;\n        }\n\n        if (!this.overlaps(start0, end0, _mce, start1, end1)) return null;\n        var mid0 = Math.trunc((start0 + end0) / 2);\n        var mid1 = Math.trunc((start1 + end1) / 2);\n\n        if (start0 < mid0) {\n          if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, _mce, start1, mid1, ei);\n          if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, _mce, mid1, end1, ei);\n        }\n\n        if (mid0 < end0) {\n          if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, _mce, start1, mid1, ei);\n          if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, _mce, mid1, end1, ei);\n        }\n      }\n    },\n    overlaps: function overlaps(start0, end0, mce, start1, end1) {\n      return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n    },\n    getStartIndexes: function getStartIndexes() {\n      return this.startIndex;\n    },\n    computeIntersects: function computeIntersects(mce, si) {\n      for (var i = 0; i < this.startIndex.length - 1; i++) {\n        for (var j = 0; j < mce.startIndex.length - 1; j++) {\n          this.computeIntersectsForChain(i, mce, j, si);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChainEdge;\n    }\n  });\n\n  function Depth() {\n    this._depth = Array(2).fill().map(function () {\n      return Array(3);\n    });\n\n    for (var i = 0; i < 2; i++) {\n      for (var j = 0; j < 3; j++) {\n        this._depth[i][j] = Depth.NULL_VALUE;\n      }\n    }\n  }\n  extend(Depth.prototype, {\n    getDepth: function getDepth(geomIndex, posIndex) {\n      return this._depth[geomIndex][posIndex];\n    },\n    setDepth: function setDepth(geomIndex, posIndex, depthValue) {\n      this._depth[geomIndex][posIndex] = depthValue;\n    },\n    isNull: function isNull() {\n      if (arguments.length === 0) {\n        for (var i = 0; i < 2; i++) {\n          for (var j = 0; j < 3; j++) {\n            if (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n          }\n        }\n\n        return true;\n      } else if (arguments.length === 1) {\n        var geomIndex = arguments[0];\n        return this._depth[geomIndex][1] === Depth.NULL_VALUE;\n      } else if (arguments.length === 2) {\n        var _geomIndex = arguments[0],\n            posIndex = arguments[1];\n        return this._depth[_geomIndex][posIndex] === Depth.NULL_VALUE;\n      }\n    },\n    normalize: function normalize() {\n      for (var i = 0; i < 2; i++) {\n        if (!this.isNull(i)) {\n          var minDepth = this._depth[i][1];\n          if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n          if (minDepth < 0) minDepth = 0;\n\n          for (var j = 1; j < 3; j++) {\n            var newValue = 0;\n            if (this._depth[i][j] > minDepth) newValue = 1;\n            this._depth[i][j] = newValue;\n          }\n        }\n      }\n    },\n    getDelta: function getDelta(geomIndex) {\n      return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n    },\n    getLocation: function getLocation(geomIndex, posIndex) {\n      if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n      return Location.INTERIOR;\n    },\n    toString: function toString() {\n      return \"A: \" + this._depth[0][1] + \",\" + this._depth[0][2] + \" B: \" + this._depth[1][1] + \",\" + this._depth[1][2];\n    },\n    add: function add() {\n      if (arguments.length === 1) {\n        var lbl = arguments[0];\n\n        for (var i = 0; i < 2; i++) {\n          for (var j = 1; j < 3; j++) {\n            var loc = lbl.getLocation(i, j);\n\n            if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n              if (this.isNull(i, j)) {\n                this._depth[i][j] = Depth.depthAtLocation(loc);\n              } else this._depth[i][j] += Depth.depthAtLocation(loc);\n            }\n          }\n        }\n      } else if (arguments.length === 3) {\n        var geomIndex = arguments[0],\n            posIndex = arguments[1],\n            location = arguments[2];\n        if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Depth;\n    }\n  });\n\n  Depth.depthAtLocation = function (location) {\n    if (location === Location.EXTERIOR) return 0;\n    if (location === Location.INTERIOR) return 1;\n    return Depth.NULL_VALUE;\n  };\n\n  Depth.NULL_VALUE = -1;\n\n  function GraphComponent() {\n    this._label = null;\n    this._isInResult = false;\n    this._isCovered = false;\n    this._isCoveredSet = false;\n    this._isVisited = false;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var label = arguments[0];\n      this._label = label;\n    }\n  }\n  extend(GraphComponent.prototype, {\n    setVisited: function setVisited(isVisited) {\n      this._isVisited = isVisited;\n    },\n    setInResult: function setInResult(isInResult) {\n      this._isInResult = isInResult;\n    },\n    isCovered: function isCovered() {\n      return this._isCovered;\n    },\n    isCoveredSet: function isCoveredSet() {\n      return this._isCoveredSet;\n    },\n    setLabel: function setLabel(label) {\n      this._label = label;\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    setCovered: function setCovered(isCovered) {\n      this._isCovered = isCovered;\n      this._isCoveredSet = true;\n    },\n    updateIM: function updateIM(im) {\n      Assert.isTrue(this._label.getGeometryCount() >= 2, \"found partial label\");\n      this.computeIM(im);\n    },\n    isInResult: function isInResult() {\n      return this._isInResult;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GraphComponent;\n    }\n  });\n\n  function Edge() {\n    GraphComponent.apply(this);\n    this.pts = null;\n    this._env = null;\n    this.eiList = new EdgeIntersectionList(this);\n    this._name = null;\n    this._mce = null;\n    this._isIsolated = true;\n    this._depth = new Depth();\n    this._depthDelta = 0;\n\n    if (arguments.length === 1) {\n      var pts = arguments[0];\n      Edge.call(this, pts, null);\n    } else if (arguments.length === 2) {\n      var _pts = arguments[0],\n          label = arguments[1];\n      this.pts = _pts;\n      this._label = label;\n    }\n  }\n  inherits(Edge, GraphComponent);\n  extend(Edge.prototype, {\n    getDepth: function getDepth() {\n      return this._depth;\n    },\n    getCollapsedEdge: function getCollapsedEdge() {\n      var newPts = new Array(2).fill(null);\n      newPts[0] = this.pts[0];\n      newPts[1] = this.pts[1];\n      var newe = new Edge(newPts, Label.toLineLabel(this._label));\n      return newe;\n    },\n    isIsolated: function isIsolated() {\n      return this._isIsolated;\n    },\n    getCoordinates: function getCoordinates() {\n      return this.pts;\n    },\n    setIsolated: function setIsolated(isIsolated) {\n      this._isIsolated = isIsolated;\n    },\n    setName: function setName(name) {\n      this._name = name;\n    },\n    equals: function equals(o) {\n      if (!(o instanceof Edge)) return false;\n      var e = o;\n      if (this.pts.length !== e.pts.length) return false;\n      var isEqualForward = true;\n      var isEqualReverse = true;\n      var iRev = this.pts.length;\n\n      for (var i = 0; i < this.pts.length; i++) {\n        if (!this.pts[i].equals2D(e.pts[i])) {\n          isEqualForward = false;\n        }\n\n        if (!this.pts[i].equals2D(e.pts[--iRev])) {\n          isEqualReverse = false;\n        }\n\n        if (!isEqualForward && !isEqualReverse) return false;\n      }\n\n      return true;\n    },\n    getCoordinate: function getCoordinate() {\n      if (arguments.length === 0) {\n        if (this.pts.length > 0) return this.pts[0];\n        return null;\n      } else if (arguments.length === 1) {\n        var i = arguments[0];\n        return this.pts[i];\n      }\n    },\n    print: function print(out) {\n      out.print(\"edge \" + this._name + \": \");\n      out.print(\"LINESTRING (\");\n\n      for (var i = 0; i < this.pts.length; i++) {\n        if (i > 0) out.print(\",\");\n        out.print(this.pts[i].x + \" \" + this.pts[i].y);\n      }\n\n      out.print(\")  \" + this._label + \" \" + this._depthDelta);\n    },\n    computeIM: function computeIM(im) {\n      Edge.updateIM(this._label, im);\n    },\n    isCollapsed: function isCollapsed() {\n      if (!this._label.isArea()) return false;\n      if (this.pts.length !== 3) return false;\n      if (this.pts[0].equals(this.pts[2])) return true;\n      return false;\n    },\n    isClosed: function isClosed() {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    },\n    getMaximumSegmentIndex: function getMaximumSegmentIndex() {\n      return this.pts.length - 1;\n    },\n    getDepthDelta: function getDepthDelta() {\n      return this._depthDelta;\n    },\n    getNumPoints: function getNumPoints() {\n      return this.pts.length;\n    },\n    printReverse: function printReverse(out) {\n      out.print(\"edge \" + this._name + \": \");\n\n      for (var i = this.pts.length - 1; i >= 0; i--) {\n        out.print(this.pts[i] + \" \");\n      }\n\n      out.println(\"\");\n    },\n    getMonotoneChainEdge: function getMonotoneChainEdge() {\n      if (this._mce === null) this._mce = new MonotoneChainEdge(this);\n      return this._mce;\n    },\n    getEnvelope: function getEnvelope() {\n      if (this._env === null) {\n        this._env = new Envelope();\n\n        for (var i = 0; i < this.pts.length; i++) {\n          this._env.expandToInclude(this.pts[i]);\n        }\n      }\n\n      return this._env;\n    },\n    addIntersection: function addIntersection(li, segmentIndex, geomIndex, intIndex) {\n      var intPt = new Coordinate(li.getIntersection(intIndex));\n      var normalizedSegmentIndex = segmentIndex;\n      var dist = li.getEdgeDistance(geomIndex, intIndex);\n      var nextSegIndex = normalizedSegmentIndex + 1;\n\n      if (nextSegIndex < this.pts.length) {\n        var nextPt = this.pts[nextSegIndex];\n\n        if (intPt.equals2D(nextPt)) {\n          normalizedSegmentIndex = nextSegIndex;\n          dist = 0.0;\n        }\n      }\n\n      var ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n    },\n    toString: function toString() {\n      var builder = new StringBuilder();\n      builder.append(\"edge \" + this._name + \": \");\n      builder.append(\"LINESTRING (\");\n\n      for (var i = 0; i < this.pts.length; i++) {\n        if (i > 0) builder.append(\",\");\n        builder.append(this.pts[i].x + \" \" + this.pts[i].y);\n      }\n\n      builder.append(\")  \" + this._label + \" \" + this._depthDelta);\n      return builder.toString();\n    },\n    isPointwiseEqual: function isPointwiseEqual(e) {\n      if (this.pts.length !== e.pts.length) return false;\n\n      for (var i = 0; i < this.pts.length; i++) {\n        if (!this.pts[i].equals2D(e.pts[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    setDepthDelta: function setDepthDelta(depthDelta) {\n      this._depthDelta = depthDelta;\n    },\n    getEdgeIntersectionList: function getEdgeIntersectionList() {\n      return this.eiList;\n    },\n    addIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n      for (var i = 0; i < li.getIntersectionNum(); i++) {\n        this.addIntersection(li, segmentIndex, geomIndex, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Edge;\n    }\n  });\n\n  Edge.updateIM = function () {\n    if (arguments.length === 2 && arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label) {\n      var label = arguments[0],\n          im = arguments[1];\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n      }\n    } else return GraphComponent.prototype.updateIM.apply(this, arguments);\n  };\n\n  function Node$1() {\n    GraphComponent.apply(this);\n    this._coord = null;\n    this._edges = null;\n    var coord = arguments[0],\n        edges = arguments[1];\n    this._coord = coord;\n    this._edges = edges;\n    this._label = new Label(0, Location.NONE);\n  }\n  inherits(Node$1, GraphComponent);\n  extend(Node$1.prototype, {\n    isIncidentEdgeInResult: function isIncidentEdgeInResult() {\n      for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n        var de = it.next();\n        if (de.getEdge().isInResult()) return true;\n      }\n\n      return false;\n    },\n    isIsolated: function isIsolated() {\n      return this._label.getGeometryCount() === 1;\n    },\n    getCoordinate: function getCoordinate() {\n      return this._coord;\n    },\n    print: function print(out) {\n      out.println(\"node \" + this._coord + \" lbl: \" + this._label);\n    },\n    computeIM: function computeIM(im) {},\n    computeMergedLocation: function computeMergedLocation(label2, eltIndex) {\n      var loc = Location.NONE;\n      loc = this._label.getLocation(eltIndex);\n\n      if (!label2.isNull(eltIndex)) {\n        var nLoc = label2.getLocation(eltIndex);\n        if (loc !== Location.BOUNDARY) loc = nLoc;\n      }\n\n      return loc;\n    },\n    setLabel: function setLabel() {\n      if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {\n        var argIndex = arguments[0],\n            onLocation = arguments[1];\n\n        if (this._label === null) {\n          this._label = new Label(argIndex, onLocation);\n        } else this._label.setLocation(argIndex, onLocation);\n      } else return GraphComponent.prototype.setLabel.apply(this, arguments);\n    },\n    getEdges: function getEdges() {\n      return this._edges;\n    },\n    mergeLabel: function mergeLabel() {\n      if (arguments[0] instanceof Node$1) {\n        var n = arguments[0];\n        this.mergeLabel(n._label);\n      } else if (arguments[0] instanceof Label) {\n        var label2 = arguments[0];\n\n        for (var i = 0; i < 2; i++) {\n          var loc = this.computeMergedLocation(label2, i);\n\n          var thisLoc = this._label.getLocation(i);\n\n          if (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n        }\n      }\n    },\n    add: function add(e) {\n      this._edges.insert(e);\n\n      e.setNode(this);\n    },\n    setLabelBoundary: function setLabelBoundary(argIndex) {\n      if (this._label === null) return null;\n      var loc = Location.NONE;\n      if (this._label !== null) loc = this._label.getLocation(argIndex);\n      var newLoc = null;\n\n      switch (loc) {\n        case Location.BOUNDARY:\n          newLoc = Location.INTERIOR;\n          break;\n\n        case Location.INTERIOR:\n          newLoc = Location.BOUNDARY;\n          break;\n\n        default:\n          newLoc = Location.BOUNDARY;\n          break;\n      }\n\n      this._label.setLocation(argIndex, newLoc);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Node$1;\n    }\n  });\n\n  function NodeMap() {\n    this.nodeMap = new TreeMap();\n    this.nodeFact = null;\n    var nodeFact = arguments[0];\n    this.nodeFact = nodeFact;\n  }\n  extend(NodeMap.prototype, {\n    find: function find(coord) {\n      return this.nodeMap.get(coord);\n    },\n    addNode: function addNode() {\n      if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        var node = this.nodeMap.get(coord);\n\n        if (node === null) {\n          node = this.nodeFact.createNode(coord);\n          this.nodeMap.put(coord, node);\n        }\n\n        return node;\n      } else if (arguments[0] instanceof Node$1) {\n        var n = arguments[0];\n        var node = this.nodeMap.get(n.getCoordinate());\n\n        if (node === null) {\n          this.nodeMap.put(n.getCoordinate(), n);\n          return n;\n        }\n\n        node.mergeLabel(n);\n        return node;\n      }\n    },\n    print: function print(out) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var n = it.next();\n        n.print(out);\n      }\n    },\n    iterator: function iterator() {\n      return this.nodeMap.values().iterator();\n    },\n    values: function values() {\n      return this.nodeMap.values();\n    },\n    getBoundaryNodes: function getBoundaryNodes(geomIndex) {\n      var bdyNodes = new ArrayList();\n\n      for (var i = this.iterator(); i.hasNext();) {\n        var node = i.next();\n        if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n      }\n\n      return bdyNodes;\n    },\n    add: function add(e) {\n      var p = e.getCoordinate();\n      var n = this.addNode(p);\n      n.add(e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NodeMap;\n    }\n  });\n\n  function EdgeEnd() {\n    this._edge = null;\n    this._label = null;\n    this._node = null;\n    this._p0 = null;\n    this._p1 = null;\n    this._dx = null;\n    this._dy = null;\n    this._quadrant = null;\n\n    if (arguments.length === 1) {\n      var edge = arguments[0];\n      this._edge = edge;\n    } else if (arguments.length === 3) {\n      var _edge = arguments[0],\n          p0 = arguments[1],\n          p1 = arguments[2];\n      EdgeEnd.call(this, _edge, p0, p1, null);\n    } else if (arguments.length === 4) {\n      var _edge2 = arguments[0],\n          _p = arguments[1],\n          _p2 = arguments[2],\n          label = arguments[3];\n      EdgeEnd.call(this, _edge2);\n      this.init(_p, _p2);\n      this._label = label;\n    }\n  }\n  extend(EdgeEnd.prototype, {\n    compareDirection: function compareDirection(e) {\n      if (this._dx === e._dx && this._dy === e._dy) return 0;\n      if (this._quadrant > e._quadrant) return 1;\n      if (this._quadrant < e._quadrant) return -1;\n      return Orientation.index(e._p0, e._p1, this._p1);\n    },\n    getDy: function getDy() {\n      return this._dy;\n    },\n    getCoordinate: function getCoordinate() {\n      return this._p0;\n    },\n    setNode: function setNode(node) {\n      this._node = node;\n    },\n    print: function print(out) {\n      var angle = Math.atan2(this._dy, this._dx);\n      var className = this.getClass().getName();\n      var lastDotPos = className.lastIndexOf('.');\n      var name = className.substring(lastDotPos + 1);\n      out.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label);\n    },\n    compareTo: function compareTo(obj) {\n      var e = obj;\n      return this.compareDirection(e);\n    },\n    getDirectedCoordinate: function getDirectedCoordinate() {\n      return this._p1;\n    },\n    getDx: function getDx() {\n      return this._dx;\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    getEdge: function getEdge() {\n      return this._edge;\n    },\n    getQuadrant: function getQuadrant() {\n      return this._quadrant;\n    },\n    getNode: function getNode() {\n      return this._node;\n    },\n    toString: function toString() {\n      var angle = Math.atan2(this._dy, this._dx);\n      var className = this.getClass().getName();\n      var lastDotPos = className.lastIndexOf('.');\n      var name = className.substring(lastDotPos + 1);\n      return \"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + angle + \"   \" + this._label;\n    },\n    computeLabel: function computeLabel(boundaryNodeRule) {},\n    init: function init(p0, p1) {\n      this._p0 = p0;\n      this._p1 = p1;\n      this._dx = p1.x - p0.x;\n      this._dy = p1.y - p0.y;\n      this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n      Assert.isTrue(!(this._dx === 0 && this._dy === 0), \"EdgeEnd with identical endpoints found\");\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return EdgeEnd;\n    }\n  });\n\n  function TopologyException() {\n    this.pt = null;\n\n    if (arguments.length === 1) {\n      var msg = arguments[0];\n      RuntimeException.call(this, msg);\n    } else if (arguments.length === 2) {\n      var _msg = arguments[0],\n          pt = arguments[1];\n      RuntimeException.call(this, TopologyException.msgWithCoord(_msg, pt));\n      this.name = 'TopologyException';\n      this.pt = new Coordinate(pt);\n    }\n  }\n  inherits(TopologyException, RuntimeException);\n  extend(TopologyException.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TopologyException;\n    }\n  });\n\n  TopologyException.msgWithCoord = function (msg, pt) {\n    if (pt !== null) return msg + \" [ \" + pt + \" ]\";\n    return msg;\n  };\n\n  function DirectedEdge() {\n    this._isForward = null;\n    this._isInResult = false;\n    this._isVisited = false;\n    this._sym = null;\n    this._next = null;\n    this._nextMin = null;\n    this._edgeRing = null;\n    this._minEdgeRing = null;\n    this._depth = [0, -999, -999];\n    var edge = arguments[0],\n        isForward = arguments[1];\n    EdgeEnd.call(this, edge);\n    this._isForward = isForward;\n\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n    } else {\n      var n = edge.getNumPoints() - 1;\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n    }\n\n    this.computeDirectedLabel();\n  }\n  inherits(DirectedEdge, EdgeEnd);\n  extend(DirectedEdge.prototype, {\n    getNextMin: function getNextMin() {\n      return this._nextMin;\n    },\n    getDepth: function getDepth(position) {\n      return this._depth[position];\n    },\n    setVisited: function setVisited(isVisited) {\n      this._isVisited = isVisited;\n    },\n    computeDirectedLabel: function computeDirectedLabel() {\n      this._label = new Label(this._edge.getLabel());\n      if (!this._isForward) this._label.flip();\n    },\n    getNext: function getNext() {\n      return this._next;\n    },\n    setDepth: function setDepth(position, depthVal) {\n      if (this._depth[position] !== -999) {\n        if (this._depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n      }\n\n      this._depth[position] = depthVal;\n    },\n    isInteriorAreaEdge: function isInteriorAreaEdge() {\n      var isInteriorAreaEdge = true;\n\n      for (var i = 0; i < 2; i++) {\n        if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n          isInteriorAreaEdge = false;\n        }\n      }\n\n      return isInteriorAreaEdge;\n    },\n    setNextMin: function setNextMin(nextMin) {\n      this._nextMin = nextMin;\n    },\n    print: function print(out) {\n      EdgeEnd.prototype.print.call(this, out);\n      out.print(\" \" + this._depth[Position.LEFT] + \"/\" + this._depth[Position.RIGHT]);\n      out.print(\" (\" + this.getDepthDelta() + \")\");\n      if (this._isInResult) out.print(\" inResult\");\n    },\n    setMinEdgeRing: function setMinEdgeRing(minEdgeRing) {\n      this._minEdgeRing = minEdgeRing;\n    },\n    isLineEdge: function isLineEdge() {\n      var isLine = this._label.isLine(0) || this._label.isLine(1);\n\n      var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\n      var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\n      return isLine && isExteriorIfArea0 && isExteriorIfArea1;\n    },\n    setEdgeRing: function setEdgeRing(edgeRing) {\n      this._edgeRing = edgeRing;\n    },\n    getMinEdgeRing: function getMinEdgeRing() {\n      return this._minEdgeRing;\n    },\n    getDepthDelta: function getDepthDelta() {\n      var depthDelta = this._edge.getDepthDelta();\n\n      if (!this._isForward) depthDelta = -depthDelta;\n      return depthDelta;\n    },\n    setInResult: function setInResult(isInResult) {\n      this._isInResult = isInResult;\n    },\n    getSym: function getSym() {\n      return this._sym;\n    },\n    isForward: function isForward() {\n      return this._isForward;\n    },\n    getEdge: function getEdge() {\n      return this._edge;\n    },\n    printEdge: function printEdge(out) {\n      this.print(out);\n      out.print(\" \");\n      if (this._isForward) this._edge.print(out);else this._edge.printReverse(out);\n    },\n    setSym: function setSym(de) {\n      this._sym = de;\n    },\n    setVisitedEdge: function setVisitedEdge(isVisited) {\n      this.setVisited(isVisited);\n\n      this._sym.setVisited(isVisited);\n    },\n    setEdgeDepths: function setEdgeDepths(position, depth) {\n      var depthDelta = this.getEdge().getDepthDelta();\n      if (!this._isForward) depthDelta = -depthDelta;\n      var directionFactor = 1;\n      if (position === Position.LEFT) directionFactor = -1;\n      var oppositePos = Position.opposite(position);\n      var delta = depthDelta * directionFactor;\n      var oppositeDepth = depth + delta;\n      this.setDepth(position, depth);\n      this.setDepth(oppositePos, oppositeDepth);\n    },\n    getEdgeRing: function getEdgeRing() {\n      return this._edgeRing;\n    },\n    isInResult: function isInResult() {\n      return this._isInResult;\n    },\n    setNext: function setNext(next) {\n      this._next = next;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DirectedEdge;\n    }\n  });\n\n  DirectedEdge.depthFactor = function (currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n    return 0;\n  };\n\n  function NodeFactory() {}\n  extend(NodeFactory.prototype, {\n    createNode: function createNode(coord) {\n      return new Node$1(coord, null);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NodeFactory;\n    }\n  });\n\n  function PlanarGraph() {\n    this._edges = new ArrayList();\n    this._nodes = null;\n    this._edgeEndList = new ArrayList();\n\n    if (arguments.length === 0) {\n      this._nodes = new NodeMap(new NodeFactory());\n    } else if (arguments.length === 1) {\n      var nodeFact = arguments[0];\n      this._nodes = new NodeMap(nodeFact);\n    }\n  }\n  extend(PlanarGraph.prototype, {\n    printEdges: function printEdges(out) {\n      out.println(\"Edges:\");\n\n      for (var i = 0; i < this._edges.size(); i++) {\n        out.println(\"edge \" + i + \":\");\n\n        var e = this._edges.get(i);\n\n        e.print(out);\n        e.eiList.print(out);\n      }\n    },\n    find: function find(coord) {\n      return this._nodes.find(coord);\n    },\n    addNode: function addNode() {\n      if (arguments[0] instanceof Node$1) {\n        var node = arguments[0];\n        return this._nodes.addNode(node);\n      } else if (arguments[0] instanceof Coordinate) {\n        var coord = arguments[0];\n        return this._nodes.addNode(coord);\n      }\n    },\n    getNodeIterator: function getNodeIterator() {\n      return this._nodes.iterator();\n    },\n    linkResultDirectedEdges: function linkResultDirectedEdges() {\n      for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        node.getEdges().linkResultDirectedEdges();\n      }\n    },\n    debugPrintln: function debugPrintln(o) {\n      System.out.println(o);\n    },\n    isBoundaryNode: function isBoundaryNode(geomIndex, coord) {\n      var node = this._nodes.find(coord);\n\n      if (node === null) return false;\n      var label = node.getLabel();\n      if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n      return false;\n    },\n    linkAllDirectedEdges: function linkAllDirectedEdges() {\n      for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        node.getEdges().linkAllDirectedEdges();\n      }\n    },\n    matchInSameDirection: function matchInSameDirection(p0, p1, ep0, ep1) {\n      if (!p0.equals(ep0)) return false;\n      if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n      return false;\n    },\n    getEdgeEnds: function getEdgeEnds() {\n      return this._edgeEndList;\n    },\n    debugPrint: function debugPrint(o) {\n      System.out.print(o);\n    },\n    getEdgeIterator: function getEdgeIterator() {\n      return this._edges.iterator();\n    },\n    findEdgeInSameDirection: function findEdgeInSameDirection(p0, p1) {\n      for (var i = 0; i < this._edges.size(); i++) {\n        var e = this._edges.get(i);\n\n        var eCoord = e.getCoordinates();\n        if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n        if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n      }\n\n      return null;\n    },\n    insertEdge: function insertEdge(e) {\n      this._edges.add(e);\n    },\n    findEdgeEnd: function findEdgeEnd(e) {\n      for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n        var ee = i.next();\n        if (ee.getEdge() === e) return ee;\n      }\n\n      return null;\n    },\n    addEdges: function addEdges(edgesToAdd) {\n      for (var it = edgesToAdd.iterator(); it.hasNext();) {\n        var e = it.next();\n\n        this._edges.add(e);\n\n        var de1 = new DirectedEdge(e, true);\n        var de2 = new DirectedEdge(e, false);\n        de1.setSym(de2);\n        de2.setSym(de1);\n        this.add(de1);\n        this.add(de2);\n      }\n    },\n    add: function add(e) {\n      this._nodes.add(e);\n\n      this._edgeEndList.add(e);\n    },\n    getNodes: function getNodes() {\n      return this._nodes.values();\n    },\n    findEdge: function findEdge(p0, p1) {\n      for (var i = 0; i < this._edges.size(); i++) {\n        var e = this._edges.get(i);\n\n        var eCoord = e.getCoordinates();\n        if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n      }\n\n      return null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PlanarGraph;\n    }\n  });\n\n  PlanarGraph.linkResultDirectedEdges = function (nodes) {\n    for (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().linkResultDirectedEdges();\n    }\n  };\n\n  function GeometryGraph() {\n    PlanarGraph.apply(this);\n    this._parentGeom = null;\n    this._lineEdgeMap = new HashMap();\n    this._boundaryNodeRule = null;\n    this._useBoundaryDeterminationRule = true;\n    this._argIndex = null;\n    this._boundaryNodes = null;\n    this._hasTooFewPoints = false;\n    this._invalidPoint = null;\n    this._areaPtLocator = null;\n    this._ptLocator = new PointLocator();\n\n    if (arguments.length === 2) {\n      var argIndex = arguments[0],\n          parentGeom = arguments[1];\n      GeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n    } else if (arguments.length === 3) {\n      var _argIndex = arguments[0],\n          _parentGeom = arguments[1],\n          boundaryNodeRule = arguments[2];\n      this._argIndex = _argIndex;\n      this._parentGeom = _parentGeom;\n      this._boundaryNodeRule = boundaryNodeRule;\n\n      if (_parentGeom !== null) {\n        this.add(_parentGeom);\n      }\n    }\n  }\n  inherits(GeometryGraph, PlanarGraph);\n  extend(GeometryGraph.prototype, {\n    insertBoundaryPoint: function insertBoundaryPoint(argIndex, coord) {\n      var n = this._nodes.addNode(coord);\n\n      var lbl = n.getLabel();\n      var boundaryCount = 1;\n      var loc = Location.NONE;\n      loc = lbl.getLocation(argIndex, Position.ON);\n      if (loc === Location.BOUNDARY) boundaryCount++;\n      var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n      lbl.setLocation(argIndex, newLoc);\n    },\n    computeSelfNodes: function computeSelfNodes() {\n      if (arguments.length === 2) {\n        var li = arguments[0],\n            computeRingSelfNodes = arguments[1];\n        return this.computeSelfNodes(li, computeRingSelfNodes, false);\n      } else if (arguments.length === 3) {\n        var _li = arguments[0],\n            _computeRingSelfNodes = arguments[1],\n            isDoneIfProperInt = arguments[2];\n        var si = new SegmentIntersector(_li, true, false);\n        si.setIsDoneIfProperInt(isDoneIfProperInt);\n        var esi = this.createEdgeSetIntersector();\n        var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n        var computeAllSegments = _computeRingSelfNodes || !isRings;\n        esi.computeIntersections(this._edges, si, computeAllSegments);\n        this.addSelfIntersectionNodes(this._argIndex);\n        return si;\n      }\n    },\n    computeSplitEdges: function computeSplitEdges(edgelist) {\n      for (var i = this._edges.iterator(); i.hasNext();) {\n        var e = i.next();\n        e.eiList.addSplitEdges(edgelist);\n      }\n    },\n    computeEdgeIntersections: function computeEdgeIntersections(g, li, includeProper) {\n      var si = new SegmentIntersector(li, includeProper, true);\n      si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n      var esi = this.createEdgeSetIntersector();\n      esi.computeIntersections(this._edges, g._edges, si);\n      return si;\n    },\n    getGeometry: function getGeometry() {\n      return this._parentGeom;\n    },\n    getBoundaryNodeRule: function getBoundaryNodeRule() {\n      return this._boundaryNodeRule;\n    },\n    hasTooFewPoints: function hasTooFewPoints() {\n      return this._hasTooFewPoints;\n    },\n    addPoint: function addPoint() {\n      if (arguments[0] instanceof Point) {\n        var p = arguments[0];\n        var coord = p.getCoordinate();\n        this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n      } else if (arguments[0] instanceof Coordinate) {\n        var pt = arguments[0];\n        this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n      }\n    },\n    addPolygon: function addPolygon(p) {\n      this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\n      for (var i = 0; i < p.getNumInteriorRing(); i++) {\n        var hole = p.getInteriorRingN(i);\n        this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n      }\n    },\n    addEdge: function addEdge(e) {\n      this.insertEdge(e);\n      var coord = e.getCoordinates();\n      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n      this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n    },\n    addLineString: function addLineString(line) {\n      var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\n      if (coord.length < 2) {\n        this._hasTooFewPoints = true;\n        this._invalidPoint = coord[0];\n        return null;\n      }\n\n      var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\n      this._lineEdgeMap.put(line, e);\n\n      this.insertEdge(e);\n      Assert.isTrue(coord.length >= 2, \"found LineString with single point\");\n      this.insertBoundaryPoint(this._argIndex, coord[0]);\n      this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n    },\n    getInvalidPoint: function getInvalidPoint() {\n      return this._invalidPoint;\n    },\n    getBoundaryPoints: function getBoundaryPoints() {\n      var coll = this.getBoundaryNodes();\n      var pts = new Array(coll.size()).fill(null);\n      var i = 0;\n\n      for (var it = coll.iterator(); it.hasNext();) {\n        var node = it.next();\n        pts[i++] = node.getCoordinate().copy();\n      }\n\n      return pts;\n    },\n    getBoundaryNodes: function getBoundaryNodes() {\n      if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n      return this._boundaryNodes;\n    },\n    addSelfIntersectionNode: function addSelfIntersectionNode(argIndex, coord, loc) {\n      if (this.isBoundaryNode(argIndex, coord)) return null;\n      if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);\n    },\n    addPolygonRing: function addPolygonRing(lr, cwLeft, cwRight) {\n      if (lr.isEmpty()) return null;\n      var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\n      if (coord.length < 4) {\n        this._hasTooFewPoints = true;\n        this._invalidPoint = coord[0];\n        return null;\n      }\n\n      var left = cwLeft;\n      var right = cwRight;\n\n      if (Orientation.isCCW(coord)) {\n        left = cwRight;\n        right = cwLeft;\n      }\n\n      var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\n      this._lineEdgeMap.put(lr, e);\n\n      this.insertEdge(e);\n      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    },\n    insertPoint: function insertPoint(argIndex, coord, onLocation) {\n      var n = this._nodes.addNode(coord);\n\n      var lbl = n.getLabel();\n\n      if (lbl === null) {\n        n._label = new Label(argIndex, onLocation);\n      } else lbl.setLocation(argIndex, onLocation);\n    },\n    createEdgeSetIntersector: function createEdgeSetIntersector() {\n      return new SimpleMCSweepLineIntersector();\n    },\n    addSelfIntersectionNodes: function addSelfIntersectionNodes(argIndex) {\n      for (var i = this._edges.iterator(); i.hasNext();) {\n        var e = i.next();\n        var eLoc = e.getLabel().getLocation(argIndex);\n\n        for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n          var ei = eiIt.next();\n          this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n        }\n      }\n    },\n    add: function add() {\n      if (arguments.length === 1 && arguments[0] instanceof Geometry) {\n        var g = arguments[0];\n        if (g.isEmpty()) return null;\n        if (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n        if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n      } else return PlanarGraph.prototype.add.apply(this, arguments);\n    },\n    addCollection: function addCollection(gc) {\n      for (var i = 0; i < gc.getNumGeometries(); i++) {\n        var g = gc.getGeometryN(i);\n        this.add(g);\n      }\n    },\n    locate: function locate(pt) {\n      if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n        if (this._areaPtLocator === null) {\n          this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n        }\n\n        return this._areaPtLocator.locate(pt);\n      }\n\n      return this._ptLocator.locate(pt, this._parentGeom);\n    },\n    findEdge: function findEdge() {\n      if (arguments.length === 1 && arguments[0] instanceof LineString) {\n        var line = arguments[0];\n        return this._lineEdgeMap.get(line);\n      } else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryGraph;\n    }\n  });\n\n  GeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n  };\n\n\n\n  var geomgraph = /*#__PURE__*/Object.freeze({\n    GeometryGraph: GeometryGraph\n  });\n\n  function KdNodeVisitor() {}\n  extend(KdNodeVisitor.prototype, {\n    visit: function visit(node) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return KdNodeVisitor;\n    }\n  });\n\n  function KdNode() {\n    this._p = null;\n    this._data = null;\n    this._left = null;\n    this._right = null;\n    this._count = null;\n\n    if (arguments.length === 2) {\n      var p = arguments[0],\n          data = arguments[1];\n      this._p = new Coordinate(p);\n      this._left = null;\n      this._right = null;\n      this._count = 1;\n      this._data = data;\n    } else if (arguments.length === 3) {\n      var _x = arguments[0],\n          _y = arguments[1],\n          _data = arguments[2];\n      this._p = new Coordinate(_x, _y);\n      this._left = null;\n      this._right = null;\n      this._count = 1;\n      this._data = _data;\n    }\n  }\n  extend(KdNode.prototype, {\n    isRepeated: function isRepeated() {\n      return this._count > 1;\n    },\n    getRight: function getRight() {\n      return this._right;\n    },\n    getCoordinate: function getCoordinate() {\n      return this._p;\n    },\n    setLeft: function setLeft(_left) {\n      this._left = _left;\n    },\n    getX: function getX() {\n      return this._p.x;\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    getCount: function getCount() {\n      return this._count;\n    },\n    getLeft: function getLeft() {\n      return this._left;\n    },\n    getY: function getY() {\n      return this._p.y;\n    },\n    increment: function increment() {\n      this._count = this._count + 1;\n    },\n    setRight: function setRight(_right) {\n      this._right = _right;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return KdNode;\n    }\n  });\n\n  function KdTree() {\n    this._root = null;\n    this._numberOfNodes = null;\n    this._tolerance = null;\n\n    if (arguments.length === 0) {\n      KdTree.call(this, 0.0);\n    } else if (arguments.length === 1) {\n      var tolerance = arguments[0];\n      this._tolerance = tolerance;\n    }\n  }\n  extend(KdTree.prototype, {\n    insert: function insert() {\n      if (arguments.length === 1) {\n        var p = arguments[0];\n        return this.insert(p, null);\n      } else if (arguments.length === 2) {\n        var _p = arguments[0],\n            data = arguments[1];\n\n        if (this._root === null) {\n          this._root = new KdNode(_p, data);\n          return this._root;\n        }\n\n        if (this._tolerance > 0) {\n          var matchNode = this.findBestMatchNode(_p);\n\n          if (matchNode !== null) {\n            matchNode.increment();\n            return matchNode;\n          }\n        }\n\n        return this.insertExact(_p, data);\n      }\n    },\n    query: function query() {\n      if (arguments.length === 1) {\n        var queryEnv = arguments[0];\n        var result = new ArrayList();\n        this.query(queryEnv, result);\n        return result;\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n          var _queryEnv = arguments[0],\n              _result = arguments[1];\n          this.queryNode(this._root, _queryEnv, true, {\n            interfaces_: function interfaces_() {\n              return [KdNodeVisitor];\n            },\n            visit: function visit(node) {\n              _result.add(node);\n            }\n          });\n        } else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n          var _queryEnv2 = arguments[0],\n              visitor = arguments[1];\n          this.queryNode(this._root, _queryEnv2, true, visitor);\n        }\n      }\n    },\n    queryNode: function queryNode(currentNode, queryEnv, odd, visitor) {\n      if (currentNode === null) return null;\n      var min = null;\n      var max = null;\n      var discriminant = null;\n\n      if (odd) {\n        min = queryEnv.getMinX();\n        max = queryEnv.getMaxX();\n        discriminant = currentNode.getX();\n      } else {\n        min = queryEnv.getMinY();\n        max = queryEnv.getMaxY();\n        discriminant = currentNode.getY();\n      }\n\n      var searchLeft = min < discriminant;\n      var searchRight = discriminant <= max;\n\n      if (searchLeft) {\n        this.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n      }\n\n      if (queryEnv.contains(currentNode.getCoordinate())) {\n        visitor.visit(currentNode);\n      }\n\n      if (searchRight) {\n        this.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n      }\n    },\n    findBestMatchNode: function findBestMatchNode(p) {\n      var visitor = new BestMatchVisitor(p, this._tolerance);\n      this.query(visitor.queryEnvelope(), visitor);\n      return visitor.getNode();\n    },\n    isEmpty: function isEmpty() {\n      if (this._root === null) return true;\n      return false;\n    },\n    insertExact: function insertExact(p, data) {\n      var currentNode = this._root;\n      var leafNode = this._root;\n      var isOddLevel = true;\n      var isLessThan = true;\n\n      while (currentNode !== null) {\n        if (currentNode !== null) {\n          var isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;\n\n          if (isInTolerance) {\n            currentNode.increment();\n            return currentNode;\n          }\n        }\n\n        if (isOddLevel) {\n          isLessThan = p.x < currentNode.getX();\n        } else {\n          isLessThan = p.y < currentNode.getY();\n        }\n\n        leafNode = currentNode;\n\n        if (isLessThan) {\n          currentNode = currentNode.getLeft();\n        } else {\n          currentNode = currentNode.getRight();\n        }\n\n        isOddLevel = !isOddLevel;\n      }\n\n      this._numberOfNodes = this._numberOfNodes + 1;\n      var node = new KdNode(p, data);\n\n      if (isLessThan) {\n        leafNode.setLeft(node);\n      } else {\n        leafNode.setRight(node);\n      }\n\n      return node;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return KdTree;\n    }\n  });\n\n  KdTree.toCoordinates = function () {\n    if (arguments.length === 1) {\n      var kdnodes = arguments[0];\n      return KdTree.toCoordinates(kdnodes, false);\n    } else if (arguments.length === 2) {\n      var _kdnodes = arguments[0],\n          includeRepeated = arguments[1];\n      var coord = new CoordinateList();\n\n      for (var it = _kdnodes.iterator(); it.hasNext();) {\n        var node = it.next();\n        var count = includeRepeated ? node.getCount() : 1;\n\n        for (var i = 0; i < count; i++) {\n          coord.add(node.getCoordinate(), true);\n        }\n      }\n\n      return coord.toCoordinateArray();\n    }\n  };\n\n  function BestMatchVisitor() {\n    this._tolerance = null;\n    this._matchNode = null;\n    this._matchDist = 0.0;\n    this._p = null;\n    var p = arguments[0],\n        tolerance = arguments[1];\n    this._p = p;\n    this._tolerance = tolerance;\n  }\n\n  extend(BestMatchVisitor.prototype, {\n    visit: function visit(node) {\n      var dist = this._p.distance(node.getCoordinate());\n\n      var isInTolerance = dist <= this._tolerance;\n      if (!isInTolerance) return null;\n      var update = false;\n      if (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;\n\n      if (update) {\n        this._matchNode = node;\n        this._matchDist = dist;\n      }\n    },\n    queryEnvelope: function queryEnvelope() {\n      var queryEnv = new Envelope(this._p);\n      queryEnv.expandBy(this._tolerance);\n      return queryEnv;\n    },\n    getNode: function getNode() {\n      return this._matchNode;\n    },\n    interfaces_: function interfaces_() {\n      return [KdNodeVisitor];\n    },\n    getClass: function getClass() {\n      return BestMatchVisitor;\n    }\n  });\n  KdTree.BestMatchVisitor = BestMatchVisitor;\n\n\n\n  var kdtree = /*#__PURE__*/Object.freeze({\n    KdTree: KdTree\n  });\n\n  function NodeBase$1() {\n    this._items = new ArrayList();\n    this._subnode = new Array(4).fill(null);\n  }\n  extend(NodeBase$1.prototype, {\n    hasChildren: function hasChildren() {\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) return true;\n      }\n\n      return false;\n    },\n    isPrunable: function isPrunable() {\n      return !(this.hasChildren() || this.hasItems());\n    },\n    addAllItems: function addAllItems(resultItems) {\n      resultItems.addAll(this._items);\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          this._subnode[i].addAllItems(resultItems);\n        }\n      }\n\n      return resultItems;\n    },\n    getNodeCount: function getNodeCount() {\n      var subSize = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          subSize += this._subnode[i].size();\n        }\n      }\n\n      return subSize + 1;\n    },\n    size: function size() {\n      var subSize = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          subSize += this._subnode[i].size();\n        }\n      }\n\n      return subSize + this._items.size();\n    },\n    addAllItemsFromOverlapping: function addAllItemsFromOverlapping(searchEnv, resultItems) {\n      if (!this.isSearchMatch(searchEnv)) return null;\n      resultItems.addAll(this._items);\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          this._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n        }\n      }\n    },\n    visitItems: function visitItems(searchEnv, visitor) {\n      for (var i = this._items.iterator(); i.hasNext();) {\n        visitor.visitItem(i.next());\n      }\n    },\n    hasItems: function hasItems() {\n      return !this._items.isEmpty();\n    },\n    remove: function remove(itemEnv, item) {\n      if (!this.isSearchMatch(itemEnv)) return false;\n      var found = false;\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          found = this._subnode[i].remove(itemEnv, item);\n\n          if (found) {\n            if (this._subnode[i].isPrunable()) this._subnode[i] = null;\n            break;\n          }\n        }\n      }\n\n      if (found) return found;\n      found = this._items.remove(item);\n      return found;\n    },\n    visit: function visit(searchEnv, visitor) {\n      if (!this.isSearchMatch(searchEnv)) return null;\n      this.visitItems(searchEnv, visitor);\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          this._subnode[i].visit(searchEnv, visitor);\n        }\n      }\n    },\n    getItems: function getItems() {\n      return this._items;\n    },\n    depth: function depth() {\n      var maxSubDepth = 0;\n\n      for (var i = 0; i < 4; i++) {\n        if (this._subnode[i] !== null) {\n          var sqd = this._subnode[i].depth();\n\n          if (sqd > maxSubDepth) maxSubDepth = sqd;\n        }\n      }\n\n      return maxSubDepth + 1;\n    },\n    isEmpty: function isEmpty() {\n      var isEmpty = true;\n      if (!this._items.isEmpty()) isEmpty = false;else {\n        for (var i = 0; i < 4; i++) {\n          if (this._subnode[i] !== null) {\n            if (!this._subnode[i].isEmpty()) {\n              isEmpty = false;\n              break;\n            }\n          }\n        }\n      }\n      return isEmpty;\n    },\n    add: function add(item) {\n      this._items.add(item);\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable];\n    },\n    getClass: function getClass() {\n      return NodeBase$1;\n    }\n  });\n\n  NodeBase$1.getSubnodeIndex = function (env, centrex, centrey) {\n    var subnodeIndex = -1;\n\n    if (env.getMinX() >= centrex) {\n      if (env.getMinY() >= centrey) subnodeIndex = 3;\n      if (env.getMaxY() <= centrey) subnodeIndex = 1;\n    }\n\n    if (env.getMaxX() <= centrex) {\n      if (env.getMinY() >= centrey) subnodeIndex = 2;\n      if (env.getMaxY() <= centrey) subnodeIndex = 0;\n    }\n\n    return subnodeIndex;\n  };\n\n  function Key$1() {\n    this._pt = new Coordinate();\n    this._level = 0;\n    this._env = null;\n    var itemEnv = arguments[0];\n    this.computeKey(itemEnv);\n  }\n  extend(Key$1.prototype, {\n    getLevel: function getLevel() {\n      return this._level;\n    },\n    computeKey: function computeKey() {\n      if (arguments.length === 1) {\n        var itemEnv = arguments[0];\n        this._level = Key$1.computeQuadLevel(itemEnv);\n        this._env = new Envelope();\n        this.computeKey(this._level, itemEnv);\n\n        while (!this._env.contains(itemEnv)) {\n          this._level += 1;\n          this.computeKey(this._level, itemEnv);\n        }\n      } else if (arguments.length === 2) {\n        var level = arguments[0],\n            _itemEnv = arguments[1];\n        var quadSize = DoubleBits.powerOf2(level);\n        this._pt.x = Math.floor(_itemEnv.getMinX() / quadSize) * quadSize;\n        this._pt.y = Math.floor(_itemEnv.getMinY() / quadSize) * quadSize;\n\n        this._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);\n      }\n    },\n    getEnvelope: function getEnvelope() {\n      return this._env;\n    },\n    getCentre: function getCentre() {\n      return new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);\n    },\n    getPoint: function getPoint() {\n      return this._pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Key$1;\n    }\n  });\n\n  Key$1.computeQuadLevel = function (env) {\n    var dx = env.getWidth();\n    var dy = env.getHeight();\n    var dMax = dx > dy ? dx : dy;\n    var level = DoubleBits.exponent(dMax) + 1;\n    return level;\n  };\n\n  function Node$2() {\n    NodeBase$1.apply(this);\n    this._env = null;\n    this._centrex = null;\n    this._centrey = null;\n    this._level = null;\n    var env = arguments[0],\n        level = arguments[1];\n    this._env = env;\n    this._level = level;\n    this._centrex = (env.getMinX() + env.getMaxX()) / 2;\n    this._centrey = (env.getMinY() + env.getMaxY()) / 2;\n  }\n  inherits(Node$2, NodeBase$1);\n  extend(Node$2.prototype, {\n    find: function find(searchEnv) {\n      var subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n      if (subnodeIndex === -1) return this;\n\n      if (this._subnode[subnodeIndex] !== null) {\n        var node = this._subnode[subnodeIndex];\n        return node.find(searchEnv);\n      }\n\n      return this;\n    },\n    isSearchMatch: function isSearchMatch(searchEnv) {\n      if (searchEnv === null) return false;\n      return this._env.intersects(searchEnv);\n    },\n    getSubnode: function getSubnode(index) {\n      if (this._subnode[index] === null) {\n        this._subnode[index] = this.createSubnode(index);\n      }\n\n      return this._subnode[index];\n    },\n    getEnvelope: function getEnvelope() {\n      return this._env;\n    },\n    getNode: function getNode(searchEnv) {\n      var subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n\n      if (subnodeIndex !== -1) {\n        var node = this.getSubnode(subnodeIndex);\n        return node.getNode(searchEnv);\n      } else {\n        return this;\n      }\n    },\n    createSubnode: function createSubnode(index) {\n      var minx = 0.0;\n      var maxx = 0.0;\n      var miny = 0.0;\n      var maxy = 0.0;\n\n      switch (index) {\n        case 0:\n          minx = this._env.getMinX();\n          maxx = this._centrex;\n          miny = this._env.getMinY();\n          maxy = this._centrey;\n          break;\n\n        case 1:\n          minx = this._centrex;\n          maxx = this._env.getMaxX();\n          miny = this._env.getMinY();\n          maxy = this._centrey;\n          break;\n\n        case 2:\n          minx = this._env.getMinX();\n          maxx = this._centrex;\n          miny = this._centrey;\n          maxy = this._env.getMaxY();\n          break;\n\n        case 3:\n          minx = this._centrex;\n          maxx = this._env.getMaxX();\n          miny = this._centrey;\n          maxy = this._env.getMaxY();\n          break;\n      }\n\n      var sqEnv = new Envelope(minx, maxx, miny, maxy);\n      var node = new Node$2(sqEnv, this._level - 1);\n      return node;\n    },\n    insertNode: function insertNode(node) {\n      Assert.isTrue(this._env === null || this._env.contains(node._env));\n      var index = NodeBase$1.getSubnodeIndex(node._env, this._centrex, this._centrey);\n\n      if (node._level === this._level - 1) {\n        this._subnode[index] = node;\n      } else {\n        var childNode = this.createSubnode(index);\n        childNode.insertNode(node);\n        this._subnode[index] = childNode;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Node$2;\n    }\n  });\n\n  Node$2.createNode = function (env) {\n    var key = new Key$1(env);\n    var node = new Node$2(key.getEnvelope(), key.getLevel());\n    return node;\n  };\n\n  Node$2.createExpanded = function (node, addEnv) {\n    var expandEnv = new Envelope(addEnv);\n    if (node !== null) expandEnv.expandToInclude(node._env);\n    var largerNode = Node$2.createNode(expandEnv);\n    if (node !== null) largerNode.insertNode(node);\n    return largerNode;\n  };\n\n  function Root$1() {\n    NodeBase$1.apply(this);\n  }\n  inherits(Root$1, NodeBase$1);\n  extend(Root$1.prototype, {\n    insert: function insert(itemEnv, item) {\n      var index = NodeBase$1.getSubnodeIndex(itemEnv, Root$1.origin.x, Root$1.origin.y);\n\n      if (index === -1) {\n        this.add(item);\n        return null;\n      }\n\n      var node = this._subnode[index];\n\n      if (node === null || !node.getEnvelope().contains(itemEnv)) {\n        var largerNode = Node$2.createExpanded(node, itemEnv);\n        this._subnode[index] = largerNode;\n      }\n\n      this.insertContained(this._subnode[index], itemEnv, item);\n    },\n    isSearchMatch: function isSearchMatch(searchEnv) {\n      return true;\n    },\n    insertContained: function insertContained(tree, itemEnv, item) {\n      Assert.isTrue(tree.getEnvelope().contains(itemEnv));\n      var isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n      var isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n      var node = null;\n      if (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);\n      node.add(item);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Root$1;\n    }\n  });\n  Root$1.origin = new Coordinate(0.0, 0.0);\n\n  function SpatialIndex() {}\n  extend(SpatialIndex.prototype, {\n    insert: function insert(itemEnv, item) {},\n    remove: function remove(itemEnv, item) {},\n    query: function query() {\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SpatialIndex;\n    }\n  });\n\n  function Quadtree() {\n    this._root = null;\n    this._minExtent = 1.0;\n    this._root = new Root$1();\n  }\n  extend(Quadtree.prototype, {\n    size: function size() {\n      if (this._root !== null) return this._root.size();\n      return 0;\n    },\n    insert: function insert(itemEnv, item) {\n      this.collectStats(itemEnv);\n      var insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n\n      this._root.insert(insertEnv, item);\n    },\n    query: function query() {\n      if (arguments.length === 1) {\n        var searchEnv = arguments[0];\n        var visitor = new ArrayListVisitor();\n        this.query(searchEnv, visitor);\n        return visitor.getItems();\n      } else if (arguments.length === 2) {\n        var _searchEnv = arguments[0],\n            _visitor = arguments[1];\n\n        this._root.visit(_searchEnv, _visitor);\n      }\n    },\n    queryAll: function queryAll() {\n      var foundItems = new ArrayList();\n\n      this._root.addAllItems(foundItems);\n\n      return foundItems;\n    },\n    remove: function remove(itemEnv, item) {\n      var posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n      return this._root.remove(posEnv, item);\n    },\n    collectStats: function collectStats(itemEnv) {\n      var delX = itemEnv.getWidth();\n      if (delX < this._minExtent && delX > 0.0) this._minExtent = delX;\n      var delY = itemEnv.getHeight();\n      if (delY < this._minExtent && delY > 0.0) this._minExtent = delY;\n    },\n    depth: function depth() {\n      if (this._root !== null) return this._root.depth();\n      return 0;\n    },\n    isEmpty: function isEmpty() {\n      if (this._root === null) return true;\n      return this._root.isEmpty();\n    },\n    interfaces_: function interfaces_() {\n      return [SpatialIndex, Serializable];\n    },\n    getClass: function getClass() {\n      return Quadtree;\n    }\n  });\n\n  Quadtree.ensureExtent = function (itemEnv, minExtent) {\n    var minx = itemEnv.getMinX();\n    var maxx = itemEnv.getMaxX();\n    var miny = itemEnv.getMinY();\n    var maxy = itemEnv.getMaxY();\n    if (minx !== maxx && miny !== maxy) return itemEnv;\n\n    if (minx === maxx) {\n      minx = minx - minExtent / 2.0;\n      maxx = minx + minExtent / 2.0;\n    }\n\n    if (miny === maxy) {\n      miny = miny - minExtent / 2.0;\n      maxy = miny + minExtent / 2.0;\n    }\n\n    return new Envelope(minx, maxx, miny, maxy);\n  };\n\n  Quadtree.serialVersionUID = -7461163625812743604;\n\n\n\n  var quadtree = /*#__PURE__*/Object.freeze({\n    Quadtree: Quadtree\n  });\n\n  function Boundable() {}\n  extend(Boundable.prototype, {\n    getBounds: function getBounds() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Boundable;\n    }\n  });\n\n  function ItemBoundable() {\n    this._bounds = null;\n    this._item = null;\n    var bounds = arguments[0],\n        item = arguments[1];\n    this._bounds = bounds;\n    this._item = item;\n  }\n  extend(ItemBoundable.prototype, {\n    getItem: function getItem() {\n      return this._item;\n    },\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    interfaces_: function interfaces_() {\n      return [Boundable, Serializable];\n    },\n    getClass: function getClass() {\n      return ItemBoundable;\n    }\n  });\n\n  function PriorityQueue() {\n    this._size = null;\n    this._items = null;\n    this._size = 0;\n    this._items = new ArrayList();\n\n    this._items.add(null);\n  }\n  extend(PriorityQueue.prototype, {\n    poll: function poll() {\n      if (this.isEmpty()) return null;\n\n      var minItem = this._items.get(1);\n\n      this._items.set(1, this._items.get(this._size));\n\n      this._size -= 1;\n      this.reorder(1);\n      return minItem;\n    },\n    size: function size() {\n      return this._size;\n    },\n    reorder: function reorder(hole) {\n      var child = null;\n\n      var tmp = this._items.get(hole);\n\n      for (; hole * 2 <= this._size; hole = child) {\n        child = hole * 2;\n        if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n        if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;\n      }\n\n      this._items.set(hole, tmp);\n    },\n    clear: function clear() {\n      this._size = 0;\n\n      this._items.clear();\n    },\n    peek: function peek() {\n      if (this.isEmpty()) return null;\n\n      var minItem = this._items.get(1);\n\n      return minItem;\n    },\n    isEmpty: function isEmpty() {\n      return this._size === 0;\n    },\n    add: function add(x) {\n      this._items.add(null);\n\n      this._size += 1;\n      var hole = this._size;\n\n      this._items.set(0, x);\n\n      for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n        this._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n      }\n\n      this._items.set(hole, x);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PriorityQueue;\n    }\n  });\n\n  function AbstractNode() {\n    this._childBoundables = new ArrayList();\n    this._bounds = null;\n    this._level = null;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var level = arguments[0];\n      this._level = level;\n    }\n  }\n  extend(AbstractNode.prototype, {\n    getLevel: function getLevel() {\n      return this._level;\n    },\n    size: function size() {\n      return this._childBoundables.size();\n    },\n    getChildBoundables: function getChildBoundables() {\n      return this._childBoundables;\n    },\n    addChildBoundable: function addChildBoundable(childBoundable) {\n      Assert.isTrue(this._bounds === null);\n\n      this._childBoundables.add(childBoundable);\n    },\n    isEmpty: function isEmpty() {\n      return this._childBoundables.isEmpty();\n    },\n    getBounds: function getBounds() {\n      if (this._bounds === null) {\n        this._bounds = this.computeBounds();\n      }\n\n      return this._bounds;\n    },\n    interfaces_: function interfaces_() {\n      return [Boundable, Serializable];\n    },\n    getClass: function getClass() {\n      return AbstractNode;\n    }\n  });\n  AbstractNode.serialVersionUID = 6493722185909573708;\n\n  function BoundablePair() {\n    this._boundable1 = null;\n    this._boundable2 = null;\n    this._distance = null;\n    this._itemDistance = null;\n    var boundable1 = arguments[0],\n        boundable2 = arguments[1],\n        itemDistance = arguments[2];\n    this._boundable1 = boundable1;\n    this._boundable2 = boundable2;\n    this._itemDistance = itemDistance;\n    this._distance = this.distance();\n  }\n  extend(BoundablePair.prototype, {\n    expandToQueue: function expandToQueue(priQ, minDistance) {\n      var isComp1 = BoundablePair.isComposite(this._boundable1);\n      var isComp2 = BoundablePair.isComposite(this._boundable2);\n\n      if (isComp1 && isComp2) {\n        if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n          this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n          return null;\n        } else {\n          this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n          return null;\n        }\n      } else if (isComp1) {\n        this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n        return null;\n      } else if (isComp2) {\n        this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n        return null;\n      }\n\n      throw new IllegalArgumentException(\"neither boundable is composite\");\n    },\n    isLeaves: function isLeaves() {\n      return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n    },\n    compareTo: function compareTo(o) {\n      var nd = o;\n      if (this._distance < nd._distance) return -1;\n      if (this._distance > nd._distance) return 1;\n      return 0;\n    },\n    expand: function expand(bndComposite, bndOther, priQ, minDistance) {\n      var children = bndComposite.getChildBoundables();\n\n      for (var i = children.iterator(); i.hasNext();) {\n        var child = i.next();\n        var bp = new BoundablePair(child, bndOther, this._itemDistance);\n\n        if (bp.getDistance() < minDistance) {\n          priQ.add(bp);\n        }\n      }\n    },\n    getBoundable: function getBoundable(i) {\n      if (i === 0) return this._boundable1;\n      return this._boundable2;\n    },\n    getDistance: function getDistance() {\n      return this._distance;\n    },\n    distance: function distance() {\n      if (this.isLeaves()) {\n        return this._itemDistance.distance(this._boundable1, this._boundable2);\n      }\n\n      return this._boundable1.getBounds().distance(this._boundable2.getBounds());\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return BoundablePair;\n    }\n  });\n\n  BoundablePair.area = function (b) {\n    return b.getBounds().getArea();\n  };\n\n  BoundablePair.isComposite = function (item) {\n    return item instanceof AbstractNode;\n  };\n\n  function AbstractSTRtree() {\n    this._root = null;\n    this._built = false;\n    this._itemBoundables = new ArrayList();\n    this._nodeCapacity = null;\n\n    if (arguments.length === 0) {\n      AbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n    } else if (arguments.length === 1) {\n      var nodeCapacity = arguments[0];\n      Assert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n      this._nodeCapacity = nodeCapacity;\n    }\n  }\n  extend(AbstractSTRtree.prototype, {\n    queryInternal: function queryInternal() {\n      if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n        var searchBounds = arguments[0],\n            node = arguments[1],\n            visitor = arguments[2];\n        var childBoundables = node.getChildBoundables();\n\n        for (var i = 0; i < childBoundables.size(); i++) {\n          var childBoundable = childBoundables.get(i);\n\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n            continue;\n          }\n\n          if (childBoundable instanceof AbstractNode) {\n            this.queryInternal(searchBounds, childBoundable, visitor);\n          } else if (childBoundable instanceof ItemBoundable) {\n            visitor.visitItem(childBoundable.getItem());\n          } else {\n            Assert.shouldNeverReachHere();\n          }\n        }\n      } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n        var _searchBounds = arguments[0],\n            _node = arguments[1],\n            matches = arguments[2];\n\n        var childBoundables = _node.getChildBoundables();\n\n        for (var i = 0; i < childBoundables.size(); i++) {\n          var childBoundable = childBoundables.get(i);\n\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds)) {\n            continue;\n          }\n\n          if (childBoundable instanceof AbstractNode) {\n            this.queryInternal(_searchBounds, childBoundable, matches);\n          } else if (childBoundable instanceof ItemBoundable) {\n            matches.add(childBoundable.getItem());\n          } else {\n            Assert.shouldNeverReachHere();\n          }\n        }\n      }\n    },\n    getNodeCapacity: function getNodeCapacity() {\n      return this._nodeCapacity;\n    },\n    lastNode: function lastNode(nodes) {\n      return nodes.get(nodes.size() - 1);\n    },\n    size: function size() {\n      if (arguments.length === 0) {\n        if (this.isEmpty()) {\n          return 0;\n        }\n\n        this.build();\n        return this.size(this._root);\n      } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var size = 0;\n\n        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n          var childBoundable = i.next();\n\n          if (childBoundable instanceof AbstractNode) {\n            size += this.size(childBoundable);\n          } else if (childBoundable instanceof ItemBoundable) {\n            size += 1;\n          }\n        }\n\n        return size;\n      }\n    },\n    removeItem: function removeItem(node, item) {\n      var childToRemove = null;\n\n      for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n        var childBoundable = i.next();\n\n        if (childBoundable instanceof ItemBoundable) {\n          if (childBoundable.getItem() === item) childToRemove = childBoundable;\n        }\n      }\n\n      if (childToRemove !== null) {\n        node.getChildBoundables().remove(childToRemove);\n        return true;\n      }\n\n      return false;\n    },\n    itemsTree: function itemsTree() {\n      if (arguments.length === 0) {\n        this.build();\n        var valuesTree = this.itemsTree(this._root);\n        if (valuesTree === null) return new ArrayList();\n        return valuesTree;\n      } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var valuesTreeForNode = new ArrayList();\n\n        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n          var childBoundable = i.next();\n\n          if (childBoundable instanceof AbstractNode) {\n            var valuesTreeForChild = this.itemsTree(childBoundable);\n            if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n          } else if (childBoundable instanceof ItemBoundable) {\n            valuesTreeForNode.add(childBoundable.getItem());\n          } else {\n            Assert.shouldNeverReachHere();\n          }\n        }\n\n        if (valuesTreeForNode.size() <= 0) return null;\n        return valuesTreeForNode;\n      }\n    },\n    insert: function insert(bounds, item) {\n      Assert.isTrue(!this._built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n\n      this._itemBoundables.add(new ItemBoundable(bounds, item));\n    },\n    boundablesAtLevel: function boundablesAtLevel() {\n      if (arguments.length === 1) {\n        var level = arguments[0];\n        var boundables = new ArrayList();\n        this.boundablesAtLevel(level, this._root, boundables);\n        return boundables;\n      } else if (arguments.length === 3) {\n        var _level = arguments[0],\n            top = arguments[1],\n            _boundables = arguments[2];\n        Assert.isTrue(_level > -2);\n\n        if (top.getLevel() === _level) {\n          _boundables.add(top);\n\n          return null;\n        }\n\n        for (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n          var boundable = i.next();\n\n          if (boundable instanceof AbstractNode) {\n            this.boundablesAtLevel(_level, boundable, _boundables);\n          } else {\n            Assert.isTrue(boundable instanceof ItemBoundable);\n\n            if (_level === -1) {\n              _boundables.add(boundable);\n            }\n          }\n        }\n\n        return null;\n      }\n    },\n    query: function query() {\n      if (arguments.length === 1) {\n        var searchBounds = arguments[0];\n        this.build();\n        var matches = new ArrayList();\n\n        if (this.isEmpty()) {\n          return matches;\n        }\n\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n          this.queryInternal(searchBounds, this._root, matches);\n        }\n\n        return matches;\n      } else if (arguments.length === 2) {\n        var _searchBounds2 = arguments[0],\n            visitor = arguments[1];\n        this.build();\n\n        if (this.isEmpty()) {\n          return null;\n        }\n\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), _searchBounds2)) {\n          this.queryInternal(_searchBounds2, this._root, visitor);\n        }\n      }\n    },\n    build: function build() {\n      if (this._built) return null;\n      this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n      this._itemBoundables = null;\n      this._built = true;\n    },\n    getRoot: function getRoot() {\n      this.build();\n      return this._root;\n    },\n    remove: function remove() {\n      if (arguments.length === 2) {\n        var searchBounds = arguments[0],\n            item = arguments[1];\n        this.build();\n\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n          return this.remove(searchBounds, this._root, item);\n        }\n\n        return false;\n      } else if (arguments.length === 3) {\n        var _searchBounds3 = arguments[0],\n            node = arguments[1],\n            _item = arguments[2];\n        var found = this.removeItem(node, _item);\n        if (found) return true;\n        var childToPrune = null;\n\n        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n          var childBoundable = i.next();\n\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds3)) {\n            continue;\n          }\n\n          if (childBoundable instanceof AbstractNode) {\n            found = this.remove(_searchBounds3, childBoundable, _item);\n\n            if (found) {\n              childToPrune = childBoundable;\n              break;\n            }\n          }\n        }\n\n        if (childToPrune !== null) {\n          if (childToPrune.getChildBoundables().isEmpty()) {\n            node.getChildBoundables().remove(childToPrune);\n          }\n        }\n\n        return found;\n      }\n    },\n    createHigherLevels: function createHigherLevels(boundablesOfALevel, level) {\n      Assert.isTrue(!boundablesOfALevel.isEmpty());\n      var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n\n      if (parentBoundables.size() === 1) {\n        return parentBoundables.get(0);\n      }\n\n      return this.createHigherLevels(parentBoundables, level + 1);\n    },\n    depth: function depth() {\n      if (arguments.length === 0) {\n        if (this.isEmpty()) {\n          return 0;\n        }\n\n        this.build();\n        return this.depth(this._root);\n      } else if (arguments.length === 1) {\n        var node = arguments[0];\n        var maxChildDepth = 0;\n\n        for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n          var childBoundable = i.next();\n\n          if (childBoundable instanceof AbstractNode) {\n            var childDepth = this.depth(childBoundable);\n            if (childDepth > maxChildDepth) maxChildDepth = childDepth;\n          }\n        }\n\n        return maxChildDepth + 1;\n      }\n    },\n    createParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n      Assert.isTrue(!childBoundables.isEmpty());\n      var parentBoundables = new ArrayList();\n      parentBoundables.add(this.createNode(newLevel));\n      var sortedChildBoundables = new ArrayList(childBoundables);\n      Collections.sort(sortedChildBoundables, this.getComparator());\n\n      for (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n        var childBoundable = i.next();\n\n        if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n          parentBoundables.add(this.createNode(newLevel));\n        }\n\n        this.lastNode(parentBoundables).addChildBoundable(childBoundable);\n      }\n\n      return parentBoundables;\n    },\n    isEmpty: function isEmpty() {\n      if (!this._built) return this._itemBoundables.isEmpty();\n      return this._root.isEmpty();\n    },\n    interfaces_: function interfaces_() {\n      return [Serializable];\n    },\n    getClass: function getClass() {\n      return AbstractSTRtree;\n    }\n  });\n\n  AbstractSTRtree.compareDoubles = function (a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  };\n\n  function IntersectsOp$1() {}\n\n  AbstractSTRtree.IntersectsOp = IntersectsOp$1;\n  AbstractSTRtree.serialVersionUID = -3886435814360241337;\n  AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  function ItemDistance() {}\n  extend(ItemDistance.prototype, {\n    distance: function distance(item1, item2) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ItemDistance;\n    }\n  });\n\n  function STRtree() {\n    if (arguments.length === 0) {\n      STRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n    } else if (arguments.length === 1) {\n      var nodeCapacity = arguments[0];\n      AbstractSTRtree.call(this, nodeCapacity);\n    }\n  }\n  inherits(STRtree, AbstractSTRtree);\n  extend(STRtree.prototype, {\n    createParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n      Assert.isTrue(verticalSlices.length > 0);\n      var parentBoundables = new ArrayList();\n\n      for (var i = 0; i < verticalSlices.length; i++) {\n        parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n      }\n\n      return parentBoundables;\n    },\n    createNode: function createNode(level) {\n      return new STRtreeNode(level);\n    },\n    size: function size() {\n      if (arguments.length === 0) {\n        return AbstractSTRtree.prototype.size.call(this);\n      } else return AbstractSTRtree.prototype.size.apply(this, arguments);\n    },\n    insert: function insert() {\n      if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {\n        var itemEnv = arguments[0],\n            item = arguments[1];\n\n        if (itemEnv.isNull()) {\n          return null;\n        }\n\n        AbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n      } else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n    },\n    getIntersectsOp: function getIntersectsOp() {\n      return STRtree.intersectsOp;\n    },\n    verticalSlices: function verticalSlices(childBoundables, sliceCount) {\n      var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n      var slices = new Array(sliceCount).fill(null);\n      var i = childBoundables.iterator();\n\n      for (var j = 0; j < sliceCount; j++) {\n        slices[j] = new ArrayList();\n        var boundablesAddedToSlice = 0;\n\n        while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n          var childBoundable = i.next();\n          slices[j].add(childBoundable);\n          boundablesAddedToSlice++;\n        }\n      }\n\n      return slices;\n    },\n    query: function query() {\n      if (arguments.length === 1) {\n        var searchEnv = arguments[0];\n        return AbstractSTRtree.prototype.query.call(this, searchEnv);\n      } else if (arguments.length === 2) {\n        var _searchEnv = arguments[0],\n            visitor = arguments[1];\n        AbstractSTRtree.prototype.query.call(this, _searchEnv, visitor);\n      }\n    },\n    getComparator: function getComparator() {\n      return STRtree.yComparator;\n    },\n    createParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n      return AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n    },\n    remove: function remove() {\n      if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {\n        var itemEnv = arguments[0],\n            item = arguments[1];\n        return AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n      } else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n    },\n    depth: function depth() {\n      if (arguments.length === 0) {\n        return AbstractSTRtree.prototype.depth.call(this);\n      } else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n    },\n    createParentBoundables: function createParentBoundables(childBoundables, newLevel) {\n      Assert.isTrue(!childBoundables.isEmpty());\n      var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n      var sortedChildBoundables = new ArrayList(childBoundables);\n      Collections.sort(sortedChildBoundables, STRtree.xComparator);\n      var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n      return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n    },\n    nearestNeighbour: function nearestNeighbour() {\n      if (arguments.length === 1) {\n        if (hasInterface(arguments[0], ItemDistance)) {\n          var itemDist = arguments[0];\n          var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n          return this.nearestNeighbour(bp);\n        } else if (arguments[0] instanceof BoundablePair) {\n          var initBndPair = arguments[0];\n          return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n        }\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n          var tree = arguments[0],\n              _itemDist = arguments[1];\n          var bp = new BoundablePair(this.getRoot(), tree.getRoot(), _itemDist);\n          return this.nearestNeighbour(bp);\n        } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n          var _initBndPair = arguments[0],\n              maxDistance = arguments[1];\n          var distanceLowerBound = maxDistance;\n          var minPair = null;\n          var priQ = new PriorityQueue();\n          priQ.add(_initBndPair);\n\n          while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n            var bndPair = priQ.poll();\n            var currentDistance = bndPair.getDistance();\n            if (currentDistance >= distanceLowerBound) break;\n\n            if (bndPair.isLeaves()) {\n              distanceLowerBound = currentDistance;\n              minPair = bndPair;\n            } else {\n              bndPair.expandToQueue(priQ, distanceLowerBound);\n            }\n          }\n\n          return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n        } else if (arguments[0] instanceof BoundablePair && Number.isInteger(arguments[1])) {\n          var _initBndPair2 = arguments[0],\n              k = arguments[1];\n          return this.nearestNeighbour(_initBndPair2, Double.POSITIVE_INFINITY, k);\n        }\n      } else if (arguments.length === 3) {\n        if (hasInterface(arguments[2], ItemDistance) && arguments[0] instanceof Envelope && arguments[1] instanceof Object) {\n          var env = arguments[0],\n              item = arguments[1],\n              _itemDist2 = arguments[2];\n          var bnd = new ItemBoundable(env, item);\n          var bp = new BoundablePair(this.getRoot(), bnd, _itemDist2);\n          return this.nearestNeighbour(bp)[0];\n        } else if (Number.isInteger(arguments[2]) && arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n          var _initBndPair3 = arguments[0],\n              _maxDistance = arguments[1],\n              _k = arguments[2];\n          var distanceLowerBound = _maxDistance;\n          var priQ = new PriorityQueue();\n          priQ.add(_initBndPair3);\n          var kNearestNeighbors = new PriorityQueue();\n\n          while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {\n            var bndPair = priQ.poll();\n            var currentDistance = bndPair.getDistance();\n\n            if (currentDistance >= distanceLowerBound) {\n              break;\n            }\n\n            if (bndPair.isLeaves()) {\n              if (kNearestNeighbors.size() < _k) {\n                kNearestNeighbors.add(bndPair);\n              } else {\n                var bp1 = kNearestNeighbors.peek();\n\n                if (bp1.getDistance() > currentDistance) {\n                  kNearestNeighbors.poll();\n                  kNearestNeighbors.add(bndPair);\n                }\n\n                var bp2 = kNearestNeighbors.peek();\n                distanceLowerBound = bp2.getDistance();\n              }\n            } else {\n              bndPair.expandToQueue(priQ, distanceLowerBound);\n            }\n          }\n\n          return STRtree.getItems(kNearestNeighbors);\n        }\n      } else if (arguments.length === 4) {\n        var _env = arguments[0],\n            _item = arguments[1],\n            _itemDist3 = arguments[2],\n            _k2 = arguments[3];\n        var bnd = new ItemBoundable(_env, _item);\n        var bp = new BoundablePair(this.getRoot(), bnd, _itemDist3);\n        return this.nearestNeighbour(bp, _k2);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [SpatialIndex, Serializable];\n    },\n    getClass: function getClass() {\n      return STRtree;\n    }\n  });\n\n  STRtree.centreX = function (e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX());\n  };\n\n  STRtree.avg = function (a, b) {\n    return (a + b) / 2;\n  };\n\n  STRtree.getItems = function (kNearestNeighbors) {\n    var items = new Array(kNearestNeighbors.size()).fill(null);\n    var count = 0;\n\n    while (!kNearestNeighbors.isEmpty()) {\n      var bp = kNearestNeighbors.poll();\n      items[count] = bp.getBoundable(0).getItem();\n      count++;\n    }\n\n    return items;\n  };\n\n  STRtree.centreY = function (e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY());\n  };\n\n  function STRtreeNode() {\n    var level = arguments[0];\n    AbstractNode.call(this, level);\n  }\n\n  inherits(STRtreeNode, AbstractNode);\n  extend(STRtreeNode.prototype, {\n    computeBounds: function computeBounds() {\n      var bounds = null;\n\n      for (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n        var childBoundable = i.next();\n\n        if (bounds === null) {\n          bounds = new Envelope(childBoundable.getBounds());\n        } else {\n          bounds.expandToInclude(childBoundable.getBounds());\n        }\n      }\n\n      return bounds;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return STRtreeNode;\n    }\n  });\n  STRtree.STRtreeNode = STRtreeNode;\n  STRtree.serialVersionUID = 259274702368956900;\n  STRtree.xComparator = {\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    compare: function compare(o1, o2) {\n      return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n    }\n  };\n  STRtree.yComparator = {\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    compare: function compare(o1, o2) {\n      return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n    }\n  };\n  STRtree.intersectsOp = {\n    interfaces_: function interfaces_() {\n      return [IntersectsOp];\n    },\n    intersects: function intersects(aBounds, bBounds) {\n      return aBounds.intersects(bBounds);\n    }\n  };\n  STRtree.DEFAULT_NODE_CAPACITY = 10;\n\n\n\n  var strtree = /*#__PURE__*/Object.freeze({\n    STRtree: STRtree\n  });\n\n\n\n  var index = /*#__PURE__*/Object.freeze({\n    kdtree: kdtree,\n    quadtree: quadtree,\n    strtree: strtree\n  });\n\n  var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n  /**\n   * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n   * NOTE: Adapted from OpenLayers 2.11 implementation.\n   */\n\n  /**\n   * Create a new parser for GeoJSON\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of GeoJsonParser.\n   * @constructor\n   * @private\n   */\n\n  function GeoJSONParser(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n  }\n  extend(GeoJSONParser.prototype, {\n    /**\n     * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n     *\n     * @param {}\n     *          A GeoJSON object.\n     * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n     * @private\n     */\n    read: function read(json) {\n      var obj;\n      if (typeof json === 'string') obj = JSON.parse(json);else obj = json;\n      var type = obj.type;\n      if (!parse$1[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);\n      if (geometryTypes.indexOf(type) !== -1) return parse$1[type].call(this, obj.coordinates);else if (type === 'GeometryCollection') return parse$1[type].call(this, obj.geometries); // feature or feature collection\n\n      return parse$1[type].call(this, obj);\n    },\n\n    /**\n     * Serialize a Geometry object into GeoJSON\n     *\n     * @param {Geometry}\n     *          geometry A Geometry or array of Geometries.\n     * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n     * @private\n     */\n    write: function write(geometry) {\n      var type = geometry.getGeometryType();\n      if (!extract$1[type]) throw new Error('Geometry is not supported');\n      return extract$1[type].call(this, geometry);\n    }\n  });\n  var parse$1 = {\n    /**\n     * Parse a GeoJSON Feature object\n     *\n     * @param {Object}\n     *          obj Object to parse.\n     *\n     * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n     */\n    Feature: function Feature(obj) {\n      var feature = {};\n\n      for (var key in obj) {\n        feature[key] = obj[key];\n      }\n\n      if (obj.geometry) {\n        var type = obj.geometry.type;\n        if (!parse$1[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);\n        feature.geometry = this.read(obj.geometry);\n      }\n\n      if (obj.bbox) feature.bbox = parse$1.bbox.call(this, obj.bbox);\n      return feature;\n    },\n\n    /**\n     * Parse a GeoJSON FeatureCollection object\n     *\n     * @param {Object}\n     *          obj Object to parse.\n     *\n     * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n     */\n    FeatureCollection: function FeatureCollection(obj) {\n      var featureCollection = {};\n\n      if (obj.features) {\n        featureCollection.features = [];\n\n        for (var i = 0; i < obj.features.length; ++i) {\n          featureCollection.features.push(this.read(obj.features[i]));\n        }\n      }\n\n      if (obj.bbox) featureCollection.bbox = this.parse.bbox.call(this, obj.bbox);\n      return featureCollection;\n    },\n\n    /**\n     * Convert the ordinates in an array to an array of Coordinates\n     *\n     * @param {Array}\n     *          array Array with {Number}s.\n     *\n     * @return {Array} Array with Coordinates.\n     */\n    coordinates: function coordinates(array) {\n      var coordinates = [];\n\n      for (var i = 0; i < array.length; ++i) {\n        var sub = array[i];\n        coordinates.push(new Coordinate(sub[0], sub[1]));\n      }\n\n      return coordinates;\n    },\n\n    /**\n     * Convert the bbox to a LinearRing\n     *\n     * @param {Array}\n     *          array Array with [xMin, yMin, xMax, yMax].\n     *\n     * @return {Array} Array with Coordinates.\n     */\n    bbox: function bbox(array) {\n      return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);\n    },\n\n    /**\n     * Convert an Array with ordinates to a Point\n     *\n     * @param {Array}\n     *          array Array with ordinates.\n     *\n     * @return {Point} Point.\n     */\n    Point: function Point(array) {\n      var coordinate = new Coordinate(array[0], array[1]);\n      return this.geometryFactory.createPoint(coordinate);\n    },\n\n    /**\n     * Convert an Array with coordinates to a MultiPoint\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {MultiPoint} MultiPoint.\n     */\n    MultiPoint: function MultiPoint(array) {\n      var points = [];\n\n      for (var i = 0; i < array.length; ++i) {\n        points.push(parse$1.Point.call(this, array[i]));\n      }\n\n      return this.geometryFactory.createMultiPoint(points);\n    },\n\n    /**\n     * Convert an Array with coordinates to a LineString\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {LineString} LineString.\n     */\n    LineString: function LineString(array) {\n      var coordinates = parse$1.coordinates.call(this, array);\n      return this.geometryFactory.createLineString(coordinates);\n    },\n\n    /**\n     * Convert an Array with coordinates to a MultiLineString\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {MultiLineString} MultiLineString.\n     */\n    MultiLineString: function MultiLineString(array) {\n      var lineStrings = [];\n\n      for (var i = 0; i < array.length; ++i) {\n        lineStrings.push(parse$1.LineString.call(this, array[i]));\n      }\n\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n\n    /**\n     * Convert an Array to a Polygon\n     *\n     * @param {Array}\n     *          array Array with shell and holes.\n     *\n     * @return {Polygon} Polygon.\n     */\n    Polygon: function Polygon(array) {\n      var shellCoordinates = parse$1.coordinates.call(this, array[0]);\n      var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n      var holes = [];\n\n      for (var i = 1; i < array.length; ++i) {\n        var hole = array[i];\n        var coordinates = parse$1.coordinates.call(this, hole);\n        var linearRing = this.geometryFactory.createLinearRing(coordinates);\n        holes.push(linearRing);\n      }\n\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n\n    /**\n     * Convert an Array to a MultiPolygon\n     *\n     * @param {Array}\n     *          array Array of arrays with shell and rings.\n     *\n     * @return {MultiPolygon} MultiPolygon.\n     */\n    MultiPolygon: function MultiPolygon(array) {\n      var polygons = [];\n\n      for (var i = 0; i < array.length; ++i) {\n        var polygon = array[i];\n        polygons.push(parse$1.Polygon.call(this, polygon));\n      }\n\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n\n    /**\n     * Convert an Array to a GeometryCollection\n     *\n     * @param {Array}\n     *          array Array of GeoJSON geometries.\n     *\n     * @return {GeometryCollection} GeometryCollection.\n     */\n    GeometryCollection: function GeometryCollection(array) {\n      var geometries = [];\n\n      for (var i = 0; i < array.length; ++i) {\n        var geometry = array[i];\n        geometries.push(this.read(geometry));\n      }\n\n      return this.geometryFactory.createGeometryCollection(geometries);\n    }\n  };\n  var extract$1 = {\n    /**\n     * Convert a Coordinate to an Array\n     *\n     * @param {Coordinate}\n     *          coordinate Coordinate to convert.\n     *\n     * @return {Array} Array of ordinates.\n     */\n    coordinate: function coordinate(_coordinate) {\n      return [_coordinate.x, _coordinate.y];\n    },\n\n    /**\n     * Convert a Point to a GeoJSON object\n     *\n     * @param {Point}\n     *          point Point to convert.\n     *\n     * @return {Array} Array of 2 ordinates (paired to a coordinate).\n     */\n    Point: function Point(point) {\n      var array = extract$1.coordinate.call(this, point.getCoordinate());\n      return {\n        type: 'Point',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiPoint to a GeoJSON object\n     *\n     * @param {MultiPoint}\n     *          multipoint MultiPoint to convert.\n     *\n     * @return {Array} Array of coordinates.\n     */\n    MultiPoint: function MultiPoint(multipoint) {\n      var array = [];\n\n      for (var i = 0; i < multipoint._geometries.length; ++i) {\n        var point = multipoint._geometries[i];\n        var geoJson = extract$1.Point.call(this, point);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiPoint',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a LineString to a GeoJSON object\n     *\n     * @param {LineString}\n     *          linestring LineString to convert.\n     *\n     * @return {Array} Array of coordinates.\n     */\n    LineString: function LineString(linestring) {\n      var array = [];\n      var coordinates = linestring.getCoordinates();\n\n      for (var i = 0; i < coordinates.length; ++i) {\n        var coordinate = coordinates[i];\n        array.push(extract$1.coordinate.call(this, coordinate));\n      }\n\n      return {\n        type: 'LineString',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiLineString to a GeoJSON object\n     *\n     * @param {MultiLineString}\n     *          multilinestring MultiLineString to convert.\n     *\n     * @return {Array} Array of Array of coordinates.\n     */\n    MultiLineString: function MultiLineString(multilinestring) {\n      var array = [];\n\n      for (var i = 0; i < multilinestring._geometries.length; ++i) {\n        var linestring = multilinestring._geometries[i];\n        var geoJson = extract$1.LineString.call(this, linestring);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiLineString',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a Polygon to a GeoJSON object\n     *\n     * @param {Polygon}\n     *          polygon Polygon to convert.\n     *\n     * @return {Array} Array with shell, holes.\n     */\n    Polygon: function Polygon(polygon) {\n      var array = [];\n      var shellGeoJson = extract$1.LineString.call(this, polygon._shell);\n      array.push(shellGeoJson.coordinates);\n\n      for (var i = 0; i < polygon._holes.length; ++i) {\n        var hole = polygon._holes[i];\n        var holeGeoJson = extract$1.LineString.call(this, hole);\n        array.push(holeGeoJson.coordinates);\n      }\n\n      return {\n        type: 'Polygon',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiPolygon to a GeoJSON object\n     *\n     * @param {MultiPolygon}\n     *          multipolygon MultiPolygon to convert.\n     *\n     * @return {Array} Array of polygons.\n     */\n    MultiPolygon: function MultiPolygon(multipolygon) {\n      var array = [];\n\n      for (var i = 0; i < multipolygon._geometries.length; ++i) {\n        var polygon = multipolygon._geometries[i];\n        var geoJson = extract$1.Polygon.call(this, polygon);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiPolygon',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a GeometryCollection to a GeoJSON object\n     *\n     * @param {GeometryCollection}\n     *          collection GeometryCollection to convert.\n     *\n     * @return {Array} Array of geometries.\n     */\n    GeometryCollection: function GeometryCollection(collection) {\n      var array = [];\n\n      for (var i = 0; i < collection._geometries.length; ++i) {\n        var geometry = collection._geometries[i];\n        var type = geometry.getGeometryType();\n        array.push(extract$1[type].call(this, geometry));\n      }\n\n      return {\n        type: 'GeometryCollection',\n        geometries: array\n      };\n    }\n  };\n\n  /**\n   * @module org/locationtech/jts/io/GeoJSONReader\n   */\n  /**\n   * Converts a geometry in GeoJSON to a {@link Geometry}.\n   */\n\n  /**\n   * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @constructor\n   */\n\n  function GeoJSONReader(geometryFactory) {\n    this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory());\n  }\n  extend(GeoJSONReader.prototype, {\n    /**\n     * Reads a GeoJSON representation of a {@link Geometry}\n     *\n     * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n     *\n     * @param {Object|String} geoJson a GeoJSON Object or String.\n     * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n     * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n     */\n    read: function read(geoJson) {\n      var geometry = this.parser.read(geoJson);\n      return geometry;\n    }\n  });\n\n  /**\n   * @module org/locationtech/jts/io/GeoJSONWriter\n   */\n  /**\n   * Writes the GeoJSON representation of a {@link Geometry}. The\n   * The GeoJSON format is defined <A\n   * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n   */\n\n  /**\n   * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n   * model. Only the maximum number of decimal places necessary to represent the\n   * ordinates to the required precision will be output.\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @constructor\n   */\n\n  function GeoJSONWriter() {\n    this.parser = new GeoJSONParser(this.geometryFactory);\n  }\n  extend(GeoJSONWriter.prototype, {\n    /**\n     * Converts a <code>Geometry</code> to its GeoJSON representation.\n     *\n     * @param {Geometry}\n     *          geometry a <code>Geometry</code> to process.\n     * @return {Object} The GeoJSON representation of the Geometry.\n     * @memberof module:org/locationtech/jts/io/GeoJSONWriter#\n     */\n    write: function write(geometry) {\n      return this.parser.write(geometry);\n    }\n  });\n\n  /**\n   * @module org/locationtech/jts/io/WKTReader\n   */\n  /**\n   * Converts a geometry in Well-Known Text format to a {@link Geometry}.\n   * <p>\n   * <code>WKTReader</code> supports extracting <code>Geometry</code> objects\n   * from either {@link Reader}s or {@link String}s. This allows it to function\n   * as a parser to read <code>Geometry</code> objects from text blocks embedded\n   * in other data formats (e.g. XML).\n   */\n\n  /**\n   * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,\n   * to allow it to create <code>Geometry</code> objects of the appropriate\n   * implementation. In particular, the <code>GeometryFactory</code> determines\n   * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n   * @param {GeometryFactory} geometryFactory\n   * @constructor\n   */\n\n  function WKTReader(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory || new GeometryFactory());\n  }\n  extend(WKTReader.prototype, {\n    /**\n     * Reads a Well-Known Text representation of a {@link Geometry}\n     *\n     * @param {string}\n     *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features\n     *          Specification).\n     * @return {Geometry} a <code>Geometry</code> read from\n     *         <code>string.</code>\n     * @memberof module:org/locationtech/jts/io/WKTReader#\n     */\n    read: function read(wkt) {\n      var geometry = this.parser.read(wkt);\n      return geometry;\n    }\n  });\n\n  /*eslint-disable no-undef */\n\n  function p2c(p) {\n    return [p.x, p.y];\n  }\n  /**\n   * OpenLayers Geometry parser and writer\n   * @param {GeometryFactory} geometryFactory\n   * @param {ol} olReference \n   * @constructor\n   */\n\n\n  function OL3Parser(geometryFactory, olReference) {\n    this.geometryFactory = geometryFactory || new GeometryFactory();\n    this.ol = olReference || typeof ol !== 'undefined' && ol;\n  }\n  extend(OL3Parser.prototype, {\n    /**\n     * Inject OpenLayers geom classes\n     */\n    inject: function inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {\n      this.ol = {\n        geom: {\n          Point: Point,\n          LineString: LineString,\n          LinearRing: LinearRing,\n          Polygon: Polygon,\n          MultiPoint: MultiPoint,\n          MultiLineString: MultiLineString,\n          MultiPolygon: MultiPolygon,\n          GeometryCollection: GeometryCollection\n        }\n      };\n    },\n\n    /**\n     * @param geometry {ol.geom.Geometry}\n     * @return {Geometry}\n     * @memberof module:org/locationtech/jts/io/OL3Parser#\n     */\n    read: function read(geometry) {\n      var ol = this.ol;\n\n      if (geometry instanceof ol.geom.Point) {\n        return this.convertFromPoint(geometry);\n      } else if (geometry instanceof ol.geom.LineString) {\n        return this.convertFromLineString(geometry);\n      } else if (geometry instanceof ol.geom.LinearRing) {\n        return this.convertFromLinearRing(geometry);\n      } else if (geometry instanceof ol.geom.Polygon) {\n        return this.convertFromPolygon(geometry);\n      } else if (geometry instanceof ol.geom.MultiPoint) {\n        return this.convertFromMultiPoint(geometry);\n      } else if (geometry instanceof ol.geom.MultiLineString) {\n        return this.convertFromMultiLineString(geometry);\n      } else if (geometry instanceof ol.geom.MultiPolygon) {\n        return this.convertFromMultiPolygon(geometry);\n      } else if (geometry instanceof ol.geom.GeometryCollection) {\n        return this.convertFromCollection(geometry);\n      }\n    },\n    convertFromPoint: function convertFromPoint(point) {\n      var coordinates = point.getCoordinates();\n      return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));\n    },\n    convertFromLineString: function convertFromLineString(lineString) {\n      return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromLinearRing: function convertFromLinearRing(linearRing) {\n      return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    },\n    convertFromPolygon: function convertFromPolygon(polygon) {\n      var linearRings = polygon.getLinearRings();\n      var shell = null;\n      var holes = [];\n\n      for (var i = 0; i < linearRings.length; i++) {\n        var linearRing = this.convertFromLinearRing(linearRings[i]);\n\n        if (i === 0) {\n          shell = linearRing;\n        } else {\n          holes.push(linearRing);\n        }\n      }\n\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n    convertFromMultiPoint: function convertFromMultiPoint(multiPoint) {\n      var points = multiPoint.getPoints().map(function (point) {\n        return this.convertFromPoint(point);\n      }, this);\n      return this.geometryFactory.createMultiPoint(points);\n    },\n    convertFromMultiLineString: function convertFromMultiLineString(multiLineString) {\n      var lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n        return this.convertFromLineString(lineString);\n      }, this);\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n    convertFromMultiPolygon: function convertFromMultiPolygon(multiPolygon) {\n      var polygons = multiPolygon.getPolygons().map(function (polygon) {\n        return this.convertFromPolygon(polygon);\n      }, this);\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n    convertFromCollection: function convertFromCollection(collection) {\n      var geometries = collection.getGeometries().map(function (geometry) {\n        return this.read(geometry);\n      }, this);\n      return this.geometryFactory.createGeometryCollection(geometries);\n    },\n\n    /**\n     * @param geometry\n     *          {Geometry}\n     * @return {ol.geom.Geometry}\n     * @memberof module:org/locationtech/jts/io/OL3Parser#\n     */\n    write: function write(geometry) {\n      if (geometry.getGeometryType() === 'Point') {\n        return this.convertToPoint(geometry.getCoordinate());\n      } else if (geometry.getGeometryType() === 'LineString') {\n        return this.convertToLineString(geometry);\n      } else if (geometry.getGeometryType() === 'LinearRing') {\n        return this.convertToLinearRing(geometry);\n      } else if (geometry.getGeometryType() === 'Polygon') {\n        return this.convertToPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPoint') {\n        return this.convertToMultiPoint(geometry);\n      } else if (geometry.getGeometryType() === 'MultiLineString') {\n        return this.convertToMultiLineString(geometry);\n      } else if (geometry.getGeometryType() === 'MultiPolygon') {\n        return this.convertToMultiPolygon(geometry);\n      } else if (geometry.getGeometryType() === 'GeometryCollection') {\n        return this.convertToCollection(geometry);\n      }\n    },\n    convertToPoint: function convertToPoint(coordinate) {\n      return new this.ol.geom.Point([coordinate.x, coordinate.y]);\n    },\n    convertToLineString: function convertToLineString(lineString) {\n      var points = lineString._points._coordinates.map(p2c);\n\n      return new this.ol.geom.LineString(points);\n    },\n    convertToLinearRing: function convertToLinearRing(linearRing) {\n      var points = linearRing._points._coordinates.map(p2c);\n\n      return new this.ol.geom.LinearRing(points);\n    },\n    convertToPolygon: function convertToPolygon(polygon) {\n      var rings = [polygon._shell._points._coordinates.map(p2c)];\n\n      for (var i = 0; i < polygon._holes.length; i++) {\n        rings.push(polygon._holes[i]._points._coordinates.map(p2c));\n      }\n\n      return new this.ol.geom.Polygon(rings);\n    },\n    convertToMultiPoint: function convertToMultiPoint(multiPoint) {\n      return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));\n    },\n    convertToMultiLineString: function convertToMultiLineString(multiLineString) {\n      var lineStrings = [];\n\n      for (var i = 0; i < multiLineString._geometries.length; i++) {\n        lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates());\n      }\n\n      return new this.ol.geom.MultiLineString(lineStrings);\n    },\n    convertToMultiPolygon: function convertToMultiPolygon(multiPolygon) {\n      var polygons = [];\n\n      for (var i = 0; i < multiPolygon._geometries.length; i++) {\n        polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates());\n      }\n\n      return new this.ol.geom.MultiPolygon(polygons);\n    },\n    convertToCollection: function convertToCollection(geometryCollection) {\n      var geometries = [];\n\n      for (var i = 0; i < geometryCollection._geometries.length; i++) {\n        var geometry = geometryCollection._geometries[i];\n        geometries.push(this.write(geometry));\n      }\n\n      return new this.ol.geom.GeometryCollection(geometries);\n    }\n  });\n\n\n\n  var io = /*#__PURE__*/Object.freeze({\n    GeoJSONReader: GeoJSONReader,\n    GeoJSONWriter: GeoJSONWriter,\n    OL3Parser: OL3Parser,\n    WKTReader: WKTReader,\n    WKTWriter: WKTWriter\n  });\n\n  function SegmentPointComparator() {}\n  extend(SegmentPointComparator.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentPointComparator;\n    }\n  });\n\n  SegmentPointComparator.relativeSign = function (x0, x1) {\n    if (x0 < x1) return -1;\n    if (x0 > x1) return 1;\n    return 0;\n  };\n\n  SegmentPointComparator.compare = function (octant, p0, p1) {\n    if (p0.equals2D(p1)) return 0;\n    var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n    var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n\n    switch (octant) {\n      case 0:\n        return SegmentPointComparator.compareValue(xSign, ySign);\n\n      case 1:\n        return SegmentPointComparator.compareValue(ySign, xSign);\n\n      case 2:\n        return SegmentPointComparator.compareValue(ySign, -xSign);\n\n      case 3:\n        return SegmentPointComparator.compareValue(-xSign, ySign);\n\n      case 4:\n        return SegmentPointComparator.compareValue(-xSign, -ySign);\n\n      case 5:\n        return SegmentPointComparator.compareValue(-ySign, -xSign);\n\n      case 6:\n        return SegmentPointComparator.compareValue(-ySign, xSign);\n\n      case 7:\n        return SegmentPointComparator.compareValue(xSign, -ySign);\n    }\n\n    Assert.shouldNeverReachHere(\"invalid octant value\");\n    return 0;\n  };\n\n  SegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n    if (compareSign0 < 0) return -1;\n    if (compareSign0 > 0) return 1;\n    if (compareSign1 < 0) return -1;\n    if (compareSign1 > 0) return 1;\n    return 0;\n  };\n\n  function SegmentNode() {\n    this._segString = null;\n    this.coord = null;\n    this.segmentIndex = null;\n    this._segmentOctant = null;\n    this._isInterior = null;\n    var segString = arguments[0],\n        coord = arguments[1],\n        segmentIndex = arguments[2],\n        segmentOctant = arguments[3];\n    this._segString = segString;\n    this.coord = new Coordinate(coord);\n    this.segmentIndex = segmentIndex;\n    this._segmentOctant = segmentOctant;\n    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n  }\n  extend(SegmentNode.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this.coord;\n    },\n    print: function print(out) {\n      out.print(this.coord);\n      out.print(\" seg # = \" + this.segmentIndex);\n    },\n    compareTo: function compareTo(obj) {\n      var other = obj;\n      if (this.segmentIndex < other.segmentIndex) return -1;\n      if (this.segmentIndex > other.segmentIndex) return 1;\n      if (this.coord.equals2D(other.coord)) return 0;\n      return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n    },\n    isEndPoint: function isEndPoint(maxSegmentIndex) {\n      if (this.segmentIndex === 0 && !this._isInterior) return true;\n      if (this.segmentIndex === maxSegmentIndex) return true;\n      return false;\n    },\n    isInterior: function isInterior() {\n      return this._isInterior;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return SegmentNode;\n    }\n  });\n\n  function SegmentNodeList() {\n    this._nodeMap = new TreeMap();\n    this._edge = null;\n    var edge = arguments[0];\n    this._edge = edge;\n  }\n  extend(SegmentNodeList.prototype, {\n    getSplitCoordinates: function getSplitCoordinates() {\n      var coordList = new CoordinateList();\n      this.addEndpoints();\n      var it = this.iterator();\n      var eiPrev = it.next();\n\n      while (it.hasNext()) {\n        var ei = it.next();\n        this.addEdgeCoordinates(eiPrev, ei, coordList);\n        eiPrev = ei;\n      }\n\n      return coordList.toCoordinateArray();\n    },\n    addCollapsedNodes: function addCollapsedNodes() {\n      var collapsedVertexIndexes = new ArrayList();\n      this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n      this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n\n      for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n        var vertexIndex = it.next().intValue();\n        this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n      }\n    },\n    print: function print(out) {\n      out.println(\"Intersections:\");\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var ei = it.next();\n        ei.print(out);\n      }\n    },\n    findCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n      for (var i = 0; i < this._edge.size() - 2; i++) {\n        var p0 = this._edge.getCoordinate(i);\n\n        var p1 = this._edge.getCoordinate(i + 1);\n\n        var p2 = this._edge.getCoordinate(i + 2);\n\n        if (p0.equals2D(p2)) {\n          collapsedVertexIndexes.add(new Integer(i + 1));\n        }\n      }\n    },\n    addEdgeCoordinates: function addEdgeCoordinates(ei0, ei1, coordList) {\n      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\n      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\n      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\n      if (!useIntPt1) {\n        npts--;\n      }\n      coordList.add(new Coordinate(ei0.coord), false);\n\n      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n        coordList.add(this._edge.getCoordinate(i));\n      }\n\n      if (useIntPt1) {\n        coordList.add(new Coordinate(ei1.coord));\n      }\n    },\n    iterator: function iterator() {\n      return this._nodeMap.values().iterator();\n    },\n    addSplitEdges: function addSplitEdges(edgeList) {\n      this.addEndpoints();\n      this.addCollapsedNodes();\n      var it = this.iterator();\n      var eiPrev = it.next();\n\n      while (it.hasNext()) {\n        var ei = it.next();\n        var newEdge = this.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n      }\n    },\n    findCollapseIndex: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n      if (!ei0.coord.equals2D(ei1.coord)) return false;\n      var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n\n      if (!ei1.isInterior()) {\n        numVerticesBetween--;\n      }\n\n      if (numVerticesBetween === 1) {\n        collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n        return true;\n      }\n\n      return false;\n    },\n    findCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n      var collapsedVertexIndex = new Array(1).fill(null);\n      var it = this.iterator();\n      var eiPrev = it.next();\n\n      while (it.hasNext()) {\n        var ei = it.next();\n        var isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n        if (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n        eiPrev = ei;\n      }\n    },\n    getEdge: function getEdge() {\n      return this._edge;\n    },\n    addEndpoints: function addEndpoints() {\n      var maxSegIndex = this._edge.size() - 1;\n      this.add(this._edge.getCoordinate(0), 0);\n      this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n    },\n    createSplitEdge: function createSplitEdge(ei0, ei1) {\n      var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\n      var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\n      var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\n      if (!useIntPt1) {\n        npts--;\n      }\n\n      var pts = new Array(npts).fill(null);\n      var ipt = 0;\n      pts[ipt++] = new Coordinate(ei0.coord);\n\n      for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n        pts[ipt++] = this._edge.getCoordinate(i);\n      }\n\n      if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n      return new NodedSegmentString(pts, this._edge.getData());\n    },\n    add: function add(intPt, segmentIndex) {\n      var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n\n      var ei = this._nodeMap.get(eiNew);\n\n      if (ei !== null) {\n        Assert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n        return ei;\n      }\n\n      this._nodeMap.put(eiNew, eiNew);\n\n      return eiNew;\n    },\n    checkSplitEdgesCorrectness: function checkSplitEdgesCorrectness(splitEdges) {\n      var edgePts = this._edge.getCoordinates();\n\n      var split0 = splitEdges.get(0);\n      var pt0 = split0.getCoordinate(0);\n      if (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n      var splitn = splitEdges.get(splitEdges.size() - 1);\n      var splitnPts = splitn.getCoordinates();\n      var ptn = splitnPts[splitnPts.length - 1];\n      if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentNodeList;\n    }\n  });\n\n  function NodeVertexIterator() {\n    this._nodeList = null;\n    this._edge = null;\n    this._nodeIt = null;\n    this._currNode = null;\n    this._nextNode = null;\n    this._currSegIndex = 0;\n    var nodeList = arguments[0];\n    this._nodeList = nodeList;\n    this._edge = nodeList.getEdge();\n    this._nodeIt = nodeList.iterator();\n    this.readNextNode();\n  }\n\n  extend(NodeVertexIterator.prototype, {\n    next: function next() {\n      if (this._currNode === null) {\n        this._currNode = this._nextNode;\n        this._currSegIndex = this._currNode.segmentIndex;\n        this.readNextNode();\n        return this._currNode;\n      }\n\n      if (this._nextNode === null) return null;\n\n      if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n        this._currNode = this._nextNode;\n        this._currSegIndex = this._currNode.segmentIndex;\n        this.readNextNode();\n        return this._currNode;\n      }\n\n      if (this._nextNode.segmentIndex > this._currNode.segmentIndex) ;\n\n      return null;\n    },\n    remove: function remove() {\n      throw new UnsupportedOperationException(this.getClass().getName());\n    },\n    hasNext: function hasNext() {\n      if (this._nextNode === null) return false;\n      return true;\n    },\n    readNextNode: function readNextNode() {\n      if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();else this._nextNode = null;\n    },\n    interfaces_: function interfaces_() {\n      return [Iterator];\n    },\n    getClass: function getClass() {\n      return NodeVertexIterator;\n    }\n  });\n\n  function Octant() {}\n  extend(Octant.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Octant;\n    }\n  });\n\n  Octant.octant = function () {\n    if (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n      var _dx = arguments[0],\n          _dy = arguments[1];\n      if (_dx === 0.0 && _dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + _dx + \", \" + _dy + \" )\");\n      var adx = Math.abs(_dx);\n      var ady = Math.abs(_dy);\n\n      if (_dx >= 0) {\n        if (_dy >= 0) {\n          if (adx >= ady) return 0;else return 1;\n        } else {\n          if (adx >= ady) return 7;else return 6;\n        }\n      } else {\n        if (_dy >= 0) {\n          if (adx >= ady) return 3;else return 2;\n        } else {\n          if (adx >= ady) return 4;else return 5;\n        }\n      }\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      var dx = p1.x - p0.x;\n      var dy = p1.y - p0.y;\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n      return Octant.octant(dx, dy);\n    }\n  };\n\n  function SegmentString() {}\n  extend(SegmentString.prototype, {\n    getCoordinates: function getCoordinates() {},\n    size: function size() {},\n    getCoordinate: function getCoordinate(i) {},\n    isClosed: function isClosed() {},\n    setData: function setData(data) {},\n    getData: function getData() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentString;\n    }\n  });\n\n  function NodableSegmentString() {}\n  extend(NodableSegmentString.prototype, {\n    addIntersection: function addIntersection(intPt, segmentIndex) {},\n    interfaces_: function interfaces_() {\n      return [SegmentString];\n    },\n    getClass: function getClass() {\n      return NodableSegmentString;\n    }\n  });\n\n  function NodedSegmentString() {\n    this._nodeList = new SegmentNodeList(this);\n    this._pts = null;\n    this._data = null;\n    var pts = arguments[0],\n        data = arguments[1];\n    this._pts = pts;\n    this._data = data;\n  }\n  extend(NodedSegmentString.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this._pts;\n    },\n    size: function size() {\n      return this._pts.length;\n    },\n    getCoordinate: function getCoordinate(i) {\n      return this._pts[i];\n    },\n    isClosed: function isClosed() {\n      return this._pts[0].equals(this._pts[this._pts.length - 1]);\n    },\n    getSegmentOctant: function getSegmentOctant(index) {\n      if (index === this._pts.length - 1) return -1;\n      return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n    },\n    setData: function setData(data) {\n      this._data = data;\n    },\n    safeOctant: function safeOctant(p0, p1) {\n      if (p0.equals2D(p1)) return 0;\n      return Octant.octant(p0, p1);\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    addIntersection: function addIntersection() {\n      if (arguments.length === 2) {\n        var _intPt = arguments[0],\n            segmentIndex = arguments[1];\n        this.addIntersectionNode(_intPt, segmentIndex);\n      } else if (arguments.length === 4) {\n        var li = arguments[0],\n            _segmentIndex = arguments[1],\n            intIndex = arguments[3];\n        var intPt = new Coordinate(li.getIntersection(intIndex));\n        this.addIntersection(intPt, _segmentIndex);\n      }\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n    },\n    getNodeList: function getNodeList() {\n      return this._nodeList;\n    },\n    addIntersectionNode: function addIntersectionNode(intPt, segmentIndex) {\n      var normalizedSegmentIndex = segmentIndex;\n      var nextSegIndex = normalizedSegmentIndex + 1;\n\n      if (nextSegIndex < this._pts.length) {\n        var nextPt = this._pts[nextSegIndex];\n\n        if (intPt.equals2D(nextPt)) {\n          normalizedSegmentIndex = nextSegIndex;\n        }\n      }\n\n      var ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n\n      return ei;\n    },\n    addIntersections: function addIntersections(li, segmentIndex, geomIndex) {\n      for (var i = 0; i < li.getIntersectionNum(); i++) {\n        this.addIntersection(li, segmentIndex, geomIndex, i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [NodableSegmentString];\n    },\n    getClass: function getClass() {\n      return NodedSegmentString;\n    }\n  });\n\n  NodedSegmentString.getNodedSubstrings = function () {\n    if (arguments.length === 1) {\n      var segStrings = arguments[0];\n      var resultEdgelist = new ArrayList();\n      NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n      return resultEdgelist;\n    } else if (arguments.length === 2) {\n      var _segStrings = arguments[0],\n          _resultEdgelist = arguments[1];\n\n      for (var i = _segStrings.iterator(); i.hasNext();) {\n        var ss = i.next();\n        ss.getNodeList().addSplitEdges(_resultEdgelist);\n      }\n    }\n  };\n\n  function MonotoneChainOverlapAction() {\n    this._overlapSeg1 = new LineSegment();\n    this._overlapSeg2 = new LineSegment();\n  }\n  extend(MonotoneChainOverlapAction.prototype, {\n    overlap: function overlap() {\n      if (arguments.length === 2) ; else if (arguments.length === 4) {\n        var mc1 = arguments[0],\n            start1 = arguments[1],\n            mc2 = arguments[2],\n            start2 = arguments[3];\n        mc1.getLineSegment(start1, this._overlapSeg1);\n        mc2.getLineSegment(start2, this._overlapSeg2);\n        this.overlap(this._overlapSeg1, this._overlapSeg2);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MonotoneChainOverlapAction;\n    }\n  });\n\n  function Noder() {}\n  extend(Noder.prototype, {\n    computeNodes: function computeNodes(segStrings) {},\n    getNodedSubstrings: function getNodedSubstrings() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Noder;\n    }\n  });\n\n  function SinglePassNoder() {\n    this._segInt = null;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var segInt = arguments[0];\n      this.setSegmentIntersector(segInt);\n    }\n  }\n  extend(SinglePassNoder.prototype, {\n    setSegmentIntersector: function setSegmentIntersector(segInt) {\n      this._segInt = segInt;\n    },\n    interfaces_: function interfaces_() {\n      return [Noder];\n    },\n    getClass: function getClass() {\n      return SinglePassNoder;\n    }\n  });\n\n  function MCIndexNoder() {\n    this._monoChains = new ArrayList();\n    this._index = new STRtree();\n    this._idCounter = 0;\n    this._nodedSegStrings = null;\n    this._nOverlaps = 0;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var si = arguments[0];\n      SinglePassNoder.call(this, si);\n    }\n  }\n  inherits(MCIndexNoder, SinglePassNoder);\n  extend(MCIndexNoder.prototype, {\n    getMonotoneChains: function getMonotoneChains() {\n      return this._monoChains;\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n    },\n    getIndex: function getIndex() {\n      return this._index;\n    },\n    add: function add(segStr) {\n      var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n\n      for (var i = segChains.iterator(); i.hasNext();) {\n        var mc = i.next();\n        mc.setId(this._idCounter++);\n\n        this._index.insert(mc.getEnvelope(), mc);\n\n        this._monoChains.add(mc);\n      }\n    },\n    computeNodes: function computeNodes(inputSegStrings) {\n      this._nodedSegStrings = inputSegStrings;\n\n      for (var i = inputSegStrings.iterator(); i.hasNext();) {\n        this.add(i.next());\n      }\n\n      this.intersectChains();\n    },\n    intersectChains: function intersectChains() {\n      var overlapAction = new SegmentOverlapAction(this._segInt);\n\n      for (var i = this._monoChains.iterator(); i.hasNext();) {\n        var queryChain = i.next();\n\n        var overlapChains = this._index.query(queryChain.getEnvelope());\n\n        for (var j = overlapChains.iterator(); j.hasNext();) {\n          var testChain = j.next();\n\n          if (testChain.getId() > queryChain.getId()) {\n            queryChain.computeOverlaps(testChain, overlapAction);\n            this._nOverlaps++;\n          }\n\n          if (this._segInt.isDone()) return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MCIndexNoder;\n    }\n  });\n\n  function SegmentOverlapAction() {\n    MonotoneChainOverlapAction.apply(this);\n    this._si = null;\n    var si = arguments[0];\n    this._si = si;\n  }\n\n  inherits(SegmentOverlapAction, MonotoneChainOverlapAction);\n  extend(SegmentOverlapAction.prototype, {\n    overlap: function overlap() {\n      if (arguments.length === 4) {\n        var mc1 = arguments[0],\n            start1 = arguments[1],\n            mc2 = arguments[2],\n            start2 = arguments[3];\n        var ss1 = mc1.getContext();\n        var ss2 = mc2.getContext();\n\n        this._si.processIntersections(ss1, start1, ss2, start2);\n      } else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentOverlapAction;\n    }\n  });\n  MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\n  function ScaledNoder() {\n    this._noder = null;\n    this._scaleFactor = null;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._isScaled = false;\n\n    if (arguments.length === 2) {\n      var noder = arguments[0],\n          scaleFactor = arguments[1];\n      ScaledNoder.call(this, noder, scaleFactor, 0, 0);\n    } else if (arguments.length === 4) {\n      var _noder = arguments[0],\n          _scaleFactor = arguments[1];\n      this._noder = _noder;\n      this._scaleFactor = _scaleFactor;\n      this._isScaled = !this.isIntegerPrecision();\n    }\n  }\n  extend(ScaledNoder.prototype, {\n    rescale: function rescale() {\n      if (hasInterface(arguments[0], Collection)) {\n        var segStrings = arguments[0];\n\n        for (var i = segStrings.iterator(); i.hasNext();) {\n          var ss = i.next();\n          this.rescale(ss.getCoordinates());\n        }\n      } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n        var p0 = null;\n        var p1 = null;\n\n        if (pts.length === 2) {\n          p0 = new Coordinate(pts[0]);\n          p1 = new Coordinate(pts[1]);\n        }\n\n        for (var i = 0; i < pts.length; i++) {\n          pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n          pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n        }\n\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n          System.out.println(pts);\n        }\n      }\n    },\n    scale: function scale() {\n      if (hasInterface(arguments[0], Collection)) {\n        var segStrings = arguments[0];\n        var nodedSegmentStrings = new ArrayList(segStrings.size());\n\n        for (var i = segStrings.iterator(); i.hasNext();) {\n          var ss = i.next();\n          nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n        }\n\n        return nodedSegmentStrings;\n      } else if (arguments[0] instanceof Array) {\n        var pts = arguments[0];\n        var roundPts = new Array(pts.length).fill(null);\n\n        for (var i = 0; i < pts.length; i++) {\n          roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);\n        }\n\n        var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n        return roundPtsNoDup;\n      }\n    },\n    isIntegerPrecision: function isIntegerPrecision() {\n      return this._scaleFactor === 1.0;\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      var splitSS = this._noder.getNodedSubstrings();\n\n      if (this._isScaled) this.rescale(splitSS);\n      return splitSS;\n    },\n    computeNodes: function computeNodes(inputSegStrings) {\n      var intSegStrings = inputSegStrings;\n      if (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n\n      this._noder.computeNodes(intSegStrings);\n    },\n    interfaces_: function interfaces_() {\n      return [Noder];\n    },\n    getClass: function getClass() {\n      return ScaledNoder;\n    }\n  });\n\n\n\n  var noding = /*#__PURE__*/Object.freeze({\n    MCIndexNoder: MCIndexNoder,\n    ScaledNoder: ScaledNoder,\n    SegmentString: SegmentString\n  });\n\n  function IsSimpleOp() {\n    this._inputGeom = null;\n    this._isClosedEndpointsInInterior = true;\n    this._nonSimpleLocation = null;\n\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      this._inputGeom = geom;\n    } else if (arguments.length === 2) {\n      var _geom = arguments[0],\n          boundaryNodeRule = arguments[1];\n      this._inputGeom = _geom;\n      this._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n    }\n  }\n  extend(IsSimpleOp.prototype, {\n    isSimpleMultiPoint: function isSimpleMultiPoint(mp) {\n      if (mp.isEmpty()) return true;\n      var points = new TreeSet();\n\n      for (var i = 0; i < mp.getNumGeometries(); i++) {\n        var pt = mp.getGeometryN(i);\n        var p = pt.getCoordinate();\n\n        if (points.contains(p)) {\n          this._nonSimpleLocation = p;\n          return false;\n        }\n\n        points.add(p);\n      }\n\n      return true;\n    },\n    isSimplePolygonal: function isSimplePolygonal(geom) {\n      var rings = LinearComponentExtracter.getLines(geom);\n\n      for (var i = rings.iterator(); i.hasNext();) {\n        var ring = i.next();\n        if (!this.isSimpleLinearGeometry(ring)) return false;\n      }\n\n      return true;\n    },\n    hasClosedEndpointIntersection: function hasClosedEndpointIntersection(graph) {\n      var endPoints = new TreeMap();\n\n      for (var i = graph.getEdgeIterator(); i.hasNext();) {\n        var e = i.next();\n        var maxSegmentIndex = e.getMaximumSegmentIndex();\n        var isClosed = e.isClosed();\n        var p0 = e.getCoordinate(0);\n        this.addEndpoint(endPoints, p0, isClosed);\n        var p1 = e.getCoordinate(e.getNumPoints() - 1);\n        this.addEndpoint(endPoints, p1, isClosed);\n      }\n\n      for (var i = endPoints.values().iterator(); i.hasNext();) {\n        var eiInfo = i.next();\n\n        if (eiInfo.isClosed && eiInfo.degree !== 2) {\n          this._nonSimpleLocation = eiInfo.getCoordinate();\n          return true;\n        }\n      }\n\n      return false;\n    },\n    getNonSimpleLocation: function getNonSimpleLocation() {\n      return this._nonSimpleLocation;\n    },\n    isSimpleLinearGeometry: function isSimpleLinearGeometry(geom) {\n      if (geom.isEmpty()) return true;\n      var graph = new GeometryGraph(0, geom);\n      var li = new RobustLineIntersector();\n      var si = graph.computeSelfNodes(li, true);\n      if (!si.hasIntersection()) return true;\n\n      if (si.hasProperIntersection()) {\n        this._nonSimpleLocation = si.getProperIntersectionPoint();\n        return false;\n      }\n\n      if (this.hasNonEndpointIntersection(graph)) return false;\n\n      if (this._isClosedEndpointsInInterior) {\n        if (this.hasClosedEndpointIntersection(graph)) return false;\n      }\n\n      return true;\n    },\n    hasNonEndpointIntersection: function hasNonEndpointIntersection(graph) {\n      for (var i = graph.getEdgeIterator(); i.hasNext();) {\n        var e = i.next();\n        var maxSegmentIndex = e.getMaximumSegmentIndex();\n\n        for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          var ei = eiIt.next();\n\n          if (!ei.isEndPoint(maxSegmentIndex)) {\n            this._nonSimpleLocation = ei.getCoordinate();\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    addEndpoint: function addEndpoint(endPoints, p, isClosed) {\n      var eiInfo = endPoints.get(p);\n\n      if (eiInfo === null) {\n        eiInfo = new EndpointInfo(p);\n        endPoints.put(p, eiInfo);\n      }\n\n      eiInfo.addEndpoint(isClosed);\n    },\n    computeSimple: function computeSimple(geom) {\n      this._nonSimpleLocation = null;\n      if (geom.isEmpty()) return true;\n      if (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n      if (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n      if (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n      if (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n      if (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n      return true;\n    },\n    isSimple: function isSimple() {\n      this._nonSimpleLocation = null;\n      return this.computeSimple(this._inputGeom);\n    },\n    isSimpleGeometryCollection: function isSimpleGeometryCollection(geom) {\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var comp = geom.getGeometryN(i);\n        if (!this.computeSimple(comp)) return false;\n      }\n\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IsSimpleOp;\n    }\n  });\n\n  IsSimpleOp.isSimple = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      var op = new IsSimpleOp(geom);\n      return op.isSimple();\n    } else if (arguments.length === 2) {\n      var _geom2 = arguments[0],\n          boundaryNodeRule = arguments[1];\n      var op = new IsSimpleOp(_geom2, boundaryNodeRule);\n      return op.isSimple();\n    }\n  };\n\n  function EndpointInfo() {\n    this.pt = null;\n    this.isClosed = null;\n    this.degree = null;\n    var pt = arguments[0];\n    this.pt = pt;\n    this.isClosed = false;\n    this.degree = 0;\n  }\n\n  extend(EndpointInfo.prototype, {\n    addEndpoint: function addEndpoint(isClosed) {\n      this.degree++;\n      this.isClosed |= isClosed;\n    },\n    getCoordinate: function getCoordinate() {\n      return this.pt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EndpointInfo;\n    }\n  });\n  IsSimpleOp.EndpointInfo = EndpointInfo;\n\n  function BufferParameters() {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n    this._endCapStyle = BufferParameters.CAP_ROUND;\n    this._joinStyle = BufferParameters.JOIN_ROUND;\n    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n    this._isSingleSided = false;\n    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var quadrantSegments = arguments[0];\n      this.setQuadrantSegments(quadrantSegments);\n    } else if (arguments.length === 2) {\n      var _quadrantSegments = arguments[0],\n          endCapStyle = arguments[1];\n      this.setQuadrantSegments(_quadrantSegments);\n      this.setEndCapStyle(endCapStyle);\n    } else if (arguments.length === 4) {\n      var _quadrantSegments2 = arguments[0],\n          _endCapStyle = arguments[1],\n          joinStyle = arguments[2],\n          mitreLimit = arguments[3];\n      this.setQuadrantSegments(_quadrantSegments2);\n      this.setEndCapStyle(_endCapStyle);\n      this.setJoinStyle(joinStyle);\n      this.setMitreLimit(mitreLimit);\n    }\n  }\n  extend(BufferParameters.prototype, {\n    getEndCapStyle: function getEndCapStyle() {\n      return this._endCapStyle;\n    },\n    isSingleSided: function isSingleSided() {\n      return this._isSingleSided;\n    },\n    setQuadrantSegments: function setQuadrantSegments(quadSegs) {\n      this._quadrantSegments = quadSegs;\n      if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n\n      if (this._quadrantSegments < 0) {\n        this._joinStyle = BufferParameters.JOIN_MITRE;\n        this._mitreLimit = Math.abs(this._quadrantSegments);\n      }\n\n      if (quadSegs <= 0) {\n        this._quadrantSegments = 1;\n      }\n\n      if (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n      }\n    },\n    getJoinStyle: function getJoinStyle() {\n      return this._joinStyle;\n    },\n    setJoinStyle: function setJoinStyle(joinStyle) {\n      this._joinStyle = joinStyle;\n    },\n    setSimplifyFactor: function setSimplifyFactor(simplifyFactor) {\n      this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n    },\n    getSimplifyFactor: function getSimplifyFactor() {\n      return this._simplifyFactor;\n    },\n    getQuadrantSegments: function getQuadrantSegments() {\n      return this._quadrantSegments;\n    },\n    setEndCapStyle: function setEndCapStyle(endCapStyle) {\n      this._endCapStyle = endCapStyle;\n    },\n    getMitreLimit: function getMitreLimit() {\n      return this._mitreLimit;\n    },\n    setMitreLimit: function setMitreLimit(mitreLimit) {\n      this._mitreLimit = mitreLimit;\n    },\n    setSingleSided: function setSingleSided(isSingleSided) {\n      this._isSingleSided = isSingleSided;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BufferParameters;\n    }\n  });\n\n  BufferParameters.bufferDistanceError = function (quadSegs) {\n    var alpha = Math.PI / 2.0 / quadSegs;\n    return 1 - Math.cos(alpha / 2.0);\n  };\n\n  BufferParameters.CAP_ROUND = 1;\n  BufferParameters.CAP_FLAT = 2;\n  BufferParameters.CAP_SQUARE = 3;\n  BufferParameters.JOIN_ROUND = 1;\n  BufferParameters.JOIN_MITRE = 2;\n  BufferParameters.JOIN_BEVEL = 3;\n  BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\n  BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\n  BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\n  function RightmostEdgeFinder() {\n    this._minIndex = -1;\n    this._minCoord = null;\n    this._minDe = null;\n    this._orientedDe = null;\n  }\n  extend(RightmostEdgeFinder.prototype, {\n    getCoordinate: function getCoordinate() {\n      return this._minCoord;\n    },\n    getRightmostSide: function getRightmostSide(de, index) {\n      var side = this.getRightmostSideOfSegment(de, index);\n      if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n\n      if (side < 0) {\n        this._minCoord = null;\n        this.checkForRightmostCoordinate(de);\n      }\n\n      return side;\n    },\n    findRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {\n      var pts = this._minDe.getEdge().getCoordinates();\n\n      Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n      var pPrev = pts[this._minIndex - 1];\n      var pNext = pts[this._minIndex + 1];\n      var orientation = Orientation.index(this._minCoord, pNext, pPrev);\n      var usePrev = false;\n\n      if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) {\n        usePrev = true;\n      } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) {\n        usePrev = true;\n      }\n\n      if (usePrev) {\n        this._minIndex = this._minIndex - 1;\n      }\n    },\n    getRightmostSideOfSegment: function getRightmostSideOfSegment(de, i) {\n      var e = de.getEdge();\n      var coord = e.getCoordinates();\n      if (i < 0 || i + 1 >= coord.length) return -1;\n      if (coord[i].y === coord[i + 1].y) return -1;\n      var pos = Position.LEFT;\n      if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n      return pos;\n    },\n    getEdge: function getEdge() {\n      return this._orientedDe;\n    },\n    checkForRightmostCoordinate: function checkForRightmostCoordinate(de) {\n      var coord = de.getEdge().getCoordinates();\n\n      for (var i = 0; i < coord.length - 1; i++) {\n        if (this._minCoord === null || coord[i].x > this._minCoord.x) {\n          this._minDe = de;\n          this._minIndex = i;\n          this._minCoord = coord[i];\n        }\n      }\n    },\n    findRightmostEdgeAtNode: function findRightmostEdgeAtNode() {\n      var node = this._minDe.getNode();\n\n      var star = node.getEdges();\n      this._minDe = star.getRightmostEdge();\n\n      if (!this._minDe.isForward()) {\n        this._minDe = this._minDe.getSym();\n        this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n      }\n    },\n    findEdge: function findEdge(dirEdgeList) {\n      for (var i = dirEdgeList.iterator(); i.hasNext();) {\n        var de = i.next();\n        if (!de.isForward()) continue;\n        this.checkForRightmostCoordinate(de);\n      }\n\n      Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n\n      if (this._minIndex === 0) {\n        this.findRightmostEdgeAtNode();\n      } else {\n        this.findRightmostEdgeAtVertex();\n      }\n\n      this._orientedDe = this._minDe;\n      var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n\n      if (rightmostSide === Position.LEFT) {\n        this._orientedDe = this._minDe.getSym();\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RightmostEdgeFinder;\n    }\n  });\n\n  function LinkedList() {\n    this.array_ = [];\n  }\n\n  LinkedList.prototype.addLast = function (e) {\n    this.array_.push(e);\n  };\n\n  LinkedList.prototype.removeFirst = function () {\n    return this.array_.shift();\n  };\n\n  LinkedList.prototype.isEmpty = function () {\n    return this.array_.length === 0;\n  };\n\n  function BufferSubgraph() {\n    this._finder = null;\n    this._dirEdgeList = new ArrayList();\n    this._nodes = new ArrayList();\n    this._rightMostCoord = null;\n    this._env = null;\n    this._finder = new RightmostEdgeFinder();\n  }\n  extend(BufferSubgraph.prototype, {\n    clearVisitedEdges: function clearVisitedEdges() {\n      for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n        var de = it.next();\n        de.setVisited(false);\n      }\n    },\n    getRightmostCoordinate: function getRightmostCoordinate() {\n      return this._rightMostCoord;\n    },\n    computeNodeDepth: function computeNodeDepth(n) {\n      var startEdge = null;\n\n      for (var i = n.getEdges().iterator(); i.hasNext();) {\n        var de = i.next();\n\n        if (de.isVisited() || de.getSym().isVisited()) {\n          startEdge = de;\n          break;\n        }\n      }\n\n      if (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n      n.getEdges().computeDepths(startEdge);\n\n      for (var i = n.getEdges().iterator(); i.hasNext();) {\n        var de = i.next();\n        de.setVisited(true);\n        this.copySymDepths(de);\n      }\n    },\n    computeDepth: function computeDepth(outsideDepth) {\n      this.clearVisitedEdges();\n\n      var de = this._finder.getEdge();\n\n      var n = de.getNode();\n      var label = de.getLabel();\n      de.setEdgeDepths(Position.RIGHT, outsideDepth);\n      this.copySymDepths(de);\n      this.computeDepths(de);\n    },\n    create: function create(node) {\n      this.addReachable(node);\n\n      this._finder.findEdge(this._dirEdgeList);\n\n      this._rightMostCoord = this._finder.getCoordinate();\n    },\n    findResultEdges: function findResultEdges() {\n      for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n        var de = it.next();\n\n        if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n          de.setInResult(true);\n        }\n      }\n    },\n    computeDepths: function computeDepths(startEdge) {\n      var nodesVisited = new HashSet();\n      var nodeQueue = new LinkedList();\n      var startNode = startEdge.getNode();\n      nodeQueue.addLast(startNode);\n      nodesVisited.add(startNode);\n      startEdge.setVisited(true);\n\n      while (!nodeQueue.isEmpty()) {\n        var n = nodeQueue.removeFirst();\n        nodesVisited.add(n);\n        this.computeNodeDepth(n);\n\n        for (var i = n.getEdges().iterator(); i.hasNext();) {\n          var de = i.next();\n          var sym = de.getSym();\n          if (sym.isVisited()) continue;\n          var adjNode = sym.getNode();\n\n          if (!nodesVisited.contains(adjNode)) {\n            nodeQueue.addLast(adjNode);\n            nodesVisited.add(adjNode);\n          }\n        }\n      }\n    },\n    compareTo: function compareTo(o) {\n      var graph = o;\n\n      if (this._rightMostCoord.x < graph._rightMostCoord.x) {\n        return -1;\n      }\n\n      if (this._rightMostCoord.x > graph._rightMostCoord.x) {\n        return 1;\n      }\n\n      return 0;\n    },\n    getEnvelope: function getEnvelope() {\n      if (this._env === null) {\n        var edgeEnv = new Envelope();\n\n        for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n          var dirEdge = it.next();\n          var pts = dirEdge.getEdge().getCoordinates();\n\n          for (var i = 0; i < pts.length - 1; i++) {\n            edgeEnv.expandToInclude(pts[i]);\n          }\n        }\n\n        this._env = edgeEnv;\n      }\n\n      return this._env;\n    },\n    addReachable: function addReachable(startNode) {\n      var nodeStack = new Stack();\n      nodeStack.add(startNode);\n\n      while (!nodeStack.empty()) {\n        var node = nodeStack.pop();\n        this.add(node, nodeStack);\n      }\n    },\n    copySymDepths: function copySymDepths(de) {\n      var sym = de.getSym();\n      sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n      sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n    },\n    add: function add(node, nodeStack) {\n      node.setVisited(true);\n\n      this._nodes.add(node);\n\n      for (var i = node.getEdges().iterator(); i.hasNext();) {\n        var de = i.next();\n\n        this._dirEdgeList.add(de);\n\n        var sym = de.getSym();\n        var symNode = sym.getNode();\n        if (!symNode.isVisited()) nodeStack.push(symNode);\n      }\n    },\n    getNodes: function getNodes() {\n      return this._nodes;\n    },\n    getDirectedEdges: function getDirectedEdges() {\n      return this._dirEdgeList;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return BufferSubgraph;\n    }\n  });\n\n  function EdgeRing() {\n    this._startDe = null;\n    this._maxNodeDegree = -1;\n    this._edges = new ArrayList();\n    this._pts = new ArrayList();\n    this._label = new Label(Location.NONE);\n    this._ring = null;\n    this._isHole = null;\n    this._shell = null;\n    this._holes = new ArrayList();\n    this._geometryFactory = null;\n    var start = arguments[0],\n        geometryFactory = arguments[1];\n    this._geometryFactory = geometryFactory;\n    this.computePoints(start);\n    this.computeRing();\n  }\n  extend(EdgeRing.prototype, {\n    computeRing: function computeRing() {\n      if (this._ring !== null) return null;\n      var coord = new Array(this._pts.size()).fill(null);\n\n      for (var i = 0; i < this._pts.size(); i++) {\n        coord[i] = this._pts.get(i);\n      }\n\n      this._ring = this._geometryFactory.createLinearRing(coord);\n      this._isHole = Orientation.isCCW(this._ring.getCoordinates());\n    },\n    isIsolated: function isIsolated() {\n      return this._label.getGeometryCount() === 1;\n    },\n    computePoints: function computePoints(start) {\n      this._startDe = start;\n      var de = start;\n      var isFirstEdge = true;\n\n      do {\n        if (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n        if (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n\n        this._edges.add(de);\n\n        var label = de.getLabel();\n        Assert.isTrue(label.isArea());\n        this.mergeLabel(label);\n        this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n        isFirstEdge = false;\n        this.setEdgeRing(de, this);\n        de = this.getNext(de);\n      } while (de !== this._startDe);\n    },\n    getLinearRing: function getLinearRing() {\n      return this._ring;\n    },\n    getCoordinate: function getCoordinate(i) {\n      return this._pts.get(i);\n    },\n    computeMaxNodeDegree: function computeMaxNodeDegree() {\n      this._maxNodeDegree = 0;\n      var de = this._startDe;\n\n      do {\n        var node = de.getNode();\n        var degree = node.getEdges().getOutgoingDegree(this);\n        if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n        de = this.getNext(de);\n      } while (de !== this._startDe);\n\n      this._maxNodeDegree *= 2;\n    },\n    addPoints: function addPoints(edge, isForward, isFirstEdge) {\n      var edgePts = edge.getCoordinates();\n\n      if (isForward) {\n        var startIndex = 1;\n        if (isFirstEdge) startIndex = 0;\n\n        for (var i = startIndex; i < edgePts.length; i++) {\n          this._pts.add(edgePts[i]);\n        }\n      } else {\n        var startIndex = edgePts.length - 2;\n        if (isFirstEdge) startIndex = edgePts.length - 1;\n\n        for (var i = startIndex; i >= 0; i--) {\n          this._pts.add(edgePts[i]);\n        }\n      }\n    },\n    isHole: function isHole() {\n      return this._isHole;\n    },\n    setInResult: function setInResult() {\n      var de = this._startDe;\n\n      do {\n        de.getEdge().setInResult(true);\n        de = de.getNext();\n      } while (de !== this._startDe);\n    },\n    containsPoint: function containsPoint(p) {\n      var shell = this.getLinearRing();\n      var env = shell.getEnvelopeInternal();\n      if (!env.contains(p)) return false;\n      if (!PointLocation.isInRing(p, shell.getCoordinates())) return false;\n\n      for (var i = this._holes.iterator(); i.hasNext();) {\n        var hole = i.next();\n        if (hole.containsPoint(p)) return false;\n      }\n\n      return true;\n    },\n    addHole: function addHole(ring) {\n      this._holes.add(ring);\n    },\n    isShell: function isShell() {\n      return this._shell === null;\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    getEdges: function getEdges() {\n      return this._edges;\n    },\n    getMaxNodeDegree: function getMaxNodeDegree() {\n      if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n      return this._maxNodeDegree;\n    },\n    getShell: function getShell() {\n      return this._shell;\n    },\n    mergeLabel: function mergeLabel() {\n      if (arguments.length === 1) {\n        var deLabel = arguments[0];\n        this.mergeLabel(deLabel, 0);\n        this.mergeLabel(deLabel, 1);\n      } else if (arguments.length === 2) {\n        var _deLabel = arguments[0],\n            geomIndex = arguments[1];\n\n        var loc = _deLabel.getLocation(geomIndex, Position.RIGHT);\n\n        if (loc === Location.NONE) return null;\n\n        if (this._label.getLocation(geomIndex) === Location.NONE) {\n          this._label.setLocation(geomIndex, loc);\n\n          return null;\n        }\n      }\n    },\n    setShell: function setShell(shell) {\n      this._shell = shell;\n      if (shell !== null) shell.addHole(this);\n    },\n    toPolygon: function toPolygon(geometryFactory) {\n      var holeLR = new Array(this._holes.size()).fill(null);\n\n      for (var i = 0; i < this._holes.size(); i++) {\n        holeLR[i] = this._holes.get(i).getLinearRing();\n      }\n\n      var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n      return poly;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeRing;\n    }\n  });\n\n  function MinimalEdgeRing() {\n    var start = arguments[0],\n        geometryFactory = arguments[1];\n    EdgeRing.call(this, start, geometryFactory);\n  }\n  inherits(MinimalEdgeRing, EdgeRing);\n  extend(MinimalEdgeRing.prototype, {\n    setEdgeRing: function setEdgeRing(de, er) {\n      de.setMinEdgeRing(er);\n    },\n    getNext: function getNext(de) {\n      return de.getNextMin();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MinimalEdgeRing;\n    }\n  });\n\n  function MaximalEdgeRing() {\n    var start = arguments[0],\n        geometryFactory = arguments[1];\n    EdgeRing.call(this, start, geometryFactory);\n  }\n  inherits(MaximalEdgeRing, EdgeRing);\n  extend(MaximalEdgeRing.prototype, {\n    buildMinimalRings: function buildMinimalRings() {\n      var minEdgeRings = new ArrayList();\n      var de = this._startDe;\n\n      do {\n        if (de.getMinEdgeRing() === null) {\n          var minEr = new MinimalEdgeRing(de, this._geometryFactory);\n          minEdgeRings.add(minEr);\n        }\n\n        de = de.getNext();\n      } while (de !== this._startDe);\n\n      return minEdgeRings;\n    },\n    setEdgeRing: function setEdgeRing(de, er) {\n      de.setEdgeRing(er);\n    },\n    linkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {\n      var de = this._startDe;\n\n      do {\n        var node = de.getNode();\n        node.getEdges().linkMinimalDirectedEdges(this);\n        de = de.getNext();\n      } while (de !== this._startDe);\n    },\n    getNext: function getNext(de) {\n      return de.getNext();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MaximalEdgeRing;\n    }\n  });\n\n  function PolygonBuilder() {\n    this._geometryFactory = null;\n    this._shellList = new ArrayList();\n    var geometryFactory = arguments[0];\n    this._geometryFactory = geometryFactory;\n  }\n  extend(PolygonBuilder.prototype, {\n    sortShellsAndHoles: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n      for (var it = edgeRings.iterator(); it.hasNext();) {\n        var er = it.next();\n\n        if (er.isHole()) {\n          freeHoleList.add(er);\n        } else {\n          shellList.add(er);\n        }\n      }\n    },\n    computePolygons: function computePolygons(shellList) {\n      var resultPolyList = new ArrayList();\n\n      for (var it = shellList.iterator(); it.hasNext();) {\n        var er = it.next();\n        var poly = er.toPolygon(this._geometryFactory);\n        resultPolyList.add(poly);\n      }\n\n      return resultPolyList;\n    },\n    placeFreeHoles: function placeFreeHoles(shellList, freeHoleList) {\n      for (var it = freeHoleList.iterator(); it.hasNext();) {\n        var hole = it.next();\n\n        if (hole.getShell() === null) {\n          var shell = this.findEdgeRingContaining(hole, shellList);\n          if (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n          hole.setShell(shell);\n        }\n      }\n    },\n    buildMinimalEdgeRings: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n      var edgeRings = new ArrayList();\n\n      for (var it = maxEdgeRings.iterator(); it.hasNext();) {\n        var er = it.next();\n\n        if (er.getMaxNodeDegree() > 2) {\n          er.linkDirectedEdgesForMinimalEdgeRings();\n          var minEdgeRings = er.buildMinimalRings();\n          var shell = this.findShell(minEdgeRings);\n\n          if (shell !== null) {\n            this.placePolygonHoles(shell, minEdgeRings);\n            shellList.add(shell);\n          } else {\n            freeHoleList.addAll(minEdgeRings);\n          }\n        } else {\n          edgeRings.add(er);\n        }\n      }\n\n      return edgeRings;\n    },\n    containsPoint: function containsPoint(p) {\n      for (var it = this._shellList.iterator(); it.hasNext();) {\n        var er = it.next();\n        if (er.containsPoint(p)) return true;\n      }\n\n      return false;\n    },\n    buildMaximalEdgeRings: function buildMaximalEdgeRings(dirEdges) {\n      var maxEdgeRings = new ArrayList();\n\n      for (var it = dirEdges.iterator(); it.hasNext();) {\n        var de = it.next();\n\n        if (de.isInResult() && de.getLabel().isArea()) {\n          if (de.getEdgeRing() === null) {\n            var er = new MaximalEdgeRing(de, this._geometryFactory);\n            maxEdgeRings.add(er);\n            er.setInResult();\n          }\n        }\n      }\n\n      return maxEdgeRings;\n    },\n    placePolygonHoles: function placePolygonHoles(shell, minEdgeRings) {\n      for (var it = minEdgeRings.iterator(); it.hasNext();) {\n        var er = it.next();\n\n        if (er.isHole()) {\n          er.setShell(shell);\n        }\n      }\n    },\n    getPolygons: function getPolygons() {\n      var resultPolyList = this.computePolygons(this._shellList);\n      return resultPolyList;\n    },\n    findEdgeRingContaining: function findEdgeRingContaining(testEr, shellList) {\n      var testRing = testEr.getLinearRing();\n      var testEnv = testRing.getEnvelopeInternal();\n      var testPt = testRing.getCoordinateN(0);\n      var minShell = null;\n      var minEnv = null;\n\n      for (var it = shellList.iterator(); it.hasNext();) {\n        var tryShell = it.next();\n        var tryRing = tryShell.getLinearRing();\n        var tryEnv = tryRing.getEnvelopeInternal();\n        if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n        var isContained = false;\n        if (tryEnv.contains(testEnv) && PointLocation.isInRing(testPt, tryRing.getCoordinates())) isContained = true;\n\n        if (isContained) {\n          if (minShell === null || minEnv.contains(tryEnv)) {\n            minShell = tryShell;\n          }\n        }\n      }\n\n      return minShell;\n    },\n    findShell: function findShell(minEdgeRings) {\n      var shellCount = 0;\n      var shell = null;\n\n      for (var it = minEdgeRings.iterator(); it.hasNext();) {\n        var er = it.next();\n\n        if (!er.isHole()) {\n          shell = er;\n          shellCount++;\n        }\n      }\n\n      Assert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n      return shell;\n    },\n    add: function add() {\n      if (arguments.length === 1) {\n        var graph = arguments[0];\n        this.add(graph.getEdgeEnds(), graph.getNodes());\n      } else if (arguments.length === 2) {\n        var dirEdges = arguments[0],\n            nodes = arguments[1];\n        PlanarGraph.linkResultDirectedEdges(nodes);\n        var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n        var freeHoleList = new ArrayList();\n        var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n        this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n        this.placeFreeHoles(this._shellList, freeHoleList);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PolygonBuilder;\n    }\n  });\n\n  function BufferInputLineSimplifier() {\n    this._inputLine = null;\n    this._distanceTol = null;\n    this._isDeleted = null;\n    this._angleOrientation = Orientation.COUNTERCLOCKWISE;\n    var inputLine = arguments[0];\n    this._inputLine = inputLine;\n  }\n  extend(BufferInputLineSimplifier.prototype, {\n    isDeletable: function isDeletable(i0, i1, i2, distanceTol) {\n      var p0 = this._inputLine[i0];\n      var p1 = this._inputLine[i1];\n      var p2 = this._inputLine[i2];\n      if (!this.isConcave(p0, p1, p2)) return false;\n      if (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n      return this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n    },\n    deleteShallowConcavities: function deleteShallowConcavities() {\n      var index = 1;\n      var maxIndex = this._inputLine.length - 1;\n      var midIndex = this.findNextNonDeletedIndex(index);\n      var lastIndex = this.findNextNonDeletedIndex(midIndex);\n      var isChanged = false;\n\n      while (lastIndex < this._inputLine.length) {\n        var isMiddleVertexDeleted = false;\n\n        if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n          this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n          isMiddleVertexDeleted = true;\n          isChanged = true;\n        }\n\n        if (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;\n        midIndex = this.findNextNonDeletedIndex(index);\n        lastIndex = this.findNextNonDeletedIndex(midIndex);\n      }\n\n      return isChanged;\n    },\n    isShallowConcavity: function isShallowConcavity(p0, p1, p2, distanceTol) {\n      var orientation = Orientation.index(p0, p1, p2);\n      var isAngleToSimplify = orientation === this._angleOrientation;\n      if (!isAngleToSimplify) return false;\n      var dist = Distance.pointToSegment(p1, p0, p2);\n      return dist < distanceTol;\n    },\n    isShallowSampled: function isShallowSampled(p0, p2, i0, i2, distanceTol) {\n      var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n      if (inc <= 0) inc = 1;\n\n      for (var i = i0; i < i2; i += inc) {\n        if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n      }\n\n      return true;\n    },\n    isConcave: function isConcave(p0, p1, p2) {\n      var orientation = Orientation.index(p0, p1, p2);\n      var isConcave = orientation === this._angleOrientation;\n      return isConcave;\n    },\n    simplify: function simplify(distanceTol) {\n      this._distanceTol = Math.abs(distanceTol);\n      if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE;\n      this._isDeleted = new Array(this._inputLine.length).fill(null);\n      var isChanged = false;\n\n      do {\n        isChanged = this.deleteShallowConcavities();\n      } while (isChanged);\n\n      return this.collapseLine();\n    },\n    findNextNonDeletedIndex: function findNextNonDeletedIndex(index) {\n      var next = index + 1;\n\n      while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {\n        next++;\n      }\n\n      return next;\n    },\n    isShallow: function isShallow(p0, p1, p2, distanceTol) {\n      var dist = Distance.pointToSegment(p1, p0, p2);\n      return dist < distanceTol;\n    },\n    collapseLine: function collapseLine() {\n      var coordList = new CoordinateList();\n\n      for (var i = 0; i < this._inputLine.length; i++) {\n        if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n      }\n\n      return coordList.toCoordinateArray();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BufferInputLineSimplifier;\n    }\n  });\n\n  BufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n    var simp = new BufferInputLineSimplifier(inputLine);\n    return simp.simplify(distanceTol);\n  };\n\n  BufferInputLineSimplifier.INIT = 0;\n  BufferInputLineSimplifier.DELETE = 1;\n  BufferInputLineSimplifier.KEEP = 1;\n  BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\n  function OffsetSegmentString() {\n    this._ptList = null;\n    this._precisionModel = null;\n    this._minimimVertexDistance = 0.0;\n    this._ptList = new ArrayList();\n  }\n  extend(OffsetSegmentString.prototype, {\n    getCoordinates: function getCoordinates() {\n      var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n\n      return coord;\n    },\n    setPrecisionModel: function setPrecisionModel(precisionModel) {\n      this._precisionModel = precisionModel;\n    },\n    addPt: function addPt(pt) {\n      var bufPt = new Coordinate(pt);\n\n      this._precisionModel.makePrecise(bufPt);\n\n      if (this.isRedundant(bufPt)) return null;\n\n      this._ptList.add(bufPt);\n    },\n    reverse: function reverse() {},\n    addPts: function addPts(pt, isForward) {\n      if (isForward) {\n        for (var i = 0; i < pt.length; i++) {\n          this.addPt(pt[i]);\n        }\n      } else {\n        for (var i = pt.length - 1; i >= 0; i--) {\n          this.addPt(pt[i]);\n        }\n      }\n    },\n    isRedundant: function isRedundant(pt) {\n      if (this._ptList.size() < 1) return false;\n\n      var lastPt = this._ptList.get(this._ptList.size() - 1);\n\n      var ptDist = pt.distance(lastPt);\n      if (ptDist < this._minimimVertexDistance) return true;\n      return false;\n    },\n    toString: function toString() {\n      var fact = new GeometryFactory();\n      var line = fact.createLineString(this.getCoordinates());\n      return line.toString();\n    },\n    closeRing: function closeRing() {\n      if (this._ptList.size() < 1) return null;\n      var startPt = new Coordinate(this._ptList.get(0));\n\n      var lastPt = this._ptList.get(this._ptList.size() - 1);\n\n      var last2Pt = null;\n      if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);\n      if (startPt.equals(lastPt)) return null;\n\n      this._ptList.add(startPt);\n    },\n    setMinimumVertexDistance: function setMinimumVertexDistance(minimimVertexDistance) {\n      this._minimimVertexDistance = minimimVertexDistance;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OffsetSegmentString;\n    }\n  });\n  OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\n  function OffsetSegmentGenerator() {\n    this._maxCurveSegmentError = 0.0;\n    this._filletAngleQuantum = null;\n    this._closingSegLengthFactor = 1;\n    this._segList = null;\n    this._distance = 0.0;\n    this._precisionModel = null;\n    this._bufParams = null;\n    this._li = null;\n    this._s0 = null;\n    this._s1 = null;\n    this._s2 = null;\n    this._seg0 = new LineSegment();\n    this._seg1 = new LineSegment();\n    this._offset0 = new LineSegment();\n    this._offset1 = new LineSegment();\n    this._side = 0;\n    this._hasNarrowConcaveAngle = false;\n    var precisionModel = arguments[0],\n        bufParams = arguments[1],\n        distance = arguments[2];\n    this._precisionModel = precisionModel;\n    this._bufParams = bufParams;\n    this._li = new RobustLineIntersector();\n    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n    this.init(distance);\n  }\n  extend(OffsetSegmentGenerator.prototype, {\n    addNextSegment: function addNextSegment(p, addStartPoint) {\n      this._s0 = this._s1;\n      this._s1 = this._s2;\n      this._s2 = p;\n\n      this._seg0.setCoordinates(this._s0, this._s1);\n\n      this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n\n      this._seg1.setCoordinates(this._s1, this._s2);\n\n      this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n      if (this._s1.equals(this._s2)) return null;\n      var orientation = Orientation.index(this._s0, this._s1, this._s2);\n      var outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n\n      if (orientation === 0) {\n        this.addCollinear(addStartPoint);\n      } else if (outsideTurn) {\n        this.addOutsideTurn(orientation, addStartPoint);\n      } else {\n        this.addInsideTurn(orientation, addStartPoint);\n      }\n    },\n    addLineEndCap: function addLineEndCap(p0, p1) {\n      var seg = new LineSegment(p0, p1);\n      var offsetL = new LineSegment();\n      this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n      var offsetR = new LineSegment();\n      this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n      var dx = p1.x - p0.x;\n      var dy = p1.y - p0.y;\n      var angle = Math.atan2(dy, dx);\n\n      switch (this._bufParams.getEndCapStyle()) {\n        case BufferParameters.CAP_ROUND:\n          this._segList.addPt(offsetL.p1);\n\n          this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance);\n\n          this._segList.addPt(offsetR.p1);\n\n          break;\n\n        case BufferParameters.CAP_FLAT:\n          this._segList.addPt(offsetL.p1);\n\n          this._segList.addPt(offsetR.p1);\n\n          break;\n\n        case BufferParameters.CAP_SQUARE:\n          var squareCapSideOffset = new Coordinate();\n          squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n          squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n          var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n          var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n\n          this._segList.addPt(squareCapLOffset);\n\n          this._segList.addPt(squareCapROffset);\n\n          break;\n      }\n    },\n    getCoordinates: function getCoordinates() {\n      var pts = this._segList.getCoordinates();\n\n      return pts;\n    },\n    addMitreJoin: function addMitreJoin(p, offset0, offset1, distance) {\n      var isMitreWithinLimit = true;\n      var intPt = null;\n\n      try {\n        intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n        var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n        if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;\n      } catch (ex) {\n        if (ex instanceof NotRepresentableException) {\n          intPt = new Coordinate(0, 0);\n          isMitreWithinLimit = false;\n        } else throw ex;\n      } finally {}\n\n      if (isMitreWithinLimit) {\n        this._segList.addPt(intPt);\n      } else {\n        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n      }\n    },\n    addOutsideTurn: function addOutsideTurn(orientation, addStartPoint) {\n      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n        this._segList.addPt(this._offset0.p1);\n\n        return null;\n      }\n\n      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n      } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n        this.addBevelJoin(this._offset0, this._offset1);\n      } else {\n        if (addStartPoint) this._segList.addPt(this._offset0.p1);\n        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n\n        this._segList.addPt(this._offset1.p0);\n      }\n    },\n    createSquare: function createSquare(p) {\n      this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n\n      this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n\n      this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n\n      this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n\n      this._segList.closeRing();\n    },\n    addSegments: function addSegments(pt, isForward) {\n      this._segList.addPts(pt, isForward);\n    },\n    addFirstSegment: function addFirstSegment() {\n      this._segList.addPt(this._offset1.p0);\n    },\n    addCornerFillet: function addCornerFillet(p, p0, p1, direction, radius) {\n      var dx0 = p0.x - p.x;\n      var dy0 = p0.y - p.y;\n      var startAngle = Math.atan2(dy0, dx0);\n      var dx1 = p1.x - p.x;\n      var dy1 = p1.y - p.y;\n      var endAngle = Math.atan2(dy1, dx1);\n\n      if (direction === Orientation.CLOCKWISE) {\n        if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n      } else {\n        if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n      }\n\n      this._segList.addPt(p0);\n\n      this.addDirectedFillet(p, startAngle, endAngle, direction, radius);\n\n      this._segList.addPt(p1);\n    },\n    addLastSegment: function addLastSegment() {\n      this._segList.addPt(this._offset1.p1);\n    },\n    initSideSegments: function initSideSegments(s1, s2, side) {\n      this._s1 = s1;\n      this._s2 = s2;\n      this._side = side;\n\n      this._seg1.setCoordinates(s1, s2);\n\n      this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n    },\n    addLimitedMitreJoin: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n      var basePt = this._seg0.p1;\n      var ang0 = Angle.angle(basePt, this._seg0.p0);\n      var ang1 = Angle.angle(basePt, this._seg1.p1);\n      var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n      var angDiffHalf = angDiff / 2;\n      var midAng = Angle.normalize(ang0 + angDiffHalf);\n      var mitreMidAng = Angle.normalize(midAng + Math.PI);\n      var mitreDist = mitreLimit * distance;\n      var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n      var bevelHalfLen = distance - bevelDelta;\n      var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n      var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n      var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n      var mitreMidLine = new LineSegment(basePt, bevelMidPt);\n      var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n      var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n\n      if (this._side === Position.LEFT) {\n        this._segList.addPt(bevelEndLeft);\n\n        this._segList.addPt(bevelEndRight);\n      } else {\n        this._segList.addPt(bevelEndRight);\n\n        this._segList.addPt(bevelEndLeft);\n      }\n    },\n    addDirectedFillet: function addDirectedFillet(p, startAngle, endAngle, direction, radius) {\n      var directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1;\n      var totalAngle = Math.abs(startAngle - endAngle);\n      var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n      if (nSegs < 1) return null;\n      var initAngle = null,\n          currAngleInc = null;\n      initAngle = 0.0;\n      currAngleInc = totalAngle / nSegs;\n      var currAngle = initAngle;\n      var pt = new Coordinate();\n\n      while (currAngle < totalAngle) {\n        var angle = startAngle + directionFactor * currAngle;\n        pt.x = p.x + radius * Math.cos(angle);\n        pt.y = p.y + radius * Math.sin(angle);\n\n        this._segList.addPt(pt);\n\n        currAngle += currAngleInc;\n      }\n    },\n    computeOffsetSegment: function computeOffsetSegment(seg, side, distance, offset) {\n      var sideSign = side === Position.LEFT ? 1 : -1;\n      var dx = seg.p1.x - seg.p0.x;\n      var dy = seg.p1.y - seg.p0.y;\n      var len = Math.sqrt(dx * dx + dy * dy);\n      var ux = sideSign * distance * dx / len;\n      var uy = sideSign * distance * dy / len;\n      offset.p0.x = seg.p0.x - uy;\n      offset.p0.y = seg.p0.y + ux;\n      offset.p1.x = seg.p1.x - uy;\n      offset.p1.y = seg.p1.y + ux;\n    },\n    addInsideTurn: function addInsideTurn(orientation, addStartPoint) {\n      this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n\n      if (this._li.hasIntersection()) {\n        this._segList.addPt(this._li.getIntersection(0));\n      } else {\n        this._hasNarrowConcaveAngle = true;\n\n        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n          this._segList.addPt(this._offset0.p1);\n        } else {\n          this._segList.addPt(this._offset0.p1);\n\n          if (this._closingSegLengthFactor > 0) {\n            var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n            this._segList.addPt(mid0);\n\n            var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n            this._segList.addPt(mid1);\n          } else {\n            this._segList.addPt(this._s1);\n          }\n\n          this._segList.addPt(this._offset1.p0);\n        }\n      }\n    },\n    createCircle: function createCircle(p) {\n      var pt = new Coordinate(p.x + this._distance, p.y);\n\n      this._segList.addPt(pt);\n\n      this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n\n      this._segList.closeRing();\n    },\n    addBevelJoin: function addBevelJoin(offset0, offset1) {\n      this._segList.addPt(offset0.p1);\n\n      this._segList.addPt(offset1.p0);\n    },\n    init: function init(distance) {\n      this._distance = distance;\n      this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n      this._segList = new OffsetSegmentString();\n\n      this._segList.setPrecisionModel(this._precisionModel);\n\n      this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n    },\n    addCollinear: function addCollinear(addStartPoint) {\n      this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n\n      var numInt = this._li.getIntersectionNum();\n\n      if (numInt >= 2) {\n        if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n          if (addStartPoint) this._segList.addPt(this._offset0.p1);\n\n          this._segList.addPt(this._offset1.p0);\n        } else {\n          this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance);\n        }\n      }\n    },\n    closeRing: function closeRing() {\n      this._segList.closeRing();\n    },\n    hasNarrowConcaveAngle: function hasNarrowConcaveAngle() {\n      return this._hasNarrowConcaveAngle;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OffsetSegmentGenerator;\n    }\n  });\n  OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\n  OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\n  function OffsetCurveBuilder() {\n    this._distance = 0.0;\n    this._precisionModel = null;\n    this._bufParams = null;\n    var precisionModel = arguments[0],\n        bufParams = arguments[1];\n    this._precisionModel = precisionModel;\n    this._bufParams = bufParams;\n  }\n  extend(OffsetCurveBuilder.prototype, {\n    getOffsetCurve: function getOffsetCurve(inputPts, distance) {\n      this._distance = distance;\n      if (distance === 0.0) return null;\n      var isRightSide = distance < 0.0;\n      var posDistance = Math.abs(distance);\n      var segGen = this.getSegGen(posDistance);\n\n      if (inputPts.length <= 1) {\n        this.computePointCurve(inputPts[0], segGen);\n      } else {\n        this.computeOffsetCurve(inputPts, isRightSide, segGen);\n      }\n\n      var curvePts = segGen.getCoordinates();\n      if (isRightSide) CoordinateArrays.reverse(curvePts);\n      return curvePts;\n    },\n    computeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n      var distTol = this.simplifyTolerance(this._distance);\n\n      if (isRightSide) {\n        segGen.addSegments(inputPts, true);\n        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        var n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (var i = n2 - 2; i >= 0; i--) {\n          segGen.addNextSegment(simp2[i], true);\n        }\n      } else {\n        segGen.addSegments(inputPts, false);\n        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        var n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (var i = 2; i <= n1; i++) {\n          segGen.addNextSegment(simp1[i], true);\n        }\n      }\n\n      segGen.addLastSegment();\n      segGen.closeRing();\n    },\n    computeRingBufferCurve: function computeRingBufferCurve(inputPts, side, segGen) {\n      var distTol = this.simplifyTolerance(this._distance);\n      if (side === Position.RIGHT) distTol = -distTol;\n      var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n      var n = simp.length - 1;\n      segGen.initSideSegments(simp[n - 1], simp[0], side);\n\n      for (var i = 1; i <= n; i++) {\n        var addStartPoint = i !== 1;\n        segGen.addNextSegment(simp[i], addStartPoint);\n      }\n\n      segGen.closeRing();\n    },\n    computeLineBufferCurve: function computeLineBufferCurve(inputPts, segGen) {\n      var distTol = this.simplifyTolerance(this._distance);\n      var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n      var n1 = simp1.length - 1;\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\n      for (var i = 2; i <= n1; i++) {\n        segGen.addNextSegment(simp1[i], true);\n      }\n\n      segGen.addLastSegment();\n      segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n      var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n      var n2 = simp2.length - 1;\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\n      for (var i = n2 - 2; i >= 0; i--) {\n        segGen.addNextSegment(simp2[i], true);\n      }\n\n      segGen.addLastSegment();\n      segGen.addLineEndCap(simp2[1], simp2[0]);\n      segGen.closeRing();\n    },\n    computePointCurve: function computePointCurve(pt, segGen) {\n      switch (this._bufParams.getEndCapStyle()) {\n        case BufferParameters.CAP_ROUND:\n          segGen.createCircle(pt);\n          break;\n\n        case BufferParameters.CAP_SQUARE:\n          segGen.createSquare(pt);\n          break;\n      }\n    },\n    getLineCurve: function getLineCurve(inputPts, distance) {\n      this._distance = distance;\n      if (distance < 0.0 && !this._bufParams.isSingleSided()) return null;\n      if (distance === 0.0) return null;\n      var posDistance = Math.abs(distance);\n      var segGen = this.getSegGen(posDistance);\n\n      if (inputPts.length <= 1) {\n        this.computePointCurve(inputPts[0], segGen);\n      } else {\n        if (this._bufParams.isSingleSided()) {\n          var isRightSide = distance < 0.0;\n          this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n        } else this.computeLineBufferCurve(inputPts, segGen);\n      }\n\n      var lineCoord = segGen.getCoordinates();\n      return lineCoord;\n    },\n    getBufferParameters: function getBufferParameters() {\n      return this._bufParams;\n    },\n    simplifyTolerance: function simplifyTolerance(bufDistance) {\n      return bufDistance * this._bufParams.getSimplifyFactor();\n    },\n    getRingCurve: function getRingCurve(inputPts, side, distance) {\n      this._distance = distance;\n      if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n\n      if (distance === 0.0) {\n        return OffsetCurveBuilder.copyCoordinates(inputPts);\n      }\n\n      var segGen = this.getSegGen(distance);\n      this.computeRingBufferCurve(inputPts, side, segGen);\n      return segGen.getCoordinates();\n    },\n    computeOffsetCurve: function computeOffsetCurve(inputPts, isRightSide, segGen) {\n      var distTol = this.simplifyTolerance(this._distance);\n\n      if (isRightSide) {\n        var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        var n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (var i = n2 - 2; i >= 0; i--) {\n          segGen.addNextSegment(simp2[i], true);\n        }\n      } else {\n        var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        var n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (var i = 2; i <= n1; i++) {\n          segGen.addNextSegment(simp1[i], true);\n        }\n      }\n\n      segGen.addLastSegment();\n    },\n    getSegGen: function getSegGen(distance) {\n      return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OffsetCurveBuilder;\n    }\n  });\n\n  OffsetCurveBuilder.copyCoordinates = function (pts) {\n    var copy = new Array(pts.length).fill(null);\n\n    for (var i = 0; i < copy.length; i++) {\n      copy[i] = new Coordinate(pts[i]);\n    }\n\n    return copy;\n  };\n\n  function SubgraphDepthLocater() {\n    this._subgraphs = null;\n    this._seg = new LineSegment();\n    var subgraphs = arguments[0];\n    this._subgraphs = subgraphs;\n  }\n  extend(SubgraphDepthLocater.prototype, {\n    findStabbedSegments: function findStabbedSegments() {\n      if (arguments.length === 1) {\n        var stabbingRayLeftPt = arguments[0];\n        var stabbedSegments = new ArrayList();\n\n        for (var i = this._subgraphs.iterator(); i.hasNext();) {\n          var bsg = i.next();\n          var env = bsg.getEnvelope();\n          if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n          this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n        }\n\n        return stabbedSegments;\n      } else if (arguments.length === 3) {\n        if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n          var _stabbingRayLeftPt = arguments[0],\n              dirEdge = arguments[1],\n              _stabbedSegments = arguments[2];\n          var pts = dirEdge.getEdge().getCoordinates();\n\n          for (var i = 0; i < pts.length - 1; i++) {\n            this._seg.p0 = pts[i];\n            this._seg.p1 = pts[i + 1];\n            if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n            var maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n            if (maxx < _stabbingRayLeftPt.x) continue;\n            if (this._seg.isHorizontal()) continue;\n            if (_stabbingRayLeftPt.y < this._seg.p0.y || _stabbingRayLeftPt.y > this._seg.p1.y) continue;\n            if (Orientation.index(this._seg.p0, this._seg.p1, _stabbingRayLeftPt) === Orientation.RIGHT) continue;\n            var depth = dirEdge.getDepth(Position.LEFT);\n            if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n            var ds = new DepthSegment(this._seg, depth);\n\n            _stabbedSegments.add(ds);\n          }\n        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n          var _stabbingRayLeftPt2 = arguments[0],\n              dirEdges = arguments[1],\n              _stabbedSegments2 = arguments[2];\n\n          for (var i = dirEdges.iterator(); i.hasNext();) {\n            var de = i.next();\n            if (!de.isForward()) continue;\n            this.findStabbedSegments(_stabbingRayLeftPt2, de, _stabbedSegments2);\n          }\n        }\n      }\n    },\n    getDepth: function getDepth(p) {\n      var stabbedSegments = this.findStabbedSegments(p);\n      if (stabbedSegments.size() === 0) return 0;\n      var ds = Collections.min(stabbedSegments);\n      return ds._leftDepth;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SubgraphDepthLocater;\n    }\n  });\n\n  function DepthSegment() {\n    this._upwardSeg = null;\n    this._leftDepth = null;\n    var seg = arguments[0],\n        depth = arguments[1];\n    this._upwardSeg = new LineSegment(seg);\n    this._leftDepth = depth;\n  }\n\n  extend(DepthSegment.prototype, {\n    compareTo: function compareTo(obj) {\n      var other = obj;\n      if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n      if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n\n      var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n\n      if (orientIndex !== 0) return orientIndex;\n      orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n      if (orientIndex !== 0) return orientIndex;\n      return this._upwardSeg.compareTo(other._upwardSeg);\n    },\n    compareX: function compareX(seg0, seg1) {\n      var compare0 = seg0.p0.compareTo(seg1.p0);\n      if (compare0 !== 0) return compare0;\n      return seg0.p1.compareTo(seg1.p1);\n    },\n    toString: function toString() {\n      return this._upwardSeg.toString();\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return DepthSegment;\n    }\n  });\n  SubgraphDepthLocater.DepthSegment = DepthSegment;\n\n  function OffsetCurveSetBuilder() {\n    this._inputGeom = null;\n    this._distance = null;\n    this._curveBuilder = null;\n    this._curveList = new ArrayList();\n    var inputGeom = arguments[0],\n        distance = arguments[1],\n        curveBuilder = arguments[2];\n    this._inputGeom = inputGeom;\n    this._distance = distance;\n    this._curveBuilder = curveBuilder;\n  }\n  extend(OffsetCurveSetBuilder.prototype, {\n    addPoint: function addPoint(p) {\n      if (this._distance <= 0.0) return null;\n      var coord = p.getCoordinates();\n\n      var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\n      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n    },\n    addPolygon: function addPolygon(p) {\n      var offsetDistance = this._distance;\n      var offsetSide = Position.LEFT;\n\n      if (this._distance < 0.0) {\n        offsetDistance = -this._distance;\n        offsetSide = Position.RIGHT;\n      }\n\n      var shell = p.getExteriorRing();\n      var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n      if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n      if (this._distance <= 0.0 && shellCoord.length < 3) return null;\n      this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n\n      for (var i = 0; i < p.getNumInteriorRing(); i++) {\n        var hole = p.getInteriorRingN(i);\n        var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n        if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n        this.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n      }\n    },\n    isTriangleErodedCompletely: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n      var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n      var inCentre = tri.inCentre();\n      var distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1);\n      return distToCentre < Math.abs(bufferDistance);\n    },\n    addLineString: function addLineString(line) {\n      if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;\n      var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\n      var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\n      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n    },\n    addCurve: function addCurve(coord, leftLoc, rightLoc) {\n      if (coord === null || coord.length < 2) return null;\n      var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n\n      this._curveList.add(e);\n    },\n    getCurves: function getCurves() {\n      this.add(this._inputGeom);\n      return this._curveList;\n    },\n    addPolygonRing: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n      if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n      var leftLoc = cwLeftLoc;\n      var rightLoc = cwRightLoc;\n\n      if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\n        leftLoc = cwRightLoc;\n        rightLoc = cwLeftLoc;\n        side = Position.opposite(side);\n      }\n\n      var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n\n      this.addCurve(curve, leftLoc, rightLoc);\n    },\n    add: function add(g) {\n      if (g.isEmpty()) return null;\n      if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());\n    },\n    isErodedCompletely: function isErodedCompletely(ring, bufferDistance) {\n      var ringCoord = ring.getCoordinates();\n      if (ringCoord.length < 4) return bufferDistance < 0;\n      if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n      var env = ring.getEnvelopeInternal();\n      var envMinDimension = Math.min(env.getHeight(), env.getWidth());\n      if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n      return false;\n    },\n    addCollection: function addCollection(gc) {\n      for (var i = 0; i < gc.getNumGeometries(); i++) {\n        var g = gc.getGeometryN(i);\n        this.add(g);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OffsetCurveSetBuilder;\n    }\n  });\n\n  function EdgeEndStar() {\n    this._edgeMap = new TreeMap();\n    this._edgeList = null;\n    this._ptInAreaLocation = [Location.NONE, Location.NONE];\n  }\n  extend(EdgeEndStar.prototype, {\n    getNextCW: function getNextCW(ee) {\n      this.getEdges();\n\n      var i = this._edgeList.indexOf(ee);\n\n      var iNextCW = i - 1;\n      if (i === 0) iNextCW = this._edgeList.size() - 1;\n      return this._edgeList.get(iNextCW);\n    },\n    propagateSideLabels: function propagateSideLabels(geomIndex) {\n      var startLoc = Location.NONE;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n        if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n      }\n\n      if (startLoc === Location.NONE) return null;\n      var currLoc = startLoc;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n        if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\n        if (label.isArea(geomIndex)) {\n          var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n          var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\n          if (rightLoc !== Location.NONE) {\n            if (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\n            if (leftLoc === Location.NONE) {\n              Assert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n            }\n\n            currLoc = leftLoc;\n          } else {\n            Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n            label.setLocation(geomIndex, Position.RIGHT, currLoc);\n            label.setLocation(geomIndex, Position.LEFT, currLoc);\n          }\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      var it = this.iterator();\n      if (!it.hasNext()) return null;\n      var e = it.next();\n      return e.getCoordinate();\n    },\n    print: function print(out) {\n      System.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        e.print(out);\n      }\n    },\n    isAreaLabelsConsistent: function isAreaLabelsConsistent(geomGraph) {\n      this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n      return this.checkAreaLabelsConsistent(0);\n    },\n    checkAreaLabelsConsistent: function checkAreaLabelsConsistent(geomIndex) {\n      var edges = this.getEdges();\n      if (edges.size() <= 0) return true;\n      var lastEdgeIndex = edges.size() - 1;\n      var startLabel = edges.get(lastEdgeIndex).getLabel();\n      var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n      Assert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n      var currLoc = startLoc;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n        Assert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n        var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n        var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\n        if (leftLoc === rightLoc) {\n          return false;\n        }\n\n        if (rightLoc !== currLoc) {\n          return false;\n        }\n\n        currLoc = leftLoc;\n      }\n\n      return true;\n    },\n    findIndex: function findIndex(eSearch) {\n      this.iterator();\n\n      for (var i = 0; i < this._edgeList.size(); i++) {\n        var e = this._edgeList.get(i);\n\n        if (e === eSearch) return i;\n      }\n\n      return -1;\n    },\n    iterator: function iterator() {\n      return this.getEdges().iterator();\n    },\n    getEdges: function getEdges() {\n      if (this._edgeList === null) {\n        this._edgeList = new ArrayList(this._edgeMap.values());\n      }\n\n      return this._edgeList;\n    },\n    getLocation: function getLocation(geomIndex, p, geom) {\n      if (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n        this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n      }\n\n      return this._ptInAreaLocation[geomIndex];\n    },\n    toString: function toString() {\n      var buf = new StringBuffer();\n      buf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n      buf.append(\"\\n\");\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        buf.append(e);\n        buf.append(\"\\n\");\n      }\n\n      return buf.toString();\n    },\n    computeEdgeEndLabels: function computeEdgeEndLabels(boundaryNodeRule) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var ee = it.next();\n        ee.computeLabel(boundaryNodeRule);\n      }\n    },\n    computeLabelling: function computeLabelling(geomGraph) {\n      this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n      this.propagateSideLabels(0);\n      this.propagateSideLabels(1);\n      var hasDimensionalCollapseEdge = [false, false];\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n\n        for (var geomi = 0; geomi < 2; geomi++) {\n          if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n        }\n      }\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n\n        for (var geomi = 0; geomi < 2; geomi++) {\n          if (label.isAnyNull(geomi)) {\n            var loc = Location.NONE;\n\n            if (hasDimensionalCollapseEdge[geomi]) {\n              loc = Location.EXTERIOR;\n            } else {\n              var p = e.getCoordinate();\n              loc = this.getLocation(geomi, p, geomGraph);\n            }\n\n            label.setAllLocationsIfNull(geomi, loc);\n          }\n        }\n      }\n    },\n    getDegree: function getDegree() {\n      return this._edgeMap.size();\n    },\n    insertEdgeEnd: function insertEdgeEnd(e, obj) {\n      this._edgeMap.put(e, obj);\n\n      this._edgeList = null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeEndStar;\n    }\n  });\n\n  function DirectedEdgeStar() {\n    EdgeEndStar.apply(this);\n    this._resultAreaEdgeList = null;\n    this._label = null;\n    this._SCANNING_FOR_INCOMING = 1;\n    this._LINKING_TO_OUTGOING = 2;\n  }\n  inherits(DirectedEdgeStar, EdgeEndStar);\n  extend(DirectedEdgeStar.prototype, {\n    linkResultDirectedEdges: function linkResultDirectedEdges() {\n      this.getResultAreaEdges();\n      var firstOut = null;\n      var incoming = null;\n      var state = this._SCANNING_FOR_INCOMING;\n\n      for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n        var nextOut = this._resultAreaEdgeList.get(i);\n\n        var nextIn = nextOut.getSym();\n        if (!nextOut.getLabel().isArea()) continue;\n        if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n\n        switch (state) {\n          case this._SCANNING_FOR_INCOMING:\n            if (!nextIn.isInResult()) continue;\n            incoming = nextIn;\n            state = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (!nextOut.isInResult()) continue;\n            incoming.setNext(nextOut);\n            state = this._SCANNING_FOR_INCOMING;\n            break;\n        }\n      }\n\n      if (state === this._LINKING_TO_OUTGOING) {\n        if (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n        Assert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n        incoming.setNext(firstOut);\n      }\n    },\n    insert: function insert(ee) {\n      var de = ee;\n      this.insertEdgeEnd(de, de);\n    },\n    getRightmostEdge: function getRightmostEdge() {\n      var edges = this.getEdges();\n      var size = edges.size();\n      if (size < 1) return null;\n      var de0 = edges.get(0);\n      if (size === 1) return de0;\n      var deLast = edges.get(size - 1);\n      var quad0 = de0.getQuadrant();\n      var quad1 = deLast.getQuadrant();\n      if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {\n        if (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;\n      }\n      Assert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n      return null;\n    },\n    print: function print(out) {\n      System.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        out.print(\"out \");\n        de.print(out);\n        out.println();\n        out.print(\"in \");\n        de.getSym().print(out);\n        out.println();\n      }\n    },\n    getResultAreaEdges: function getResultAreaEdges() {\n      if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n      this._resultAreaEdgeList = new ArrayList();\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n      }\n\n      return this._resultAreaEdgeList;\n    },\n    updateLabelling: function updateLabelling(nodeLabel) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        var label = de.getLabel();\n        label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n        label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n      }\n    },\n    linkAllDirectedEdges: function linkAllDirectedEdges() {\n      this.getEdges();\n      var prevOut = null;\n      var firstIn = null;\n\n      for (var i = this._edgeList.size() - 1; i >= 0; i--) {\n        var nextOut = this._edgeList.get(i);\n\n        var nextIn = nextOut.getSym();\n        if (firstIn === null) firstIn = nextIn;\n        if (prevOut !== null) nextIn.setNext(prevOut);\n        prevOut = nextOut;\n      }\n\n      firstIn.setNext(prevOut);\n    },\n    computeDepths: function computeDepths() {\n      if (arguments.length === 1) {\n        var de = arguments[0];\n        var edgeIndex = this.findIndex(de);\n        var label = de.getLabel();\n        var startDepth = de.getDepth(Position.LEFT);\n        var targetLastDepth = de.getDepth(Position.RIGHT);\n        var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n        var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n        if (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n      } else if (arguments.length === 3) {\n        var startIndex = arguments[0],\n            endIndex = arguments[1],\n            _startDepth = arguments[2];\n        var currDepth = _startDepth;\n\n        for (var i = startIndex; i < endIndex; i++) {\n          var nextDe = this._edgeList.get(i);\n\n          var label = nextDe.getLabel();\n          nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n          currDepth = nextDe.getDepth(Position.LEFT);\n        }\n\n        return currDepth;\n      }\n    },\n    mergeSymLabels: function mergeSymLabels() {\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        var label = de.getLabel();\n        label.merge(de.getSym().getLabel());\n      }\n    },\n    linkMinimalDirectedEdges: function linkMinimalDirectedEdges(er) {\n      var firstOut = null;\n      var incoming = null;\n      var state = this._SCANNING_FOR_INCOMING;\n\n      for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n        var nextOut = this._resultAreaEdgeList.get(i);\n\n        var nextIn = nextOut.getSym();\n        if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n\n        switch (state) {\n          case this._SCANNING_FOR_INCOMING:\n            if (nextIn.getEdgeRing() !== er) continue;\n            incoming = nextIn;\n            state = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (nextOut.getEdgeRing() !== er) continue;\n            incoming.setNextMin(nextOut);\n            state = this._SCANNING_FOR_INCOMING;\n            break;\n        }\n      }\n\n      if (state === this._LINKING_TO_OUTGOING) {\n        Assert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n        Assert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n        incoming.setNextMin(firstOut);\n      }\n    },\n    getOutgoingDegree: function getOutgoingDegree() {\n      if (arguments.length === 0) {\n        var degree = 0;\n\n        for (var it = this.iterator(); it.hasNext();) {\n          var de = it.next();\n          if (de.isInResult()) degree++;\n        }\n\n        return degree;\n      } else if (arguments.length === 1) {\n        var er = arguments[0];\n        var degree = 0;\n\n        for (var it = this.iterator(); it.hasNext();) {\n          var de = it.next();\n          if (de.getEdgeRing() === er) degree++;\n        }\n\n        return degree;\n      }\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    findCoveredLineEdges: function findCoveredLineEdges() {\n      var startLoc = Location.NONE;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var nextOut = it.next();\n        var nextIn = nextOut.getSym();\n\n        if (!nextOut.isLineEdge()) {\n          if (nextOut.isInResult()) {\n            startLoc = Location.INTERIOR;\n            break;\n          }\n\n          if (nextIn.isInResult()) {\n            startLoc = Location.EXTERIOR;\n            break;\n          }\n        }\n      }\n\n      if (startLoc === Location.NONE) return null;\n      var currLoc = startLoc;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var nextOut = it.next();\n        var nextIn = nextOut.getSym();\n\n        if (nextOut.isLineEdge()) {\n          nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n        } else {\n          if (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n          if (nextIn.isInResult()) currLoc = Location.INTERIOR;\n        }\n      }\n    },\n    computeLabelling: function computeLabelling(geom) {\n      EdgeEndStar.prototype.computeLabelling.call(this, geom);\n      this._label = new Label(Location.NONE);\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var ee = it.next();\n        var e = ee.getEdge();\n        var eLabel = e.getLabel();\n\n        for (var i = 0; i < 2; i++) {\n          var eLoc = eLabel.getLocation(i);\n          if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DirectedEdgeStar;\n    }\n  });\n\n  function OverlayNodeFactory() {\n    NodeFactory.apply(this);\n  }\n  inherits(OverlayNodeFactory, NodeFactory);\n  extend(OverlayNodeFactory.prototype, {\n    createNode: function createNode(coord) {\n      return new Node$1(coord, new DirectedEdgeStar());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OverlayNodeFactory;\n    }\n  });\n\n  function OrientedCoordinateArray() {\n    this._pts = null;\n    this._orientation = null;\n    var pts = arguments[0];\n    this._pts = pts;\n    this._orientation = OrientedCoordinateArray.orientation(pts);\n  }\n  extend(OrientedCoordinateArray.prototype, {\n    compareTo: function compareTo(o1) {\n      var oca = o1;\n      var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n      return comp;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return OrientedCoordinateArray;\n    }\n  });\n\n  OrientedCoordinateArray.orientation = function (pts) {\n    return CoordinateArrays.increasingDirection(pts) === 1;\n  };\n\n  OrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n    var dir1 = orientation1 ? 1 : -1;\n    var dir2 = orientation2 ? 1 : -1;\n    var limit1 = orientation1 ? pts1.length : -1;\n    var limit2 = orientation2 ? pts2.length : -1;\n    var i1 = orientation1 ? 0 : pts1.length - 1;\n    var i2 = orientation2 ? 0 : pts2.length - 1;\n\n    while (true) {\n      var compPt = pts1[i1].compareTo(pts2[i2]);\n      if (compPt !== 0) return compPt;\n      i1 += dir1;\n      i2 += dir2;\n      var done1 = i1 === limit1;\n      var done2 = i2 === limit2;\n      if (done1 && !done2) return -1;\n      if (!done1 && done2) return 1;\n      if (done1 && done2) return 0;\n    }\n  };\n\n  function EdgeList() {\n    this._edges = new ArrayList();\n    this._ocaMap = new TreeMap();\n  }\n  extend(EdgeList.prototype, {\n    print: function print(out) {\n      out.print(\"MULTILINESTRING ( \");\n\n      for (var j = 0; j < this._edges.size(); j++) {\n        var e = this._edges.get(j);\n\n        if (j > 0) out.print(\",\");\n        out.print(\"(\");\n        var pts = e.getCoordinates();\n\n        for (var i = 0; i < pts.length; i++) {\n          if (i > 0) out.print(\",\");\n          out.print(pts[i].x + \" \" + pts[i].y);\n        }\n\n        out.println(\")\");\n      }\n\n      out.print(\")  \");\n    },\n    addAll: function addAll(edgeColl) {\n      for (var i = edgeColl.iterator(); i.hasNext();) {\n        this.add(i.next());\n      }\n    },\n    findEdgeIndex: function findEdgeIndex(e) {\n      for (var i = 0; i < this._edges.size(); i++) {\n        if (this._edges.get(i).equals(e)) return i;\n      }\n\n      return -1;\n    },\n    iterator: function iterator() {\n      return this._edges.iterator();\n    },\n    getEdges: function getEdges() {\n      return this._edges;\n    },\n    get: function get(i) {\n      return this._edges.get(i);\n    },\n    findEqualEdge: function findEqualEdge(e) {\n      var oca = new OrientedCoordinateArray(e.getCoordinates());\n\n      var matchEdge = this._ocaMap.get(oca);\n\n      return matchEdge;\n    },\n    add: function add(e) {\n      this._edges.add(e);\n\n      var oca = new OrientedCoordinateArray(e.getCoordinates());\n\n      this._ocaMap.put(oca, e);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeList;\n    }\n  });\n\n  function SegmentIntersector$1() {}\n  extend(SegmentIntersector$1.prototype, {\n    processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {},\n    isDone: function isDone() {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SegmentIntersector$1;\n    }\n  });\n\n  function IntersectionAdder() {\n    this._hasIntersection = false;\n    this._hasProper = false;\n    this._hasProperInterior = false;\n    this._hasInterior = false;\n    this._properIntersectionPoint = null;\n    this._li = null;\n    this._isSelfIntersection = null;\n    this.numIntersections = 0;\n    this.numInteriorIntersections = 0;\n    this.numProperIntersections = 0;\n    this.numTests = 0;\n    var li = arguments[0];\n    this._li = li;\n  }\n  extend(IntersectionAdder.prototype, {\n    isTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1) {\n        if (this._li.getIntersectionNum() === 1) {\n          if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\n          if (e0.isClosed()) {\n            var maxSegIndex = e0.size() - 1;\n\n            if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    },\n    getProperIntersectionPoint: function getProperIntersectionPoint() {\n      return this._properIntersectionPoint;\n    },\n    hasProperInteriorIntersection: function hasProperInteriorIntersection() {\n      return this._hasProperInterior;\n    },\n    getLineIntersector: function getLineIntersector() {\n      return this._li;\n    },\n    hasProperIntersection: function hasProperIntersection() {\n      return this._hasProper;\n    },\n    processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      this.numTests++;\n      var p00 = e0.getCoordinates()[segIndex0];\n      var p01 = e0.getCoordinates()[segIndex0 + 1];\n      var p10 = e1.getCoordinates()[segIndex1];\n      var p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        this.numIntersections++;\n\n        if (this._li.isInteriorIntersection()) {\n          this.numInteriorIntersections++;\n          this._hasInterior = true;\n        }\n\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n          this._hasIntersection = true;\n          e0.addIntersections(this._li, segIndex0, 0);\n          e1.addIntersections(this._li, segIndex1, 1);\n\n          if (this._li.isProper()) {\n            this.numProperIntersections++;\n            this._hasProper = true;\n            this._hasProperInterior = true;\n          }\n        }\n      }\n    },\n    hasIntersection: function hasIntersection() {\n      return this._hasIntersection;\n    },\n    isDone: function isDone() {\n      return false;\n    },\n    hasInteriorIntersection: function hasInteriorIntersection() {\n      return this._hasInterior;\n    },\n    interfaces_: function interfaces_() {\n      return [SegmentIntersector$1];\n    },\n    getClass: function getClass() {\n      return IntersectionAdder;\n    }\n  });\n\n  IntersectionAdder.isAdjacentSegments = function (i1, i2) {\n    return Math.abs(i1 - i2) === 1;\n  };\n\n  function BufferBuilder() {\n    this._bufParams = null;\n    this._workingPrecisionModel = null;\n    this._workingNoder = null;\n    this._geomFact = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    var bufParams = arguments[0];\n    this._bufParams = bufParams;\n  }\n  extend(BufferBuilder.prototype, {\n    setWorkingPrecisionModel: function setWorkingPrecisionModel(pm) {\n      this._workingPrecisionModel = pm;\n    },\n    insertUniqueEdge: function insertUniqueEdge(e) {\n      var existingEdge = this._edgeList.findEqualEdge(e);\n\n      if (existingEdge !== null) {\n        var existingLabel = existingEdge.getLabel();\n        var labelToMerge = e.getLabel();\n\n        if (!existingEdge.isPointwiseEqual(e)) {\n          labelToMerge = new Label(e.getLabel());\n          labelToMerge.flip();\n        }\n\n        existingLabel.merge(labelToMerge);\n        var mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n        var existingDelta = existingEdge.getDepthDelta();\n        var newDelta = existingDelta + mergeDelta;\n        existingEdge.setDepthDelta(newDelta);\n      } else {\n        this._edgeList.add(e);\n\n        e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n      }\n    },\n    buildSubgraphs: function buildSubgraphs(subgraphList, polyBuilder) {\n      var processedGraphs = new ArrayList();\n\n      for (var i = subgraphList.iterator(); i.hasNext();) {\n        var subgraph = i.next();\n        var p = subgraph.getRightmostCoordinate();\n        var locater = new SubgraphDepthLocater(processedGraphs);\n        var outsideDepth = locater.getDepth(p);\n        subgraph.computeDepth(outsideDepth);\n        subgraph.findResultEdges();\n        processedGraphs.add(subgraph);\n        polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n      }\n    },\n    createSubgraphs: function createSubgraphs(graph) {\n      var subgraphList = new ArrayList();\n\n      for (var i = graph.getNodes().iterator(); i.hasNext();) {\n        var node = i.next();\n\n        if (!node.isVisited()) {\n          var subgraph = new BufferSubgraph();\n          subgraph.create(node);\n          subgraphList.add(subgraph);\n        }\n      }\n\n      Collections.sort(subgraphList, Collections.reverseOrder());\n      return subgraphList;\n    },\n    createEmptyResultGeometry: function createEmptyResultGeometry() {\n      var emptyGeom = this._geomFact.createPolygon();\n\n      return emptyGeom;\n    },\n    getNoder: function getNoder(precisionModel) {\n      if (this._workingNoder !== null) return this._workingNoder;\n      var noder = new MCIndexNoder();\n      var li = new RobustLineIntersector();\n      li.setPrecisionModel(precisionModel);\n      noder.setSegmentIntersector(new IntersectionAdder(li));\n      return noder;\n    },\n    buffer: function buffer(g, distance) {\n      var precisionModel = this._workingPrecisionModel;\n      if (precisionModel === null) precisionModel = g.getPrecisionModel();\n      this._geomFact = g.getFactory();\n      var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n      var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n      var bufferSegStrList = curveSetBuilder.getCurves();\n\n      if (bufferSegStrList.size() <= 0) {\n        return this.createEmptyResultGeometry();\n      }\n\n      this.computeNodedEdges(bufferSegStrList, precisionModel);\n      this._graph = new PlanarGraph(new OverlayNodeFactory());\n\n      this._graph.addEdges(this._edgeList.getEdges());\n\n      var subgraphList = this.createSubgraphs(this._graph);\n      var polyBuilder = new PolygonBuilder(this._geomFact);\n      this.buildSubgraphs(subgraphList, polyBuilder);\n      var resultPolyList = polyBuilder.getPolygons();\n\n      if (resultPolyList.size() <= 0) {\n        return this.createEmptyResultGeometry();\n      }\n\n      var resultGeom = this._geomFact.buildGeometry(resultPolyList);\n\n      return resultGeom;\n    },\n    computeNodedEdges: function computeNodedEdges(bufferSegStrList, precisionModel) {\n      var noder = this.getNoder(precisionModel);\n      noder.computeNodes(bufferSegStrList);\n      var nodedSegStrings = noder.getNodedSubstrings();\n\n      for (var i = nodedSegStrings.iterator(); i.hasNext();) {\n        var segStr = i.next();\n        var pts = segStr.getCoordinates();\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n        var oldLabel = segStr.getData();\n        var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n        this.insertUniqueEdge(edge);\n      }\n    },\n    setNoder: function setNoder(noder) {\n      this._workingNoder = noder;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BufferBuilder;\n    }\n  });\n\n  BufferBuilder.depthDelta = function (label) {\n    var lLoc = label.getLocation(0, Position.LEFT);\n    var rLoc = label.getLocation(0, Position.RIGHT);\n    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n    return 0;\n  };\n\n  BufferBuilder.convertSegStrings = function (it) {\n    var fact = new GeometryFactory();\n    var lines = new ArrayList();\n\n    while (it.hasNext()) {\n      var ss = it.next();\n      var line = fact.createLineString(ss.getCoordinates());\n      lines.add(line);\n    }\n\n    return fact.buildGeometry(lines);\n  };\n\n  function NodingValidator() {\n    this._li = new RobustLineIntersector();\n    this._segStrings = null;\n    var segStrings = arguments[0];\n    this._segStrings = segStrings;\n  }\n  extend(NodingValidator.prototype, {\n    checkEndPtVertexIntersections: function checkEndPtVertexIntersections() {\n      if (arguments.length === 0) {\n        for (var i = this._segStrings.iterator(); i.hasNext();) {\n          var ss = i.next();\n          var pts = ss.getCoordinates();\n          this.checkEndPtVertexIntersections(pts[0], this._segStrings);\n          this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n        }\n      } else if (arguments.length === 2) {\n        var testPt = arguments[0],\n            segStrings = arguments[1];\n\n        for (var i = segStrings.iterator(); i.hasNext();) {\n          var ss = i.next();\n          var pts = ss.getCoordinates();\n\n          for (var j = 1; j < pts.length - 1; j++) {\n            if (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n          }\n        }\n      }\n    },\n    checkInteriorIntersections: function checkInteriorIntersections() {\n      if (arguments.length === 0) {\n        for (var i = this._segStrings.iterator(); i.hasNext();) {\n          var ss0 = i.next();\n\n          for (var j = this._segStrings.iterator(); j.hasNext();) {\n            var ss1 = j.next();\n            this.checkInteriorIntersections(ss0, ss1);\n          }\n        }\n      } else if (arguments.length === 2) {\n        var _ss = arguments[0],\n            _ss2 = arguments[1];\n\n        var pts0 = _ss.getCoordinates();\n\n        var pts1 = _ss2.getCoordinates();\n\n        for (var i0 = 0; i0 < pts0.length - 1; i0++) {\n          for (var i1 = 0; i1 < pts1.length - 1; i1++) {\n            this.checkInteriorIntersections(_ss, i0, _ss2, i1);\n          }\n        }\n      } else if (arguments.length === 4) {\n        var e0 = arguments[0],\n            segIndex0 = arguments[1],\n            e1 = arguments[2],\n            segIndex1 = arguments[3];\n        if (e0 === e1 && segIndex0 === segIndex1) return null;\n        var p00 = e0.getCoordinates()[segIndex0];\n        var p01 = e0.getCoordinates()[segIndex0 + 1];\n        var p10 = e1.getCoordinates()[segIndex1];\n        var p11 = e1.getCoordinates()[segIndex1 + 1];\n\n        this._li.computeIntersection(p00, p01, p10, p11);\n\n        if (this._li.hasIntersection()) {\n          if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n            throw new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n          }\n        }\n      }\n    },\n    checkValid: function checkValid() {\n      this.checkEndPtVertexIntersections();\n      this.checkInteriorIntersections();\n      this.checkCollapses();\n    },\n    checkCollapses: function checkCollapses() {\n      if (arguments.length === 0) {\n        for (var i = this._segStrings.iterator(); i.hasNext();) {\n          var ss = i.next();\n          this.checkCollapses(ss);\n        }\n      } else if (arguments.length === 1) {\n        var _ss3 = arguments[0];\n\n        var pts = _ss3.getCoordinates();\n\n        for (var i = 0; i < pts.length - 2; i++) {\n          this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n        }\n      }\n    },\n    hasInteriorIntersection: function hasInteriorIntersection(li, p0, p1) {\n      for (var i = 0; i < li.getIntersectionNum(); i++) {\n        var intPt = li.getIntersection(i);\n        if (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n      }\n\n      return false;\n    },\n    checkCollapse: function checkCollapse(p0, p1, p2) {\n      if (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NodingValidator;\n    }\n  });\n  NodingValidator.fact = new GeometryFactory();\n\n  function HotPixel() {\n    this._li = null;\n    this._pt = null;\n    this._originalPt = null;\n    this._ptScaled = null;\n    this._p0Scaled = null;\n    this._p1Scaled = null;\n    this._scaleFactor = null;\n    this._minx = null;\n    this._maxx = null;\n    this._miny = null;\n    this._maxy = null;\n    this._corner = new Array(4).fill(null);\n    this._safeEnv = null;\n    var pt = arguments[0],\n        scaleFactor = arguments[1],\n        li = arguments[2];\n    this._originalPt = pt;\n    this._pt = pt;\n    this._scaleFactor = scaleFactor;\n    this._li = li;\n    if (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n\n    if (scaleFactor !== 1.0) {\n      this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n      this._p0Scaled = new Coordinate();\n      this._p1Scaled = new Coordinate();\n    }\n\n    this.initCorners(this._pt);\n  }\n  extend(HotPixel.prototype, {\n    intersectsScaled: function intersectsScaled(p0, p1) {\n      var segMinx = Math.min(p0.x, p1.x);\n      var segMaxx = Math.max(p0.x, p1.x);\n      var segMiny = Math.min(p0.y, p1.y);\n      var segMaxy = Math.max(p0.y, p1.y);\n      var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n      if (isOutsidePixelEnv) return false;\n      var intersects = this.intersectsToleranceSquare(p0, p1);\n      Assert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n      return intersects;\n    },\n    initCorners: function initCorners(pt) {\n      var tolerance = 0.5;\n      this._minx = pt.x - tolerance;\n      this._maxx = pt.x + tolerance;\n      this._miny = pt.y - tolerance;\n      this._maxy = pt.y + tolerance;\n      this._corner[0] = new Coordinate(this._maxx, this._maxy);\n      this._corner[1] = new Coordinate(this._minx, this._maxy);\n      this._corner[2] = new Coordinate(this._minx, this._miny);\n      this._corner[3] = new Coordinate(this._maxx, this._miny);\n    },\n    intersects: function intersects(p0, p1) {\n      if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n      this.copyScaled(p0, this._p0Scaled);\n      this.copyScaled(p1, this._p1Scaled);\n      return this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n    },\n    scale: function scale(val) {\n      return Math.round(val * this._scaleFactor);\n    },\n    getCoordinate: function getCoordinate() {\n      return this._originalPt;\n    },\n    copyScaled: function copyScaled(p, pScaled) {\n      pScaled.x = this.scale(p.x);\n      pScaled.y = this.scale(p.y);\n    },\n    getSafeEnvelope: function getSafeEnvelope() {\n      if (this._safeEnv === null) {\n        var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n        this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n      }\n\n      return this._safeEnv;\n    },\n    intersectsPixelClosure: function intersectsPixelClosure(p0, p1) {\n      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\n      if (this._li.hasIntersection()) return true;\n      return false;\n    },\n    intersectsToleranceSquare: function intersectsToleranceSquare(p0, p1) {\n      var intersectsLeft = false;\n      var intersectsBottom = false;\n\n      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\n      if (this._li.isProper()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\n      if (this._li.isProper()) return true;\n      if (this._li.hasIntersection()) intersectsLeft = true;\n\n      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\n      if (this._li.isProper()) return true;\n      if (this._li.hasIntersection()) intersectsBottom = true;\n\n      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\n      if (this._li.isProper()) return true;\n      if (intersectsLeft && intersectsBottom) return true;\n      if (p0.equals(this._pt)) return true;\n      if (p1.equals(this._pt)) return true;\n      return false;\n    },\n    addSnappedNode: function addSnappedNode(segStr, segIndex) {\n      var p0 = segStr.getCoordinate(segIndex);\n      var p1 = segStr.getCoordinate(segIndex + 1);\n\n      if (this.intersects(p0, p1)) {\n        segStr.addIntersection(this.getCoordinate(), segIndex);\n        return true;\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return HotPixel;\n    }\n  });\n  HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\n  function MCIndexPointSnapper() {\n    this._index = null;\n    var index = arguments[0];\n    this._index = index;\n  }\n  extend(MCIndexPointSnapper.prototype, {\n    snap: function snap() {\n      if (arguments.length === 1) {\n        var hotPixel = arguments[0];\n        return this.snap(hotPixel, null, -1);\n      } else if (arguments.length === 3) {\n        var _hotPixel = arguments[0],\n            parentEdge = arguments[1],\n            hotPixelVertexIndex = arguments[2];\n\n        var pixelEnv = _hotPixel.getSafeEnvelope();\n\n        var hotPixelSnapAction = new HotPixelSnapAction(_hotPixel, parentEdge, hotPixelVertexIndex);\n\n        this._index.query(pixelEnv, {\n          interfaces_: function interfaces_() {\n            return [ItemVisitor];\n          },\n          visitItem: function visitItem(item) {\n            var testChain = item;\n            testChain.select(pixelEnv, hotPixelSnapAction);\n          }\n        });\n\n        return hotPixelSnapAction.isNodeAdded();\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return MCIndexPointSnapper;\n    }\n  });\n\n  function HotPixelSnapAction() {\n    MonotoneChainSelectAction.apply(this);\n    this._hotPixel = null;\n    this._parentEdge = null;\n    this._hotPixelVertexIndex = null;\n    this._isNodeAdded = false;\n    var hotPixel = arguments[0],\n        parentEdge = arguments[1],\n        hotPixelVertexIndex = arguments[2];\n    this._hotPixel = hotPixel;\n    this._parentEdge = parentEdge;\n    this._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n\n  inherits(HotPixelSnapAction, MonotoneChainSelectAction);\n  extend(HotPixelSnapAction.prototype, {\n    isNodeAdded: function isNodeAdded() {\n      return this._isNodeAdded;\n    },\n    select: function select() {\n      if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain) {\n        var mc = arguments[0],\n            startIndex = arguments[1];\n        var ss = mc.getContext();\n\n        if (this._parentEdge !== null) {\n          if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;\n        }\n\n        this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n      } else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return HotPixelSnapAction;\n    }\n  });\n  MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\n  function InteriorIntersectionFinderAdder() {\n    this._li = null;\n    this._interiorIntersections = null;\n    var li = arguments[0];\n    this._li = li;\n    this._interiorIntersections = new ArrayList();\n  }\n  extend(InteriorIntersectionFinderAdder.prototype, {\n    processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      var p00 = e0.getCoordinates()[segIndex0];\n      var p01 = e0.getCoordinates()[segIndex0 + 1];\n      var p10 = e1.getCoordinates()[segIndex1];\n      var p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        if (this._li.isInteriorIntersection()) {\n          for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n            this._interiorIntersections.add(this._li.getIntersection(intIndex));\n          }\n\n          e0.addIntersections(this._li, segIndex0, 0);\n          e1.addIntersections(this._li, segIndex1, 1);\n        }\n      }\n    },\n    isDone: function isDone() {\n      return false;\n    },\n    getInteriorIntersections: function getInteriorIntersections() {\n      return this._interiorIntersections;\n    },\n    interfaces_: function interfaces_() {\n      return [SegmentIntersector$1];\n    },\n    getClass: function getClass() {\n      return InteriorIntersectionFinderAdder;\n    }\n  });\n\n  function MCIndexSnapRounder() {\n    this._pm = null;\n    this._li = null;\n    this._scaleFactor = null;\n    this._noder = null;\n    this._pointSnapper = null;\n    this._nodedSegStrings = null;\n    var pm = arguments[0];\n    this._pm = pm;\n    this._li = new RobustLineIntersector();\n\n    this._li.setPrecisionModel(pm);\n\n    this._scaleFactor = pm.getScale();\n  }\n  extend(MCIndexSnapRounder.prototype, {\n    checkCorrectness: function checkCorrectness(inputSegmentStrings) {\n      var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n      var nv = new NodingValidator(resultSegStrings);\n\n      try {\n        nv.checkValid();\n      } catch (ex) {\n        if (ex instanceof Exception) {\n          ex.printStackTrace();\n        } else throw ex;\n      } finally {}\n    },\n    getNodedSubstrings: function getNodedSubstrings() {\n      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n    },\n    snapRound: function snapRound(segStrings, li) {\n      var intersections = this.findInteriorIntersections(segStrings, li);\n      this.computeIntersectionSnaps(intersections);\n      this.computeVertexSnaps(segStrings);\n    },\n    findInteriorIntersections: function findInteriorIntersections(segStrings, li) {\n      var intFinderAdder = new InteriorIntersectionFinderAdder(li);\n\n      this._noder.setSegmentIntersector(intFinderAdder);\n\n      this._noder.computeNodes(segStrings);\n\n      return intFinderAdder.getInteriorIntersections();\n    },\n    computeVertexSnaps: function computeVertexSnaps() {\n      if (hasInterface(arguments[0], Collection)) {\n        var edges = arguments[0];\n\n        for (var i0 = edges.iterator(); i0.hasNext();) {\n          var edge0 = i0.next();\n          this.computeVertexSnaps(edge0);\n        }\n      } else if (arguments[0] instanceof NodedSegmentString) {\n        var e = arguments[0];\n        var pts0 = e.getCoordinates();\n\n        for (var i = 0; i < pts0.length; i++) {\n          var hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n\n          var isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n\n          if (isNodeAdded) {\n            e.addIntersection(pts0[i], i);\n          }\n        }\n      }\n    },\n    computeNodes: function computeNodes(inputSegmentStrings) {\n      this._nodedSegStrings = inputSegmentStrings;\n      this._noder = new MCIndexNoder();\n      this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n      this.snapRound(inputSegmentStrings, this._li);\n    },\n    computeIntersectionSnaps: function computeIntersectionSnaps(snapPts) {\n      for (var it = snapPts.iterator(); it.hasNext();) {\n        var snapPt = it.next();\n        var hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n\n        this._pointSnapper.snap(hotPixel);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [Noder];\n    },\n    getClass: function getClass() {\n      return MCIndexSnapRounder;\n    }\n  });\n\n  function BufferOp() {\n    this._argGeom = null;\n    this._distance = null;\n    this._bufParams = new BufferParameters();\n    this._resultGeometry = null;\n    this._saveException = null;\n\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      this._argGeom = g;\n    } else if (arguments.length === 2) {\n      var _g = arguments[0],\n          bufParams = arguments[1];\n      this._argGeom = _g;\n      this._bufParams = bufParams;\n    }\n  }\n  extend(BufferOp.prototype, {\n    bufferFixedPrecision: function bufferFixedPrecision(fixedPM) {\n      var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n      var bufBuilder = new BufferBuilder(this._bufParams);\n      bufBuilder.setWorkingPrecisionModel(fixedPM);\n      bufBuilder.setNoder(noder);\n      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n    },\n    bufferReducedPrecision: function bufferReducedPrecision() {\n      if (arguments.length === 0) {\n        for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n          try {\n            this.bufferReducedPrecision(precDigits);\n          } catch (ex) {\n            if (ex instanceof TopologyException) {\n              this._saveException = ex;\n            } else throw ex;\n          } finally {}\n\n          if (this._resultGeometry !== null) return null;\n        }\n\n        throw this._saveException;\n      } else if (arguments.length === 1) {\n        var precisionDigits = arguments[0];\n        var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n        var fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n        this.bufferFixedPrecision(fixedPM);\n      }\n    },\n    computeGeometry: function computeGeometry() {\n      this.bufferOriginalPrecision();\n      if (this._resultGeometry !== null) return null;\n\n      var argPM = this._argGeom.getFactory().getPrecisionModel();\n\n      if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();\n    },\n    setQuadrantSegments: function setQuadrantSegments(quadrantSegments) {\n      this._bufParams.setQuadrantSegments(quadrantSegments);\n    },\n    bufferOriginalPrecision: function bufferOriginalPrecision() {\n      try {\n        var bufBuilder = new BufferBuilder(this._bufParams);\n        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n      } catch (ex) {\n        if (ex instanceof RuntimeException) {\n          this._saveException = ex;\n        } else throw ex;\n      } finally {}\n    },\n    getResultGeometry: function getResultGeometry(distance) {\n      this._distance = distance;\n      this.computeGeometry();\n      return this._resultGeometry;\n    },\n    setEndCapStyle: function setEndCapStyle(endCapStyle) {\n      this._bufParams.setEndCapStyle(endCapStyle);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return BufferOp;\n    }\n  });\n\n  BufferOp.bufferOp = function () {\n    if (arguments.length === 2) {\n      var g = arguments[0],\n          distance = arguments[1];\n      var gBuf = new BufferOp(g);\n      var geomBuf = gBuf.getResultGeometry(distance);\n      return geomBuf;\n    } else if (arguments.length === 3) {\n      if (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n        var _g2 = arguments[0],\n            _distance = arguments[1],\n            quadrantSegments = arguments[2];\n        var bufOp = new BufferOp(_g2);\n        bufOp.setQuadrantSegments(quadrantSegments);\n        var geomBuf = bufOp.getResultGeometry(_distance);\n        return geomBuf;\n      } else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === \"number\") {\n        var _g3 = arguments[0],\n            _distance2 = arguments[1],\n            params = arguments[2];\n        var bufOp = new BufferOp(_g3, params);\n        var geomBuf = bufOp.getResultGeometry(_distance2);\n        return geomBuf;\n      }\n    } else if (arguments.length === 4) {\n      var _g4 = arguments[0],\n          _distance3 = arguments[1],\n          _quadrantSegments = arguments[2],\n          endCapStyle = arguments[3];\n      var bufOp = new BufferOp(_g4);\n      bufOp.setQuadrantSegments(_quadrantSegments);\n      bufOp.setEndCapStyle(endCapStyle);\n      var geomBuf = bufOp.getResultGeometry(_distance3);\n      return geomBuf;\n    }\n  };\n\n  BufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n    var env = g.getEnvelopeInternal();\n    var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n    var expandByDistance = distance > 0.0 ? distance : 0.0;\n    var bufEnvMax = envMax + 2 * expandByDistance;\n    var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n    var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n    var scaleFactor = Math.pow(10.0, minUnitLog10);\n    return scaleFactor;\n  };\n\n  BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\n  BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\n  BufferOp.MAX_PRECISION_DIGITS = 12;\n\n\n\n  var buffer = /*#__PURE__*/Object.freeze({\n    BufferOp: BufferOp,\n    BufferParameters: BufferParameters\n  });\n\n  function PolygonExtracter() {\n    this._comps = null;\n    var comps = arguments[0];\n    this._comps = comps;\n  }\n  extend(PolygonExtracter.prototype, {\n    filter: function filter(geom) {\n      if (geom instanceof Polygon) this._comps.add(geom);\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryFilter];\n    },\n    getClass: function getClass() {\n      return PolygonExtracter;\n    }\n  });\n\n  PolygonExtracter.getPolygons = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      return PolygonExtracter.getPolygons(geom, new ArrayList());\n    } else if (arguments.length === 2) {\n      var _geom = arguments[0],\n          list = arguments[1];\n\n      if (_geom instanceof Polygon) {\n        list.add(_geom);\n      } else if (_geom instanceof GeometryCollection) {\n        _geom.apply(new PolygonExtracter(list));\n      }\n\n      return list;\n    }\n  };\n\n  function GeometryLocation() {\n    this._component = null;\n    this._segIndex = null;\n    this._pt = null;\n\n    if (arguments.length === 2) {\n      var component = arguments[0],\n          pt = arguments[1];\n      GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n    } else if (arguments.length === 3) {\n      var _component = arguments[0],\n          segIndex = arguments[1],\n          _pt = arguments[2];\n      this._component = _component;\n      this._segIndex = segIndex;\n      this._pt = _pt;\n    }\n  }\n  extend(GeometryLocation.prototype, {\n    isInsideArea: function isInsideArea() {\n      return this._segIndex === GeometryLocation.INSIDE_AREA;\n    },\n    getCoordinate: function getCoordinate() {\n      return this._pt;\n    },\n    getGeometryComponent: function getGeometryComponent() {\n      return this._component;\n    },\n    getSegmentIndex: function getSegmentIndex() {\n      return this._segIndex;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryLocation;\n    }\n  });\n  GeometryLocation.INSIDE_AREA = -1;\n\n  function PointExtracter() {\n    this._pts = null;\n    var pts = arguments[0];\n    this._pts = pts;\n  }\n  extend(PointExtracter.prototype, {\n    filter: function filter(geom) {\n      if (geom instanceof Point) this._pts.add(geom);\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryFilter];\n    },\n    getClass: function getClass() {\n      return PointExtracter;\n    }\n  });\n\n  PointExtracter.getPoints = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n\n      if (geom instanceof Point) {\n        return Collections.singletonList(geom);\n      }\n\n      return PointExtracter.getPoints(geom, new ArrayList());\n    } else if (arguments.length === 2) {\n      var _geom = arguments[0],\n          list = arguments[1];\n\n      if (_geom instanceof Point) {\n        list.add(_geom);\n      } else if (_geom instanceof GeometryCollection) {\n        _geom.apply(new PointExtracter(list));\n      }\n\n      return list;\n    }\n  };\n\n  function ConnectedElementLocationFilter() {\n    this._locations = null;\n    var locations = arguments[0];\n    this._locations = locations;\n  }\n  extend(ConnectedElementLocationFilter.prototype, {\n    filter: function filter(geom) {\n      if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryFilter];\n    },\n    getClass: function getClass() {\n      return ConnectedElementLocationFilter;\n    }\n  });\n\n  ConnectedElementLocationFilter.getLocations = function (geom) {\n    var locations = new ArrayList();\n    geom.apply(new ConnectedElementLocationFilter(locations));\n    return locations;\n  };\n\n  function DistanceOp() {\n    this._geom = null;\n    this._terminateDistance = 0.0;\n    this._ptLocator = new PointLocator();\n    this._minDistanceLocation = null;\n    this._minDistance = Double.MAX_VALUE;\n\n    if (arguments.length === 2) {\n      var g0 = arguments[0],\n          g1 = arguments[1];\n      DistanceOp.call(this, g0, g1, 0.0);\n    } else if (arguments.length === 3) {\n      var _g = arguments[0],\n          _g2 = arguments[1],\n          terminateDistance = arguments[2];\n      this._geom = new Array(2).fill(null);\n      this._geom[0] = _g;\n      this._geom[1] = _g2;\n      this._terminateDistance = terminateDistance;\n    }\n  }\n  extend(DistanceOp.prototype, {\n    computeContainmentDistance: function computeContainmentDistance() {\n      if (arguments.length === 0) {\n        var locPtPoly = new Array(2).fill(null);\n        this.computeContainmentDistance(0, locPtPoly);\n        if (this._minDistance <= this._terminateDistance) return null;\n        this.computeContainmentDistance(1, locPtPoly);\n      } else if (arguments.length === 2) {\n        var polyGeomIndex = arguments[0],\n            _locPtPoly = arguments[1];\n        var polyGeom = this._geom[polyGeomIndex];\n        if (polyGeom.getDimension() < 2) return null;\n        var locationsIndex = 1 - polyGeomIndex;\n        var polys = PolygonExtracter.getPolygons(polyGeom);\n\n        if (polys.size() > 0) {\n          var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n          this.computeContainmentDistance(insideLocs, polys, _locPtPoly);\n\n          if (this._minDistance <= this._terminateDistance) {\n            this._minDistanceLocation[locationsIndex] = _locPtPoly[0];\n            this._minDistanceLocation[polyGeomIndex] = _locPtPoly[1];\n            return null;\n          }\n        }\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n          var locs = arguments[0],\n              _polys = arguments[1],\n              _locPtPoly2 = arguments[2];\n\n          for (var i = 0; i < locs.size(); i++) {\n            var loc = locs.get(i);\n\n            for (var j = 0; j < _polys.size(); j++) {\n              this.computeContainmentDistance(loc, _polys.get(j), _locPtPoly2);\n              if (this._minDistance <= this._terminateDistance) return null;\n            }\n          }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n          var ptLoc = arguments[0],\n              poly = arguments[1],\n              _locPtPoly3 = arguments[2];\n          var pt = ptLoc.getCoordinate();\n\n          if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n            this._minDistance = 0.0;\n            _locPtPoly3[0] = ptLoc;\n            _locPtPoly3[1] = new GeometryLocation(poly, pt);\n            return null;\n          }\n        }\n      }\n    },\n    computeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(lines, points, locGeom) {\n      for (var i = 0; i < lines.size(); i++) {\n        var line = lines.get(i);\n\n        for (var j = 0; j < points.size(); j++) {\n          var pt = points.get(j);\n          this.computeMinDistance(line, pt, locGeom);\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    },\n    computeFacetDistance: function computeFacetDistance() {\n      var locGeom = new Array(2).fill(null);\n      var lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n      var lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n      var pts0 = PointExtracter.getPoints(this._geom[0]);\n      var pts1 = PointExtracter.getPoints(this._geom[1]);\n      this.computeMinDistanceLines(lines0, lines1, locGeom);\n      this.updateMinDistance(locGeom, false);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n      this.updateMinDistance(locGeom, false);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n      this.updateMinDistance(locGeom, true);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistancePoints(pts0, pts1, locGeom);\n      this.updateMinDistance(locGeom, false);\n    },\n    nearestLocations: function nearestLocations() {\n      this.computeMinDistance();\n      return this._minDistanceLocation;\n    },\n    updateMinDistance: function updateMinDistance(locGeom, flip) {\n      if (locGeom[0] === null) return null;\n\n      if (flip) {\n        this._minDistanceLocation[0] = locGeom[1];\n        this._minDistanceLocation[1] = locGeom[0];\n      } else {\n        this._minDistanceLocation[0] = locGeom[0];\n        this._minDistanceLocation[1] = locGeom[1];\n      }\n    },\n    nearestPoints: function nearestPoints() {\n      this.computeMinDistance();\n      var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n      return nearestPts;\n    },\n    computeMinDistance: function computeMinDistance() {\n      if (arguments.length === 0) {\n        if (this._minDistanceLocation !== null) return null;\n        this._minDistanceLocation = new Array(2).fill(null);\n        this.computeContainmentDistance();\n        if (this._minDistance <= this._terminateDistance) return null;\n        this.computeFacetDistance();\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n          var line = arguments[0],\n              pt = arguments[1],\n              locGeom = arguments[2];\n          if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;\n          var coord0 = line.getCoordinates();\n          var coord = pt.getCoordinate();\n\n          for (var i = 0; i < coord0.length - 1; i++) {\n            var dist = Distance.pointToSegment(coord, coord0[i], coord0[i + 1]);\n\n            if (dist < this._minDistance) {\n              this._minDistance = dist;\n              var seg = new LineSegment(coord0[i], coord0[i + 1]);\n              var segClosestPoint = seg.closestPoint(coord);\n              locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n              locGeom[1] = new GeometryLocation(pt, 0, coord);\n            }\n\n            if (this._minDistance <= this._terminateDistance) return null;\n          }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n          var line0 = arguments[0],\n              line1 = arguments[1],\n              _locGeom = arguments[2];\n          if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;\n          var coord0 = line0.getCoordinates();\n          var coord1 = line1.getCoordinates();\n\n          for (var i = 0; i < coord0.length - 1; i++) {\n            for (var j = 0; j < coord1.length - 1; j++) {\n              var dist = Distance.segmentToSegment(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n\n              if (dist < this._minDistance) {\n                this._minDistance = dist;\n                var seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n                var seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n                var closestPt = seg0.closestPoints(seg1);\n                _locGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n                _locGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n              }\n\n              if (this._minDistance <= this._terminateDistance) return null;\n            }\n          }\n        }\n      }\n    },\n    computeMinDistancePoints: function computeMinDistancePoints(points0, points1, locGeom) {\n      for (var i = 0; i < points0.size(); i++) {\n        var pt0 = points0.get(i);\n\n        for (var j = 0; j < points1.size(); j++) {\n          var pt1 = points1.get(j);\n          var dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n\n          if (dist < this._minDistance) {\n            this._minDistance = dist;\n            locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n            locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n          }\n\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    },\n    distance: function distance() {\n      if (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException(\"null geometries are not supported\");\n      if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;\n      this.computeMinDistance();\n      return this._minDistance;\n    },\n    computeMinDistanceLines: function computeMinDistanceLines(lines0, lines1, locGeom) {\n      for (var i = 0; i < lines0.size(); i++) {\n        var line0 = lines0.get(i);\n\n        for (var j = 0; j < lines1.size(); j++) {\n          var line1 = lines1.get(j);\n          this.computeMinDistance(line0, line1, locGeom);\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DistanceOp;\n    }\n  });\n\n  DistanceOp.distance = function (g0, g1) {\n    var distOp = new DistanceOp(g0, g1);\n    return distOp.distance();\n  };\n\n  DistanceOp.isWithinDistance = function (g0, g1, distance) {\n    var envDist = g0.getEnvelopeInternal().distance(g1.getEnvelopeInternal());\n    if (envDist > distance) return false;\n    var distOp = new DistanceOp(g0, g1, distance);\n    return distOp.distance() <= distance;\n  };\n\n  DistanceOp.nearestPoints = function (g0, g1) {\n    var distOp = new DistanceOp(g0, g1);\n    return distOp.nearestPoints();\n  };\n\n\n\n  var distance = /*#__PURE__*/Object.freeze({\n    DistanceOp: DistanceOp\n  });\n\n  function EdgeString() {\n    this._factory = null;\n    this._directedEdges = new ArrayList();\n    this._coordinates = null;\n    var factory = arguments[0];\n    this._factory = factory;\n  }\n  extend(EdgeString.prototype, {\n    getCoordinates: function getCoordinates() {\n      if (this._coordinates === null) {\n        var forwardDirectedEdges = 0;\n        var reverseDirectedEdges = 0;\n        var coordinateList = new CoordinateList();\n\n        for (var i = this._directedEdges.iterator(); i.hasNext();) {\n          var directedEdge = i.next();\n\n          if (directedEdge.getEdgeDirection()) {\n            forwardDirectedEdges++;\n          } else {\n            reverseDirectedEdges++;\n          }\n\n          coordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n        }\n\n        this._coordinates = coordinateList.toCoordinateArray();\n\n        if (reverseDirectedEdges > forwardDirectedEdges) {\n          CoordinateArrays.reverse(this._coordinates);\n        }\n      }\n\n      return this._coordinates;\n    },\n    toLineString: function toLineString() {\n      return this._factory.createLineString(this.getCoordinates());\n    },\n    add: function add(directedEdge) {\n      this._directedEdges.add(directedEdge);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeString;\n    }\n  });\n\n  function GraphComponent$1() {\n    this._isMarked = false;\n    this._isVisited = false;\n    this._data = null;\n  }\n  extend(GraphComponent$1.prototype, {\n    setVisited: function setVisited(isVisited) {\n      this._isVisited = isVisited;\n    },\n    isMarked: function isMarked() {\n      return this._isMarked;\n    },\n    setData: function setData(data) {\n      this._data = data;\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    setMarked: function setMarked(isMarked) {\n      this._isMarked = isMarked;\n    },\n    getContext: function getContext() {\n      return this._data;\n    },\n    isVisited: function isVisited() {\n      return this._isVisited;\n    },\n    setContext: function setContext(data) {\n      this._data = data;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GraphComponent$1;\n    }\n  });\n\n  GraphComponent$1.getComponentWithVisitedState = function (i, visitedState) {\n    while (i.hasNext()) {\n      var comp = i.next();\n      if (comp.isVisited() === visitedState) return comp;\n    }\n\n    return null;\n  };\n\n  GraphComponent$1.setVisited = function (i, visited) {\n    while (i.hasNext()) {\n      var comp = i.next();\n      comp.setVisited(visited);\n    }\n  };\n\n  GraphComponent$1.setMarked = function (i, marked) {\n    while (i.hasNext()) {\n      var comp = i.next();\n      comp.setMarked(marked);\n    }\n  };\n\n  function DirectedEdge$1() {\n    GraphComponent$1.apply(this);\n    this._parentEdge = null;\n    this._from = null;\n    this._to = null;\n    this._p0 = null;\n    this._p1 = null;\n    this._sym = null;\n    this._edgeDirection = null;\n    this._quadrant = null;\n    this._angle = null;\n    var from = arguments[0],\n        to = arguments[1],\n        directionPt = arguments[2],\n        edgeDirection = arguments[3];\n    this._from = from;\n    this._to = to;\n    this._edgeDirection = edgeDirection;\n    this._p0 = from.getCoordinate();\n    this._p1 = directionPt;\n    var dx = this._p1.x - this._p0.x;\n    var dy = this._p1.y - this._p0.y;\n    this._quadrant = Quadrant.quadrant(dx, dy);\n    this._angle = Math.atan2(dy, dx);\n  }\n  inherits(DirectedEdge$1, GraphComponent$1);\n  extend(DirectedEdge$1.prototype, {\n    isRemoved: function isRemoved() {\n      return this._parentEdge === null;\n    },\n    compareDirection: function compareDirection(e) {\n      if (this._quadrant > e._quadrant) return 1;\n      if (this._quadrant < e._quadrant) return -1;\n      return Orientation.index(e._p0, e._p1, this._p1);\n    },\n    getCoordinate: function getCoordinate() {\n      return this._from.getCoordinate();\n    },\n    print: function print(out) {\n      var className = this.getClass().getName();\n      var lastDotPos = className.lastIndexOf('.');\n      var name = className.substring(lastDotPos + 1);\n      out.print(\"  \" + name + \": \" + this._p0 + \" - \" + this._p1 + \" \" + this._quadrant + \":\" + this._angle);\n    },\n    getDirectionPt: function getDirectionPt() {\n      return this._p1;\n    },\n    getAngle: function getAngle() {\n      return this._angle;\n    },\n    compareTo: function compareTo(obj) {\n      var de = obj;\n      return this.compareDirection(de);\n    },\n    getFromNode: function getFromNode() {\n      return this._from;\n    },\n    getSym: function getSym() {\n      return this._sym;\n    },\n    setEdge: function setEdge(parentEdge) {\n      this._parentEdge = parentEdge;\n    },\n    remove: function remove() {\n      this._sym = null;\n      this._parentEdge = null;\n    },\n    getEdge: function getEdge() {\n      return this._parentEdge;\n    },\n    getQuadrant: function getQuadrant() {\n      return this._quadrant;\n    },\n    setSym: function setSym(sym) {\n      this._sym = sym;\n    },\n    getToNode: function getToNode() {\n      return this._to;\n    },\n    getEdgeDirection: function getEdgeDirection() {\n      return this._edgeDirection;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return DirectedEdge$1;\n    }\n  });\n\n  DirectedEdge$1.toEdges = function (dirEdges) {\n    var edges = new ArrayList();\n\n    for (var i = dirEdges.iterator(); i.hasNext();) {\n      edges.add(i.next()._parentEdge);\n    }\n\n    return edges;\n  };\n\n  function LineMergeDirectedEdge() {\n    var from = arguments[0],\n        to = arguments[1],\n        directionPt = arguments[2],\n        edgeDirection = arguments[3];\n    DirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits(LineMergeDirectedEdge, DirectedEdge$1);\n  extend(LineMergeDirectedEdge.prototype, {\n    getNext: function getNext() {\n      if (this.getToNode().getDegree() !== 2) {\n        return null;\n      }\n\n      if (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {\n        return this.getToNode().getOutEdges().getEdges().get(1);\n      }\n\n      Assert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n      return this.getToNode().getOutEdges().getEdges().get(0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineMergeDirectedEdge;\n    }\n  });\n\n  function Edge$1() {\n    GraphComponent$1.apply(this);\n    this._dirEdge = null;\n\n    if (arguments.length === 0) ; else if (arguments.length === 2) {\n      var de0 = arguments[0],\n          de1 = arguments[1];\n      this.setDirectedEdges(de0, de1);\n    }\n  }\n  inherits(Edge$1, GraphComponent$1);\n  extend(Edge$1.prototype, {\n    isRemoved: function isRemoved() {\n      return this._dirEdge === null;\n    },\n    setDirectedEdges: function setDirectedEdges(de0, de1) {\n      this._dirEdge = [de0, de1];\n      de0.setEdge(this);\n      de1.setEdge(this);\n      de0.setSym(de1);\n      de1.setSym(de0);\n      de0.getFromNode().addOutEdge(de0);\n      de1.getFromNode().addOutEdge(de1);\n    },\n    getDirEdge: function getDirEdge() {\n      if (Number.isInteger(arguments[0])) {\n        var i = arguments[0];\n        return this._dirEdge[i];\n      } else if (arguments[0] instanceof Node$3) {\n        var fromNode = arguments[0];\n        if (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];\n        if (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];\n        return null;\n      }\n    },\n    remove: function remove() {\n      this._dirEdge = null;\n    },\n    getOppositeNode: function getOppositeNode(node) {\n      if (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();\n      if (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();\n      return null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Edge$1;\n    }\n  });\n\n  function DirectedEdgeStar$1() {\n    this._outEdges = new ArrayList();\n    this._sorted = false;\n  }\n  extend(DirectedEdgeStar$1.prototype, {\n    getNextEdge: function getNextEdge(dirEdge) {\n      var i = this.getIndex(dirEdge);\n      return this._outEdges.get(this.getIndex(i + 1));\n    },\n    getCoordinate: function getCoordinate() {\n      var it = this.iterator();\n      if (!it.hasNext()) return null;\n      var e = it.next();\n      return e.getCoordinate();\n    },\n    iterator: function iterator() {\n      this.sortEdges();\n      return this._outEdges.iterator();\n    },\n    sortEdges: function sortEdges() {\n      if (!this._sorted) {\n        Collections.sort(this._outEdges);\n        this._sorted = true;\n      }\n    },\n    remove: function remove(de) {\n      this._outEdges.remove(de);\n    },\n    getEdges: function getEdges() {\n      this.sortEdges();\n      return this._outEdges;\n    },\n    getNextCWEdge: function getNextCWEdge(dirEdge) {\n      var i = this.getIndex(dirEdge);\n      return this._outEdges.get(this.getIndex(i - 1));\n    },\n    getIndex: function getIndex() {\n      if (arguments[0] instanceof Edge$1) {\n        var edge = arguments[0];\n        this.sortEdges();\n\n        for (var i = 0; i < this._outEdges.size(); i++) {\n          var de = this._outEdges.get(i);\n\n          if (de.getEdge() === edge) return i;\n        }\n\n        return -1;\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        var dirEdge = arguments[0];\n        this.sortEdges();\n\n        for (var i = 0; i < this._outEdges.size(); i++) {\n          var de = this._outEdges.get(i);\n\n          if (de === dirEdge) return i;\n        }\n\n        return -1;\n      } else if (Number.isInteger(arguments[0])) {\n        var _i = arguments[0];\n\n        var modi = _i % this._outEdges.size();\n\n        if (modi < 0) modi += this._outEdges.size();\n        return modi;\n      }\n    },\n    add: function add(de) {\n      this._outEdges.add(de);\n\n      this._sorted = false;\n    },\n    getDegree: function getDegree() {\n      return this._outEdges.size();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DirectedEdgeStar$1;\n    }\n  });\n\n  function Node$3() {\n    GraphComponent$1.apply(this);\n    this._pt = null;\n    this._deStar = null;\n\n    if (arguments.length === 1) {\n      var pt = arguments[0];\n      Node$3.call(this, pt, new DirectedEdgeStar$1());\n    } else if (arguments.length === 2) {\n      var _pt = arguments[0],\n          deStar = arguments[1];\n      this._pt = _pt;\n      this._deStar = deStar;\n    }\n  }\n  inherits(Node$3, GraphComponent$1);\n  extend(Node$3.prototype, {\n    isRemoved: function isRemoved() {\n      return this._pt === null;\n    },\n    addOutEdge: function addOutEdge(de) {\n      this._deStar.add(de);\n    },\n    getCoordinate: function getCoordinate() {\n      return this._pt;\n    },\n    getOutEdges: function getOutEdges() {\n      return this._deStar;\n    },\n    remove: function remove() {\n      if (arguments.length === 0) {\n        this._pt = null;\n      } else if (arguments.length === 1) {\n        var de = arguments[0];\n\n        this._deStar.remove(de);\n      }\n    },\n    getIndex: function getIndex(edge) {\n      return this._deStar.getIndex(edge);\n    },\n    getDegree: function getDegree() {\n      return this._deStar.getDegree();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Node$3;\n    }\n  });\n\n  Node$3.getEdgesBetween = function (node0, node1) {\n    var edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());\n    var commonEdges = new HashSet(edges0);\n    var edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());\n    commonEdges.retainAll(edges1);\n    return commonEdges;\n  };\n\n  function LineMergeEdge() {\n    Edge$1.apply(this);\n    this._line = null;\n    var line = arguments[0];\n    this._line = line;\n  }\n  inherits(LineMergeEdge, Edge$1);\n  extend(LineMergeEdge.prototype, {\n    getLine: function getLine() {\n      return this._line;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineMergeEdge;\n    }\n  });\n\n  function NodeMap$1() {\n    this._nodeMap = new TreeMap();\n  }\n  extend(NodeMap$1.prototype, {\n    find: function find(coord) {\n      return this._nodeMap.get(coord);\n    },\n    iterator: function iterator() {\n      return this._nodeMap.values().iterator();\n    },\n    remove: function remove(pt) {\n      return this._nodeMap.remove(pt);\n    },\n    values: function values() {\n      return this._nodeMap.values();\n    },\n    add: function add(n) {\n      this._nodeMap.put(n.getCoordinate(), n);\n\n      return n;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return NodeMap$1;\n    }\n  });\n\n  function PlanarGraph$1() {\n    this._edges = new HashSet();\n    this._dirEdges = new HashSet();\n    this._nodeMap = new NodeMap$1();\n  }\n  extend(PlanarGraph$1.prototype, {\n    findNodesOfDegree: function findNodesOfDegree(degree) {\n      var nodesFound = new ArrayList();\n\n      for (var i = this.nodeIterator(); i.hasNext();) {\n        var node = i.next();\n        if (node.getDegree() === degree) nodesFound.add(node);\n      }\n\n      return nodesFound;\n    },\n    dirEdgeIterator: function dirEdgeIterator() {\n      return this._dirEdges.iterator();\n    },\n    edgeIterator: function edgeIterator() {\n      return this._edges.iterator();\n    },\n    remove: function remove() {\n      if (arguments[0] instanceof Edge$1) {\n        var _edge = arguments[0];\n        this.remove(_edge.getDirEdge(0));\n        this.remove(_edge.getDirEdge(1));\n\n        this._edges.remove(_edge);\n\n        _edge.remove();\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        var _de = arguments[0];\n\n        var sym = _de.getSym();\n\n        if (sym !== null) sym.setSym(null);\n\n        _de.getFromNode().remove(_de);\n\n        _de.remove();\n\n        this._dirEdges.remove(_de);\n      } else if (arguments[0] instanceof Node$3) {\n        var node = arguments[0];\n        var outEdges = node.getOutEdges().getEdges();\n\n        for (var i = outEdges.iterator(); i.hasNext();) {\n          var de = i.next();\n          var sym = de.getSym();\n          if (sym !== null) this.remove(sym);\n\n          this._dirEdges.remove(de);\n\n          var edge = de.getEdge();\n\n          if (edge !== null) {\n            this._edges.remove(edge);\n          }\n        }\n\n        this._nodeMap.remove(node.getCoordinate());\n\n        node.remove();\n      }\n    },\n    findNode: function findNode(pt) {\n      return this._nodeMap.find(pt);\n    },\n    getEdges: function getEdges() {\n      return this._edges;\n    },\n    nodeIterator: function nodeIterator() {\n      return this._nodeMap.iterator();\n    },\n    contains: function contains() {\n      if (arguments[0] instanceof Edge$1) {\n        var e = arguments[0];\n        return this._edges.contains(e);\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        var de = arguments[0];\n        return this._dirEdges.contains(de);\n      }\n    },\n    add: function add() {\n      if (arguments[0] instanceof Node$3) {\n        var node = arguments[0];\n\n        this._nodeMap.add(node);\n      } else if (arguments[0] instanceof Edge$1) {\n        var edge = arguments[0];\n\n        this._edges.add(edge);\n\n        this.add(edge.getDirEdge(0));\n        this.add(edge.getDirEdge(1));\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        var dirEdge = arguments[0];\n\n        this._dirEdges.add(dirEdge);\n      }\n    },\n    getNodes: function getNodes() {\n      return this._nodeMap.values();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PlanarGraph$1;\n    }\n  });\n\n  function LineMergeGraph() {\n    PlanarGraph$1.apply(this);\n  }\n  inherits(LineMergeGraph, PlanarGraph$1);\n  extend(LineMergeGraph.prototype, {\n    addEdge: function addEdge(lineString) {\n      if (lineString.isEmpty()) {\n        return null;\n      }\n\n      var coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n      if (coordinates.length <= 1) return null;\n      var startCoordinate = coordinates[0];\n      var endCoordinate = coordinates[coordinates.length - 1];\n      var startNode = this.getNode(startCoordinate);\n      var endNode = this.getNode(endCoordinate);\n      var directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n      var directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n      var edge = new LineMergeEdge(lineString);\n      edge.setDirectedEdges(directedEdge0, directedEdge1);\n      this.add(edge);\n    },\n    getNode: function getNode(coordinate) {\n      var node = this.findNode(coordinate);\n\n      if (node === null) {\n        node = new Node$3(coordinate);\n        this.add(node);\n      }\n\n      return node;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineMergeGraph;\n    }\n  });\n\n  function LineMerger() {\n    this._graph = new LineMergeGraph();\n    this._mergedLineStrings = null;\n    this._factory = null;\n    this._edgeStrings = null;\n  }\n  extend(LineMerger.prototype, {\n    buildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {\n      for (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n        var node = i.next();\n\n        if (!node.isMarked()) {\n          Assert.isTrue(node.getDegree() === 2);\n          this.buildEdgeStringsStartingAt(node);\n          node.setMarked(true);\n        }\n      }\n    },\n    buildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {\n      for (var i = this._graph.getNodes().iterator(); i.hasNext();) {\n        var node = i.next();\n\n        if (node.getDegree() !== 2) {\n          this.buildEdgeStringsStartingAt(node);\n          node.setMarked(true);\n        }\n      }\n    },\n    buildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {\n      this.buildEdgeStringsForNonDegree2Nodes();\n    },\n    getMergedLineStrings: function getMergedLineStrings() {\n      this.merge();\n      return this._mergedLineStrings;\n    },\n    buildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(node) {\n      for (var i = node.getOutEdges().iterator(); i.hasNext();) {\n        var directedEdge = i.next();\n\n        if (directedEdge.getEdge().isMarked()) {\n          continue;\n        }\n\n        this._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n      }\n    },\n    merge: function merge() {\n      if (this._mergedLineStrings !== null) {\n        return null;\n      }\n\n      GraphComponent$1.setMarked(this._graph.nodeIterator(), false);\n      GraphComponent$1.setMarked(this._graph.edgeIterator(), false);\n      this._edgeStrings = new ArrayList();\n      this.buildEdgeStringsForObviousStartNodes();\n      this.buildEdgeStringsForIsolatedLoops();\n      this._mergedLineStrings = new ArrayList();\n\n      for (var i = this._edgeStrings.iterator(); i.hasNext();) {\n        var edgeString = i.next();\n\n        this._mergedLineStrings.add(edgeString.toLineString());\n      }\n    },\n    buildEdgeStringStartingWith: function buildEdgeStringStartingWith(start) {\n      var edgeString = new EdgeString(this._factory);\n      var current = start;\n\n      do {\n        edgeString.add(current);\n        current.getEdge().setMarked(true);\n        current = current.getNext();\n      } while (current !== null && current !== start);\n\n      return edgeString;\n    },\n    add: function add() {\n      if (arguments[0] instanceof Geometry) {\n        var _geometry = arguments[0];\n\n        _geometry.apply({\n          interfaces_: function interfaces_() {\n            return [GeometryComponentFilter];\n          },\n          filter: function filter(component) {\n            if (component instanceof LineString) {\n              this.add(component);\n            }\n          }\n        });\n      } else if (hasInterface(arguments[0], Collection)) {\n        var geometries = arguments[0];\n        this._mergedLineStrings = null;\n\n        for (var i = geometries.iterator(); i.hasNext();) {\n          var geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof LineString) {\n        var lineString = arguments[0];\n\n        if (this._factory === null) {\n          this._factory = lineString.getFactory();\n        }\n\n        this._graph.addEdge(lineString);\n      }\n    },\n    buildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {\n      this.buildEdgeStringsForUnprocessedNodes();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineMerger;\n    }\n  });\n\n\n\n  var linemerge = /*#__PURE__*/Object.freeze({\n    LineMerger: LineMerger\n  });\n\n  function BasicSegmentString() {\n    this._pts = null;\n    this._data = null;\n    var pts = arguments[0],\n        data = arguments[1];\n    this._pts = pts;\n    this._data = data;\n  }\n  extend(BasicSegmentString.prototype, {\n    getCoordinates: function getCoordinates() {\n      return this._pts;\n    },\n    size: function size() {\n      return this._pts.length;\n    },\n    getCoordinate: function getCoordinate(i) {\n      return this._pts[i];\n    },\n    isClosed: function isClosed() {\n      return this._pts[0].equals(this._pts[this._pts.length - 1]);\n    },\n    getSegmentOctant: function getSegmentOctant(index) {\n      if (index === this._pts.length - 1) return -1;\n      return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n    },\n    setData: function setData(data) {\n      this._data = data;\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n    },\n    interfaces_: function interfaces_() {\n      return [SegmentString];\n    },\n    getClass: function getClass() {\n      return BasicSegmentString;\n    }\n  });\n\n  function InteriorIntersectionFinder() {\n    this._findAllIntersections = false;\n    this._isCheckEndSegmentsOnly = false;\n    this._li = null;\n    this._interiorIntersection = null;\n    this._intSegments = null;\n    this._intersections = new ArrayList();\n    this._intersectionCount = 0;\n    this._keepIntersections = true;\n    var li = arguments[0];\n    this._li = li;\n    this._interiorIntersection = null;\n  }\n  extend(InteriorIntersectionFinder.prototype, {\n    getInteriorIntersection: function getInteriorIntersection() {\n      return this._interiorIntersection;\n    },\n    setCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n      this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n    },\n    getIntersectionSegments: function getIntersectionSegments() {\n      return this._intSegments;\n    },\n    count: function count() {\n      return this._intersectionCount;\n    },\n    getIntersections: function getIntersections() {\n      return this._intersections;\n    },\n    setFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n      this._findAllIntersections = findAllIntersections;\n    },\n    setKeepIntersections: function setKeepIntersections(keepIntersections) {\n      this._keepIntersections = keepIntersections;\n    },\n    processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (!this._findAllIntersections && this.hasIntersection()) return null;\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n\n      if (this._isCheckEndSegmentsOnly) {\n        var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n        if (!isEndSegPresent) return null;\n      }\n\n      var p00 = e0.getCoordinates()[segIndex0];\n      var p01 = e0.getCoordinates()[segIndex0 + 1];\n      var p10 = e1.getCoordinates()[segIndex1];\n      var p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        if (this._li.isInteriorIntersection()) {\n          this._intSegments = new Array(4).fill(null);\n          this._intSegments[0] = p00;\n          this._intSegments[1] = p01;\n          this._intSegments[2] = p10;\n          this._intSegments[3] = p11;\n          this._interiorIntersection = this._li.getIntersection(0);\n          if (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n          this._intersectionCount++;\n        }\n      }\n    },\n    isEndSegment: function isEndSegment(segStr, index) {\n      if (index === 0) return true;\n      if (index >= segStr.size() - 2) return true;\n      return false;\n    },\n    hasIntersection: function hasIntersection() {\n      return this._interiorIntersection !== null;\n    },\n    isDone: function isDone() {\n      if (this._findAllIntersections) return false;\n      return this._interiorIntersection !== null;\n    },\n    interfaces_: function interfaces_() {\n      return [SegmentIntersector$1];\n    },\n    getClass: function getClass() {\n      return InteriorIntersectionFinder;\n    }\n  });\n\n  InteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n    var finder = new InteriorIntersectionFinder(li);\n    finder.setFindAllIntersections(true);\n    return finder;\n  };\n\n  InteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n    return new InteriorIntersectionFinder(li);\n  };\n\n  InteriorIntersectionFinder.createIntersectionCounter = function (li) {\n    var finder = new InteriorIntersectionFinder(li);\n    finder.setFindAllIntersections(true);\n    finder.setKeepIntersections(false);\n    return finder;\n  };\n\n  function FastNodingValidator() {\n    this._li = new RobustLineIntersector();\n    this._segStrings = null;\n    this._findAllIntersections = false;\n    this._segInt = null;\n    this._isValid = true;\n    var segStrings = arguments[0];\n    this._segStrings = segStrings;\n  }\n  extend(FastNodingValidator.prototype, {\n    execute: function execute() {\n      if (this._segInt !== null) return null;\n      this.checkInteriorIntersections();\n    },\n    getIntersections: function getIntersections() {\n      return this._segInt.getIntersections();\n    },\n    isValid: function isValid() {\n      this.execute();\n      return this._isValid;\n    },\n    setFindAllIntersections: function setFindAllIntersections(findAllIntersections) {\n      this._findAllIntersections = findAllIntersections;\n    },\n    checkInteriorIntersections: function checkInteriorIntersections() {\n      this._isValid = true;\n      this._segInt = new InteriorIntersectionFinder(this._li);\n\n      this._segInt.setFindAllIntersections(this._findAllIntersections);\n\n      var noder = new MCIndexNoder();\n      noder.setSegmentIntersector(this._segInt);\n      noder.computeNodes(this._segStrings);\n\n      if (this._segInt.hasIntersection()) {\n        this._isValid = false;\n        return null;\n      }\n    },\n    checkValid: function checkValid() {\n      this.execute();\n      if (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());\n    },\n    getErrorMessage: function getErrorMessage() {\n      if (this._isValid) return \"no intersections found\";\n\n      var intSegs = this._segInt.getIntersectionSegments();\n\n      return \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return FastNodingValidator;\n    }\n  });\n\n  FastNodingValidator.computeIntersections = function (segStrings) {\n    var nv = new FastNodingValidator(segStrings);\n    nv.setFindAllIntersections(true);\n    nv.isValid();\n    return nv.getIntersections();\n  };\n\n  function EdgeNodingValidator() {\n    this._nv = null;\n    var edges = arguments[0];\n    this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n  }\n  extend(EdgeNodingValidator.prototype, {\n    checkValid: function checkValid() {\n      this._nv.checkValid();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeNodingValidator;\n    }\n  });\n\n  EdgeNodingValidator.toSegmentStrings = function (edges) {\n    var segStrings = new ArrayList();\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n    }\n\n    return segStrings;\n  };\n\n  EdgeNodingValidator.checkValid = function (edges) {\n    var validator = new EdgeNodingValidator(edges);\n    validator.checkValid();\n  };\n\n  function GeometryCollectionMapper() {\n    this._mapOp = null;\n    var mapOp = arguments[0];\n    this._mapOp = mapOp;\n  }\n  extend(GeometryCollectionMapper.prototype, {\n    map: function map(gc) {\n      var mapped = new ArrayList();\n\n      for (var i = 0; i < gc.getNumGeometries(); i++) {\n        var g = this._mapOp.map(gc.getGeometryN(i));\n\n        if (!g.isEmpty()) mapped.add(g);\n      }\n\n      return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryCollectionMapper;\n    }\n  });\n\n  GeometryCollectionMapper.map = function (gc, op) {\n    var mapper = new GeometryCollectionMapper(op);\n    return mapper.map(gc);\n  };\n\n  function LineBuilder() {\n    this._op = null;\n    this._geometryFactory = null;\n    this._ptLocator = null;\n    this._lineEdgesList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    var op = arguments[0],\n        geometryFactory = arguments[1],\n        ptLocator = arguments[2];\n    this._op = op;\n    this._geometryFactory = geometryFactory;\n    this._ptLocator = ptLocator;\n  }\n  extend(LineBuilder.prototype, {\n    collectLines: function collectLines(opCode) {\n      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n        var de = it.next();\n        this.collectLineEdge(de, opCode, this._lineEdgesList);\n        this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n      }\n    },\n    labelIsolatedLine: function labelIsolatedLine(e, targetIndex) {\n      var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n\n      e.getLabel().setLocation(targetIndex, loc);\n    },\n    build: function build(opCode) {\n      this.findCoveredLineEdges();\n      this.collectLines(opCode);\n      this.buildLines(opCode);\n      return this._resultLineList;\n    },\n    collectLineEdge: function collectLineEdge(de, opCode, edges) {\n      var label = de.getLabel();\n      var e = de.getEdge();\n\n      if (de.isLineEdge()) {\n        if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n          edges.add(e);\n          de.setVisitedEdge(true);\n        }\n      }\n    },\n    findCoveredLineEdges: function findCoveredLineEdges() {\n      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        node.getEdges().findCoveredLineEdges();\n      }\n\n      for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n        var de = it.next();\n        var e = de.getEdge();\n\n        if (de.isLineEdge() && !e.isCoveredSet()) {\n          var isCovered = this._op.isCoveredByA(de.getCoordinate());\n\n          e.setCovered(isCovered);\n        }\n      }\n    },\n    labelIsolatedLines: function labelIsolatedLines(edgesList) {\n      for (var it = edgesList.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n\n        if (e.isIsolated()) {\n          if (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);\n        }\n      }\n    },\n    buildLines: function buildLines(opCode) {\n      for (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n        var e = it.next();\n        var label = e.getLabel();\n\n        var line = this._geometryFactory.createLineString(e.getCoordinates());\n\n        this._resultLineList.add(line);\n\n        e.setInResult(true);\n      }\n    },\n    collectBoundaryTouchEdge: function collectBoundaryTouchEdge(de, opCode, edges) {\n      var label = de.getLabel();\n      if (de.isLineEdge()) return null;\n      if (de.isVisited()) return null;\n      if (de.isInteriorAreaEdge()) return null;\n      if (de.getEdge().isInResult()) return null;\n      Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n\n      if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n        edges.add(de.getEdge());\n        de.setVisitedEdge(true);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineBuilder;\n    }\n  });\n\n  function PointBuilder() {\n    this._op = null;\n    this._geometryFactory = null;\n    this._resultPointList = new ArrayList();\n    var op = arguments[0],\n        geometryFactory = arguments[1];\n    this._op = op;\n    this._geometryFactory = geometryFactory;\n  }\n  extend(PointBuilder.prototype, {\n    filterCoveredNodeToPoint: function filterCoveredNodeToPoint(n) {\n      var coord = n.getCoordinate();\n\n      if (!this._op.isCoveredByLA(coord)) {\n        var pt = this._geometryFactory.createPoint(coord);\n\n        this._resultPointList.add(pt);\n      }\n    },\n    extractNonCoveredResultNodes: function extractNonCoveredResultNodes(opCode) {\n      for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n        var n = nodeit.next();\n        if (n.isInResult()) continue;\n        if (n.isIncidentEdgeInResult()) continue;\n\n        if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n          var label = n.getLabel();\n\n          if (OverlayOp.isResultOfOp(label, opCode)) {\n            this.filterCoveredNodeToPoint(n);\n          }\n        }\n      }\n    },\n    build: function build(opCode) {\n      this.extractNonCoveredResultNodes(opCode);\n      return this._resultPointList;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointBuilder;\n    }\n  });\n\n  function LineStringSnapper() {\n    this._snapTolerance = 0.0;\n    this._srcPts = null;\n    this._seg = new LineSegment();\n    this._allowSnappingToSourceVertices = false;\n    this._isClosed = false;\n\n    if (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n      var srcLine = arguments[0],\n          snapTolerance = arguments[1];\n      LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n    } else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n      var srcPts = arguments[0],\n          _snapTolerance = arguments[1];\n      this._srcPts = srcPts;\n      this._isClosed = LineStringSnapper.isClosed(srcPts);\n      this._snapTolerance = _snapTolerance;\n    }\n  }\n  extend(LineStringSnapper.prototype, {\n    snapVertices: function snapVertices(srcCoords, snapPts) {\n      var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n\n      for (var i = 0; i < end; i++) {\n        var srcPt = srcCoords.get(i);\n        var snapVert = this.findSnapForVertex(srcPt, snapPts);\n\n        if (snapVert !== null) {\n          srcCoords.set(i, new Coordinate(snapVert));\n          if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n        }\n      }\n    },\n    findSnapForVertex: function findSnapForVertex(pt, snapPts) {\n      for (var i = 0; i < snapPts.length; i++) {\n        if (pt.equals2D(snapPts[i])) return null;\n        if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n      }\n\n      return null;\n    },\n    snapTo: function snapTo(snapPts) {\n      var coordList = new CoordinateList(this._srcPts);\n      this.snapVertices(coordList, snapPts);\n      this.snapSegments(coordList, snapPts);\n      var newPts = coordList.toCoordinateArray();\n      return newPts;\n    },\n    snapSegments: function snapSegments(srcCoords, snapPts) {\n      if (snapPts.length === 0) return null;\n      var distinctPtCount = snapPts.length;\n      if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n\n      for (var i = 0; i < distinctPtCount; i++) {\n        var snapPt = snapPts[i];\n        var index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n\n        if (index >= 0) {\n          srcCoords.add(index + 1, new Coordinate(snapPt), false);\n        }\n      }\n    },\n    findSegmentIndexToSnap: function findSegmentIndexToSnap(snapPt, srcCoords) {\n      var minDist = Double.MAX_VALUE;\n      var snapIndex = -1;\n\n      for (var i = 0; i < srcCoords.size() - 1; i++) {\n        this._seg.p0 = srcCoords.get(i);\n        this._seg.p1 = srcCoords.get(i + 1);\n\n        if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {\n          if (this._allowSnappingToSourceVertices) continue;else return -1;\n        }\n\n        var dist = this._seg.distance(snapPt);\n\n        if (dist < this._snapTolerance && dist < minDist) {\n          minDist = dist;\n          snapIndex = i;\n        }\n      }\n\n      return snapIndex;\n    },\n    setAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n      this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineStringSnapper;\n    }\n  });\n\n  LineStringSnapper.isClosed = function (pts) {\n    if (pts.length <= 1) return false;\n    return pts[0].equals2D(pts[pts.length - 1]);\n  };\n\n  function GeometrySnapper() {\n    this._srcGeom = null;\n    var srcGeom = arguments[0];\n    this._srcGeom = srcGeom;\n  }\n  extend(GeometrySnapper.prototype, {\n    snapTo: function snapTo(snapGeom, snapTolerance) {\n      var snapPts = this.extractTargetCoordinates(snapGeom);\n      var snapTrans = new SnapTransformer(snapTolerance, snapPts);\n      return snapTrans.transform(this._srcGeom);\n    },\n    snapToSelf: function snapToSelf(snapTolerance, cleanResult) {\n      var snapPts = this.extractTargetCoordinates(this._srcGeom);\n      var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n      var snappedGeom = snapTrans.transform(this._srcGeom);\n      var result = snappedGeom;\n\n      if (cleanResult && hasInterface(result, Polygonal)) {\n        result = snappedGeom.buffer(0);\n      }\n\n      return result;\n    },\n    computeSnapTolerance: function computeSnapTolerance(ringPts) {\n      var minSegLen = this.computeMinimumSegmentLength(ringPts);\n      var snapTol = minSegLen / 10;\n      return snapTol;\n    },\n    extractTargetCoordinates: function extractTargetCoordinates(g) {\n      var ptSet = new TreeSet();\n      var pts = g.getCoordinates();\n\n      for (var i = 0; i < pts.length; i++) {\n        ptSet.add(pts[i]);\n      }\n\n      return ptSet.toArray(new Array(0).fill(null));\n    },\n    computeMinimumSegmentLength: function computeMinimumSegmentLength(pts) {\n      var minSegLen = Double.MAX_VALUE;\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        var segLen = pts[i].distance(pts[i + 1]);\n        if (segLen < minSegLen) minSegLen = segLen;\n      }\n\n      return minSegLen;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometrySnapper;\n    }\n  });\n\n  GeometrySnapper.snap = function (g0, g1, snapTolerance) {\n    var snapGeom = new Array(2).fill(null);\n    var snapper0 = new GeometrySnapper(g0);\n    snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n    var snapper1 = new GeometrySnapper(g1);\n    snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n    return snapGeom;\n  };\n\n  GeometrySnapper.computeOverlaySnapTolerance = function () {\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n      var pm = g.getPrecisionModel();\n\n      if (pm.getType() === PrecisionModel.FIXED) {\n        var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n        if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n      }\n\n      return snapTolerance;\n    } else if (arguments.length === 2) {\n      var g0 = arguments[0],\n          g1 = arguments[1];\n      return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n    }\n  };\n\n  GeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n    var env = g.getEnvelopeInternal();\n    var minDimension = Math.min(env.getHeight(), env.getWidth());\n    var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n    return snapTol;\n  };\n\n  GeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n    var snapper0 = new GeometrySnapper(geom);\n    return snapper0.snapToSelf(snapTolerance, cleanResult);\n  };\n\n  GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\n\n  function SnapTransformer() {\n    GeometryTransformer.apply(this);\n    this._snapTolerance = null;\n    this._snapPts = null;\n    this._isSelfSnap = false;\n\n    if (arguments.length === 2) {\n      var snapTolerance = arguments[0],\n          snapPts = arguments[1];\n      this._snapTolerance = snapTolerance;\n      this._snapPts = snapPts;\n    } else if (arguments.length === 3) {\n      var _snapTolerance = arguments[0],\n          _snapPts = arguments[1],\n          isSelfSnap = arguments[2];\n      this._snapTolerance = _snapTolerance;\n      this._snapPts = _snapPts;\n      this._isSelfSnap = isSelfSnap;\n    }\n  }\n\n  inherits(SnapTransformer, GeometryTransformer);\n  extend(SnapTransformer.prototype, {\n    snapLine: function snapLine(srcPts, snapPts) {\n      var snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n      snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n      return snapper.snapTo(snapPts);\n    },\n    transformCoordinates: function transformCoordinates(coords, parent) {\n      var srcPts = coords.toCoordinateArray();\n      var newPts = this.snapLine(srcPts, this._snapPts);\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SnapTransformer;\n    }\n  });\n\n  function CommonBits() {\n    this._isFirst = true;\n    this._commonMantissaBitsCount = 53;\n    this._commonBits = new Long();\n    this._commonSignExp = null;\n  }\n  extend(CommonBits.prototype, {\n    getCommon: function getCommon() {\n      return Double.longBitsToDouble(this._commonBits);\n    },\n    add: function add(num) {\n      var numBits = Double.doubleToLongBits(num);\n\n      if (this._isFirst) {\n        this._commonBits = numBits;\n        this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n        this._isFirst = false;\n        return null;\n      }\n\n      var numSignExp = CommonBits.signExpBits(numBits);\n\n      if (numSignExp !== this._commonSignExp) {\n        this._commonBits.high = 0 | 0;\n        this._commonBits.low = 0 | 0;\n        return null;\n      }\n\n      this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n      this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n    },\n    toString: function toString() {\n      if (arguments.length === 1) {\n        var bits = arguments[0];\n        var x = Double.longBitsToDouble(bits);\n        var numStr = Long.toBinaryString(bits);\n        var padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n        var bitStr = padStr.substring(padStr.length - 64);\n        var str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n        return str;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CommonBits;\n    }\n  });\n\n  CommonBits.getBit = function (bits, i) {\n    var mask = 1 << i % 32;\n\n    if (i < 32) {\n      return (bits.low & mask) != 0 ? 1 : 0;\n    }\n\n    return (bits.high & mask) != 0 ? 1 : 0;\n  };\n\n  CommonBits.signExpBits = function (num) {\n    return num.high >>> 20;\n  };\n\n  CommonBits.zeroLowerBits = function (bits, nBits) {\n    var prop = 'low';\n\n    if (nBits > 32) {\n      bits.low = 0 | 0;\n      nBits %= 32;\n      prop = 'high';\n    }\n\n    if (nBits > 0) {\n      var mask = nBits < 32 ? ~((1 << nBits) - 1) : 0;\n      bits[prop] &= mask;\n    }\n\n    return bits;\n  };\n\n  CommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n    var count = 0;\n\n    for (var i = 52; i >= 0; i--) {\n      if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n      count++;\n    }\n\n    return 52;\n  };\n\n  function CommonBitsRemover() {\n    this._commonCoord = null;\n    this._ccFilter = new CommonCoordinateFilter();\n  }\n  extend(CommonBitsRemover.prototype, {\n    addCommonBits: function addCommonBits(geom) {\n      var trans = new Translater(this._commonCoord);\n      geom.apply(trans);\n      geom.geometryChanged();\n    },\n    removeCommonBits: function removeCommonBits(geom) {\n      if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n      var invCoord = new Coordinate(this._commonCoord);\n      invCoord.x = -invCoord.x;\n      invCoord.y = -invCoord.y;\n      var trans = new Translater(invCoord);\n      geom.apply(trans);\n      geom.geometryChanged();\n      return geom;\n    },\n    getCommonCoordinate: function getCommonCoordinate() {\n      return this._commonCoord;\n    },\n    add: function add(geom) {\n      geom.apply(this._ccFilter);\n      this._commonCoord = this._ccFilter.getCommonCoordinate();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CommonBitsRemover;\n    }\n  });\n\n  function CommonCoordinateFilter() {\n    this._commonBitsX = new CommonBits();\n    this._commonBitsY = new CommonBits();\n  }\n\n  extend(CommonCoordinateFilter.prototype, {\n    filter: function filter(coord) {\n      this._commonBitsX.add(coord.x);\n\n      this._commonBitsY.add(coord.y);\n    },\n    getCommonCoordinate: function getCommonCoordinate() {\n      return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateFilter];\n    },\n    getClass: function getClass() {\n      return CommonCoordinateFilter;\n    }\n  });\n\n  function Translater() {\n    this.trans = null;\n    var trans = arguments[0];\n    this.trans = trans;\n  }\n\n  extend(Translater.prototype, {\n    filter: function filter(seq, i) {\n      var xp = seq.getOrdinate(i, 0) + this.trans.x;\n      var yp = seq.getOrdinate(i, 1) + this.trans.y;\n      seq.setOrdinate(i, 0, xp);\n      seq.setOrdinate(i, 1, yp);\n    },\n    isDone: function isDone() {\n      return false;\n    },\n    isGeometryChanged: function isGeometryChanged() {\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [CoordinateSequenceFilter];\n    },\n    getClass: function getClass() {\n      return Translater;\n    }\n  });\n  CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\n  CommonBitsRemover.Translater = Translater;\n\n  function SnapOverlayOp() {\n    this._geom = new Array(2).fill(null);\n    this._snapTolerance = null;\n    this._cbr = null;\n    var g1 = arguments[0],\n        g2 = arguments[1];\n    this._geom[0] = g1;\n    this._geom[1] = g2;\n    this.computeSnapTolerance();\n  }\n  extend(SnapOverlayOp.prototype, {\n    selfSnap: function selfSnap(geom) {\n      var snapper0 = new GeometrySnapper(geom);\n      var snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n      return snapGeom;\n    },\n    removeCommonBits: function removeCommonBits(geom) {\n      this._cbr = new CommonBitsRemover();\n\n      this._cbr.add(geom[0]);\n\n      this._cbr.add(geom[1]);\n\n      var remGeom = new Array(2).fill(null);\n      remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n      remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n      return remGeom;\n    },\n    prepareResult: function prepareResult(geom) {\n      this._cbr.addCommonBits(geom);\n\n      return geom;\n    },\n    getResultGeometry: function getResultGeometry(opCode) {\n      var prepGeom = this.snap(this._geom);\n      var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n      return this.prepareResult(result);\n    },\n    checkValid: function checkValid(g) {\n      if (!g.isValid()) {\n        System.out.println(\"Snapped geometry is invalid\");\n      }\n    },\n    computeSnapTolerance: function computeSnapTolerance() {\n      this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n    },\n    snap: function snap(geom) {\n      var remGeom = this.removeCommonBits(geom);\n      var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n      return snapGeom;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SnapOverlayOp;\n    }\n  });\n\n  SnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n    var op = new SnapOverlayOp(g0, g1);\n    return op.getResultGeometry(opCode);\n  };\n\n  SnapOverlayOp.union = function (g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n\n  SnapOverlayOp.intersection = function (g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n\n  SnapOverlayOp.symDifference = function (g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n\n  SnapOverlayOp.difference = function (g0, g1) {\n    return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function SnapIfNeededOverlayOp() {\n    this._geom = new Array(2).fill(null);\n    var g1 = arguments[0],\n        g2 = arguments[1];\n    this._geom[0] = g1;\n    this._geom[1] = g2;\n  }\n  extend(SnapIfNeededOverlayOp.prototype, {\n    getResultGeometry: function getResultGeometry(opCode) {\n      var result = null;\n      var isSuccess = false;\n      var savedException = null;\n\n      try {\n        result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n        isSuccess = true;\n      } catch (ex) {\n        if (ex instanceof RuntimeException) {\n          savedException = ex;\n        } else throw ex;\n      } finally {}\n\n      if (!isSuccess) {\n        try {\n          result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n        } catch (ex) {\n          if (ex instanceof RuntimeException) {\n            throw savedException;\n          } else throw ex;\n        } finally {}\n      }\n\n      return result;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SnapIfNeededOverlayOp;\n    }\n  });\n\n  SnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n    var op = new SnapIfNeededOverlayOp(g0, g1);\n    return op.getResultGeometry(opCode);\n  };\n\n  SnapIfNeededOverlayOp.union = function (g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n  };\n\n  SnapIfNeededOverlayOp.intersection = function (g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n  };\n\n  SnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n  };\n\n  SnapIfNeededOverlayOp.difference = function (g0, g1) {\n    return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n  };\n\n  function GeometryGraphOperation() {\n    this._li = new RobustLineIntersector();\n    this._resultPrecisionModel = null;\n    this._arg = null;\n\n    if (arguments.length === 1) {\n      var g0 = arguments[0];\n      this.setComputationPrecision(g0.getPrecisionModel());\n      this._arg = new Array(1).fill(null);\n      this._arg[0] = new GeometryGraph(0, g0);\n    } else if (arguments.length === 2) {\n      var _g = arguments[0],\n          g1 = arguments[1];\n      GeometryGraphOperation.call(this, _g, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n    } else if (arguments.length === 3) {\n      var _g2 = arguments[0],\n          _g3 = arguments[1],\n          boundaryNodeRule = arguments[2];\n      if (_g2.getPrecisionModel().compareTo(_g3.getPrecisionModel()) >= 0) this.setComputationPrecision(_g2.getPrecisionModel());else this.setComputationPrecision(_g3.getPrecisionModel());\n      this._arg = new Array(2).fill(null);\n      this._arg[0] = new GeometryGraph(0, _g2, boundaryNodeRule);\n      this._arg[1] = new GeometryGraph(1, _g3, boundaryNodeRule);\n    }\n  }\n  extend(GeometryGraphOperation.prototype, {\n    getArgGeometry: function getArgGeometry(i) {\n      return this._arg[i].getGeometry();\n    },\n    setComputationPrecision: function setComputationPrecision(pm) {\n      this._resultPrecisionModel = pm;\n\n      this._li.setPrecisionModel(this._resultPrecisionModel);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryGraphOperation;\n    }\n  });\n\n  function OverlayOp() {\n    this._ptLocator = new PointLocator();\n    this._geomFact = null;\n    this._resultGeom = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    this._resultPolyList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    this._resultPointList = new ArrayList();\n    var g0 = arguments[0],\n        g1 = arguments[1];\n    GeometryGraphOperation.call(this, g0, g1);\n    this._graph = new PlanarGraph(new OverlayNodeFactory());\n    this._geomFact = g0.getFactory();\n  }\n  inherits(OverlayOp, GeometryGraphOperation);\n  extend(OverlayOp.prototype, {\n    insertUniqueEdge: function insertUniqueEdge(e) {\n      var existingEdge = this._edgeList.findEqualEdge(e);\n\n      if (existingEdge !== null) {\n        var existingLabel = existingEdge.getLabel();\n        var labelToMerge = e.getLabel();\n\n        if (!existingEdge.isPointwiseEqual(e)) {\n          labelToMerge = new Label(e.getLabel());\n          labelToMerge.flip();\n        }\n\n        var depth = existingEdge.getDepth();\n\n        if (depth.isNull()) {\n          depth.add(existingLabel);\n        }\n\n        depth.add(labelToMerge);\n        existingLabel.merge(labelToMerge);\n      } else {\n        this._edgeList.add(e);\n      }\n    },\n    getGraph: function getGraph() {\n      return this._graph;\n    },\n    cancelDuplicateResultEdges: function cancelDuplicateResultEdges() {\n      for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n        var de = it.next();\n        var sym = de.getSym();\n\n        if (de.isInResult() && sym.isInResult()) {\n          de.setInResult(false);\n          sym.setInResult(false);\n        }\n      }\n    },\n    isCoveredByLA: function isCoveredByLA(coord) {\n      if (this.isCovered(coord, this._resultLineList)) return true;\n      if (this.isCovered(coord, this._resultPolyList)) return true;\n      return false;\n    },\n    computeGeometry: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n      var geomList = new ArrayList();\n      geomList.addAll(resultPointList);\n      geomList.addAll(resultLineList);\n      geomList.addAll(resultPolyList);\n      if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n      return this._geomFact.buildGeometry(geomList);\n    },\n    mergeSymLabels: function mergeSymLabels() {\n      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        node.getEdges().mergeSymLabels();\n      }\n    },\n    isCovered: function isCovered(coord, geomList) {\n      for (var it = geomList.iterator(); it.hasNext();) {\n        var geom = it.next();\n\n        var loc = this._ptLocator.locate(coord, geom);\n\n        if (loc !== Location.EXTERIOR) return true;\n      }\n\n      return false;\n    },\n    replaceCollapsedEdges: function replaceCollapsedEdges() {\n      var newEdges = new ArrayList();\n\n      for (var it = this._edgeList.iterator(); it.hasNext();) {\n        var e = it.next();\n\n        if (e.isCollapsed()) {\n          it.remove();\n          newEdges.add(e.getCollapsedEdge());\n        }\n      }\n\n      this._edgeList.addAll(newEdges);\n    },\n    updateNodeLabelling: function updateNodeLabelling() {\n      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        var lbl = node.getEdges().getLabel();\n        node.getLabel().merge(lbl);\n      }\n    },\n    getResultGeometry: function getResultGeometry(overlayOpCode) {\n      this.computeOverlay(overlayOpCode);\n      return this._resultGeom;\n    },\n    insertUniqueEdges: function insertUniqueEdges(edges) {\n      for (var i = edges.iterator(); i.hasNext();) {\n        var e = i.next();\n        this.insertUniqueEdge(e);\n      }\n    },\n    computeOverlay: function computeOverlay(opCode) {\n      this.copyPoints(0);\n      this.copyPoints(1);\n\n      this._arg[0].computeSelfNodes(this._li, false);\n\n      this._arg[1].computeSelfNodes(this._li, false);\n\n      this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n\n      var baseSplitEdges = new ArrayList();\n\n      this._arg[0].computeSplitEdges(baseSplitEdges);\n\n      this._arg[1].computeSplitEdges(baseSplitEdges);\n      this.insertUniqueEdges(baseSplitEdges);\n      this.computeLabelsFromDepths();\n      this.replaceCollapsedEdges();\n      EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n\n      this._graph.addEdges(this._edgeList.getEdges());\n\n      this.computeLabelling();\n      this.labelIncompleteNodes();\n      this.findResultAreaEdges(opCode);\n      this.cancelDuplicateResultEdges();\n      var polyBuilder = new PolygonBuilder(this._geomFact);\n      polyBuilder.add(this._graph);\n      this._resultPolyList = polyBuilder.getPolygons();\n      var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n      this._resultLineList = lineBuilder.build(opCode);\n      var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n      this._resultPointList = pointBuilder.build(opCode);\n      this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n    },\n    labelIncompleteNode: function labelIncompleteNode(n, targetIndex) {\n      var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\n      n.getLabel().setLocation(targetIndex, loc);\n    },\n    copyPoints: function copyPoints(argIndex) {\n      for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n        var graphNode = i.next();\n\n        var newNode = this._graph.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    },\n    findResultAreaEdges: function findResultAreaEdges(opCode) {\n      for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n        var de = it.next();\n        var label = de.getLabel();\n\n        if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n          de.setInResult(true);\n        }\n      }\n    },\n    computeLabelsFromDepths: function computeLabelsFromDepths() {\n      for (var it = this._edgeList.iterator(); it.hasNext();) {\n        var e = it.next();\n        var lbl = e.getLabel();\n        var depth = e.getDepth();\n\n        if (!depth.isNull()) {\n          depth.normalize();\n\n          for (var i = 0; i < 2; i++) {\n            if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n              if (depth.getDelta(i) === 0) {\n                lbl.toLine(i);\n              } else {\n                Assert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n                lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n                Assert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n                lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n              }\n            }\n          }\n        }\n      }\n    },\n    computeLabelling: function computeLabelling() {\n      for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        var node = nodeit.next();\n        node.getEdges().computeLabelling(this._arg);\n      }\n\n      this.mergeSymLabels();\n      this.updateNodeLabelling();\n    },\n    labelIncompleteNodes: function labelIncompleteNodes() {\n\n      for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n        var n = ni.next();\n        var label = n.getLabel();\n\n        if (n.isIsolated()) {\n          if (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);\n        }\n\n        n.getEdges().updateLabelling(label);\n      }\n    },\n    isCoveredByA: function isCoveredByA(coord) {\n      if (this.isCovered(coord, this._resultPolyList)) return true;\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return OverlayOp;\n    }\n  });\n\n  OverlayOp.overlayOp = function (geom0, geom1, opCode) {\n    var gov = new OverlayOp(geom0, geom1);\n    var geomOv = gov.getResultGeometry(opCode);\n    return geomOv;\n  };\n\n  OverlayOp.union = function (geom, other) {\n    if (geom.isEmpty() || other.isEmpty()) {\n      if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());\n      if (geom.isEmpty()) return other.copy();\n      if (other.isEmpty()) return geom.copy();\n    }\n\n    if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n    return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.UNION);\n  };\n\n  OverlayOp.intersection = function (geom, other) {\n    if (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());\n\n    if (geom.isGeometryCollection()) {\n      var g2 = other;\n      return GeometryCollectionMapper.map(geom, {\n        interfaces_: function interfaces_() {\n          return [MapOp];\n        },\n        map: function map(g) {\n          return g.intersection(g2);\n        }\n      });\n    }\n\n    if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n    return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.INTERSECTION);\n  };\n\n  OverlayOp.symDifference = function (geom, other) {\n    if (geom.isEmpty() || other.isEmpty()) {\n      if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());\n      if (geom.isEmpty()) return other.copy();\n      if (other.isEmpty()) return geom.copy();\n    }\n\n    if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n    return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);\n  };\n\n  OverlayOp.resultDimension = function (opCode, g0, g1) {\n    var dim0 = g0.getDimension();\n    var dim1 = g1.getDimension();\n    var resultDimension = -1;\n\n    switch (opCode) {\n      case OverlayOp.INTERSECTION:\n        resultDimension = Math.min(dim0, dim1);\n        break;\n\n      case OverlayOp.UNION:\n        resultDimension = Math.max(dim0, dim1);\n        break;\n\n      case OverlayOp.DIFFERENCE:\n        resultDimension = dim0;\n        break;\n\n      case OverlayOp.SYMDIFFERENCE:\n        resultDimension = Math.max(dim0, dim1);\n        break;\n    }\n\n    return resultDimension;\n  };\n\n  OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n    var result = null;\n\n    switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n      case -1:\n        result = geomFact.createGeometryCollection();\n        break;\n\n      case 0:\n        result = geomFact.createPoint();\n        break;\n\n      case 1:\n        result = geomFact.createLineString();\n        break;\n\n      case 2:\n        result = geomFact.createPolygon();\n        break;\n    }\n\n    return result;\n  };\n\n  OverlayOp.difference = function (geom, other) {\n    if (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());\n    if (other.isEmpty()) return geom.copy();\n    if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n    return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.DIFFERENCE);\n  };\n\n  OverlayOp.isResultOfOp = function () {\n    if (arguments.length === 2) {\n      var label = arguments[0],\n          opCode = arguments[1];\n      var loc0 = label.getLocation(0);\n      var loc1 = label.getLocation(1);\n      return OverlayOp.isResultOfOp(loc0, loc1, opCode);\n    } else if (arguments.length === 3) {\n      var _loc = arguments[0],\n          _loc2 = arguments[1],\n          overlayOpCode = arguments[2];\n      if (_loc === Location.BOUNDARY) _loc = Location.INTERIOR;\n      if (_loc2 === Location.BOUNDARY) _loc2 = Location.INTERIOR;\n\n      switch (overlayOpCode) {\n        case OverlayOp.INTERSECTION:\n          return _loc === Location.INTERIOR && _loc2 === Location.INTERIOR;\n\n        case OverlayOp.UNION:\n          return _loc === Location.INTERIOR || _loc2 === Location.INTERIOR;\n\n        case OverlayOp.DIFFERENCE:\n          return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR;\n\n        case OverlayOp.SYMDIFFERENCE:\n          return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR || _loc !== Location.INTERIOR && _loc2 === Location.INTERIOR;\n      }\n\n      return false;\n    }\n  };\n\n  OverlayOp.INTERSECTION = 1;\n  OverlayOp.UNION = 2;\n  OverlayOp.DIFFERENCE = 3;\n  OverlayOp.SYMDIFFERENCE = 4;\n\n\n\n  var overlay = /*#__PURE__*/Object.freeze({\n    OverlayOp: OverlayOp\n  });\n\n  function PolygonizeDirectedEdge() {\n    this._edgeRing = null;\n    this._next = null;\n    this._label = -1;\n    var from = arguments[0],\n        to = arguments[1],\n        directionPt = arguments[2],\n        edgeDirection = arguments[3];\n    DirectedEdge$1.call(this, from, to, directionPt, edgeDirection);\n  }\n  inherits(PolygonizeDirectedEdge, DirectedEdge$1);\n  extend(PolygonizeDirectedEdge.prototype, {\n    getNext: function getNext() {\n      return this._next;\n    },\n    isInRing: function isInRing() {\n      return this._edgeRing !== null;\n    },\n    setRing: function setRing(edgeRing) {\n      this._edgeRing = edgeRing;\n    },\n    setLabel: function setLabel(label) {\n      this._label = label;\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    setNext: function setNext(next) {\n      this._next = next;\n    },\n    getRing: function getRing() {\n      return this._edgeRing;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PolygonizeDirectedEdge;\n    }\n  });\n\n  function PolygonizeEdge() {\n    Edge$1.apply(this);\n    this._line = null;\n    var line = arguments[0];\n    this._line = line;\n  }\n  inherits(PolygonizeEdge, Edge$1);\n  extend(PolygonizeEdge.prototype, {\n    getLine: function getLine() {\n      return this._line;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PolygonizeEdge;\n    }\n  });\n\n  function EdgeRing$1() {\n    this._factory = null;\n    this._deList = new ArrayList();\n    this._lowestEdge = null;\n    this._ring = null;\n    this._ringPts = null;\n    this._holes = null;\n    this._shell = null;\n    this._isHole = null;\n    this._isProcessed = false;\n    this._isIncludedSet = false;\n    this._isIncluded = false;\n    var factory = arguments[0];\n    this._factory = factory;\n  }\n  extend(EdgeRing$1.prototype, {\n    isIncluded: function isIncluded() {\n      return this._isIncluded;\n    },\n    getCoordinates: function getCoordinates() {\n      if (this._ringPts === null) {\n        var coordList = new CoordinateList();\n\n        for (var i = this._deList.iterator(); i.hasNext();) {\n          var de = i.next();\n          var edge = de.getEdge();\n          EdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n        }\n\n        this._ringPts = coordList.toCoordinateArray();\n      }\n\n      return this._ringPts;\n    },\n    isIncludedSet: function isIncludedSet() {\n      return this._isIncludedSet;\n    },\n    isValid: function isValid() {\n      this.getCoordinates();\n      if (this._ringPts.length <= 3) return false;\n      this.getRing();\n      return this._ring.isValid();\n    },\n    build: function build(startDE) {\n      var de = startDE;\n\n      do {\n        this.add(de);\n        de.setRing(this);\n        de = de.getNext();\n        Assert.isTrue(de !== null, \"found null DE in ring\");\n        Assert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n      } while (de !== startDE);\n    },\n    isOuterHole: function isOuterHole() {\n      if (!this._isHole) return false;\n      return !this.hasShell();\n    },\n    getPolygon: function getPolygon() {\n      var holeLR = null;\n\n      if (this._holes !== null) {\n        holeLR = new Array(this._holes.size()).fill(null);\n\n        for (var i = 0; i < this._holes.size(); i++) {\n          holeLR[i] = this._holes.get(i);\n        }\n      }\n\n      var poly = this._factory.createPolygon(this._ring, holeLR);\n\n      return poly;\n    },\n    isHole: function isHole() {\n      return this._isHole;\n    },\n    isProcessed: function isProcessed() {\n      return this._isProcessed;\n    },\n    addHole: function addHole() {\n      if (arguments[0] instanceof LinearRing) {\n        var _hole = arguments[0];\n        if (this._holes === null) this._holes = new ArrayList();\n\n        this._holes.add(_hole);\n      } else if (arguments[0] instanceof EdgeRing$1) {\n        var holeER = arguments[0];\n        holeER.setShell(this);\n        var hole = holeER.getRing();\n        if (this._holes === null) this._holes = new ArrayList();\n\n        this._holes.add(hole);\n      }\n    },\n    setIncluded: function setIncluded(isIncluded) {\n      this._isIncluded = isIncluded;\n      this._isIncludedSet = true;\n    },\n    getOuterHole: function getOuterHole() {\n      if (this.isHole()) return null;\n\n      for (var i = 0; i < this._deList.size(); i++) {\n        var de = this._deList.get(i);\n\n        var adjRing = de.getSym().getRing();\n        if (adjRing.isOuterHole()) return adjRing;\n      }\n\n      return null;\n    },\n    computeHole: function computeHole() {\n      var ring = this.getRing();\n      this._isHole = Orientation.isCCW(ring.getCoordinates());\n    },\n    hasShell: function hasShell() {\n      return this._shell !== null;\n    },\n    isOuterShell: function isOuterShell() {\n      return this.getOuterHole() !== null;\n    },\n    getLineString: function getLineString() {\n      this.getCoordinates();\n      return this._factory.createLineString(this._ringPts);\n    },\n    toString: function toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n    },\n    getShell: function getShell() {\n      if (this.isHole()) return this._shell;\n      return this;\n    },\n    add: function add(de) {\n      this._deList.add(de);\n    },\n    getRing: function getRing() {\n      if (this._ring !== null) return this._ring;\n      this.getCoordinates();\n      if (this._ringPts.length < 3) System.out.println(this._ringPts);\n\n      try {\n        this._ring = this._factory.createLinearRing(this._ringPts);\n      } catch (ex) {\n        if (ex instanceof Exception) {\n          System.out.println(this._ringPts);\n        } else throw ex;\n      } finally {}\n\n      return this._ring;\n    },\n    updateIncluded: function updateIncluded() {\n      if (this.isHole()) return null;\n\n      for (var i = 0; i < this._deList.size(); i++) {\n        var de = this._deList.get(i);\n\n        var adjShell = de.getSym().getRing().getShell();\n\n        if (adjShell !== null && adjShell.isIncludedSet()) {\n          this.setIncluded(!adjShell.isIncluded());\n          return null;\n        }\n      }\n    },\n    setShell: function setShell(shell) {\n      this._shell = shell;\n    },\n    setProcessed: function setProcessed(isProcessed) {\n      this._isProcessed = isProcessed;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeRing$1;\n    }\n  });\n\n  EdgeRing$1.findDirEdgesInRing = function (startDE) {\n    var de = startDE;\n    var edges = new ArrayList();\n\n    do {\n      edges.add(de);\n      de = de.getNext();\n      Assert.isTrue(de !== null, \"found null DE in ring\");\n      Assert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n    } while (de !== startDE);\n\n    return edges;\n  };\n\n  EdgeRing$1.addEdge = function (coords, isForward, coordList) {\n    if (isForward) {\n      for (var i = 0; i < coords.length; i++) {\n        coordList.add(coords[i], false);\n      }\n    } else {\n      for (var i = coords.length - 1; i >= 0; i--) {\n        coordList.add(coords[i], false);\n      }\n    }\n  };\n\n  EdgeRing$1.findEdgeRingContaining = function (testEr, shellList) {\n    var testRing = testEr.getRing();\n    var testEnv = testRing.getEnvelopeInternal();\n    var testPt = testRing.getCoordinateN(0);\n    var minShell = null;\n    var minShellEnv = null;\n\n    for (var it = shellList.iterator(); it.hasNext();) {\n      var tryShell = it.next();\n      var tryShellRing = tryShell.getRing();\n      var tryShellEnv = tryShellRing.getEnvelopeInternal();\n      if (tryShellEnv.equals(testEnv)) continue;\n      if (!tryShellEnv.contains(testEnv)) continue;\n      testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n      var isContained = false;\n      if (PointLocation.isInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n\n      if (isContained) {\n        if (minShell === null || minShellEnv.contains(tryShellEnv)) {\n          minShell = tryShell;\n          minShellEnv = minShell.getRing().getEnvelopeInternal();\n        }\n      }\n    }\n\n    return minShell;\n  };\n\n  function EnvelopeComparator() {}\n\n  extend(EnvelopeComparator.prototype, {\n    compare: function compare(obj0, obj1) {\n      var r0 = obj0;\n      var r1 = obj1;\n      return r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n    },\n    interfaces_: function interfaces_() {\n      return [Comparator];\n    },\n    getClass: function getClass() {\n      return EnvelopeComparator;\n    }\n  });\n  EdgeRing$1.EnvelopeComparator = EnvelopeComparator;\n\n  function PolygonizeGraph() {\n    PlanarGraph$1.apply(this);\n    this._factory = null;\n    var factory = arguments[0];\n    this._factory = factory;\n  }\n  inherits(PolygonizeGraph, PlanarGraph$1);\n  extend(PolygonizeGraph.prototype, {\n    findEdgeRing: function findEdgeRing(startDE) {\n      var er = new EdgeRing$1(this._factory);\n      er.build(startDE);\n      return er;\n    },\n    computeDepthParity: function computeDepthParity() {\n      if (arguments.length === 0) {\n        while (true) {\n          var de = null;\n          return null;\n          this.computeDepthParity(de);\n        }\n      }\n    },\n    computeNextCWEdges: function computeNextCWEdges() {\n      for (var iNode = this.nodeIterator(); iNode.hasNext();) {\n        var node = iNode.next();\n        PolygonizeGraph.computeNextCWEdges(node);\n      }\n    },\n    addEdge: function addEdge(line) {\n      if (line.isEmpty()) {\n        return null;\n      }\n\n      var linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\n      if (linePts.length < 2) {\n        return null;\n      }\n\n      var startPt = linePts[0];\n      var endPt = linePts[linePts.length - 1];\n      var nStart = this.getNode(startPt);\n      var nEnd = this.getNode(endPt);\n      var de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n      var de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n      var edge = new PolygonizeEdge(line);\n      edge.setDirectedEdges(de0, de1);\n      this.add(edge);\n    },\n    deleteCutEdges: function deleteCutEdges() {\n      this.computeNextCWEdges();\n      PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n      var cutLines = new ArrayList();\n\n      for (var i = this._dirEdges.iterator(); i.hasNext();) {\n        var de = i.next();\n        if (de.isMarked()) continue;\n        var sym = de.getSym();\n\n        if (de.getLabel() === sym.getLabel()) {\n          de.setMarked(true);\n          sym.setMarked(true);\n          var e = de.getEdge();\n          cutLines.add(e.getLine());\n        }\n      }\n\n      return cutLines;\n    },\n    getEdgeRings: function getEdgeRings() {\n      this.computeNextCWEdges();\n      PolygonizeGraph.label(this._dirEdges, -1);\n      var maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n      this.convertMaximalToMinimalEdgeRings(maximalRings);\n      var edgeRingList = new ArrayList();\n\n      for (var i = this._dirEdges.iterator(); i.hasNext();) {\n        var de = i.next();\n        if (de.isMarked()) continue;\n        if (de.isInRing()) continue;\n        var er = this.findEdgeRing(de);\n        edgeRingList.add(er);\n      }\n\n      return edgeRingList;\n    },\n    getNode: function getNode(pt) {\n      var node = this.findNode(pt);\n\n      if (node === null) {\n        node = new Node$3(pt);\n        this.add(node);\n      }\n\n      return node;\n    },\n    convertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(ringEdges) {\n      for (var i = ringEdges.iterator(); i.hasNext();) {\n        var de = i.next();\n        var label = de.getLabel();\n        var intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n        if (intNodes === null) continue;\n\n        for (var iNode = intNodes.iterator(); iNode.hasNext();) {\n          var node = iNode.next();\n          PolygonizeGraph.computeNextCCWEdges(node, label);\n        }\n      }\n    },\n    deleteDangles: function deleteDangles() {\n      var nodesToRemove = this.findNodesOfDegree(1);\n      var dangleLines = new HashSet();\n      var nodeStack = new Stack();\n\n      for (var i = nodesToRemove.iterator(); i.hasNext();) {\n        nodeStack.push(i.next());\n      }\n\n      while (!nodeStack.isEmpty()) {\n        var node = nodeStack.pop();\n        PolygonizeGraph.deleteAllEdges(node);\n        var nodeOutEdges = node.getOutEdges().getEdges();\n\n        for (var i = nodeOutEdges.iterator(); i.hasNext();) {\n          var de = i.next();\n          de.setMarked(true);\n          var sym = de.getSym();\n          if (sym !== null) sym.setMarked(true);\n          var e = de.getEdge();\n          dangleLines.add(e.getLine());\n          var toNode = de.getToNode();\n          if (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n        }\n      }\n\n      return dangleLines;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PolygonizeGraph;\n    }\n  });\n\n  PolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {\n    var edgeRingStarts = new ArrayList();\n    var currLabel = 1;\n\n    for (var i = dirEdges.iterator(); i.hasNext();) {\n      var de = i.next();\n      if (de.isMarked()) continue;\n      if (de.getLabel() >= 0) continue;\n      edgeRingStarts.add(de);\n      var edges = EdgeRing$1.findDirEdgesInRing(de);\n      PolygonizeGraph.label(edges, currLabel);\n      currLabel++;\n    }\n\n    return edgeRingStarts;\n  };\n\n  PolygonizeGraph.getDegreeNonDeleted = function (node) {\n    var edges = node.getOutEdges().getEdges();\n    var degree = 0;\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var de = i.next();\n      if (!de.isMarked()) degree++;\n    }\n\n    return degree;\n  };\n\n  PolygonizeGraph.deleteAllEdges = function (node) {\n    var edges = node.getOutEdges().getEdges();\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var de = i.next();\n      de.setMarked(true);\n      var sym = de.getSym();\n      if (sym !== null) sym.setMarked(true);\n    }\n  };\n\n  PolygonizeGraph.label = function (dirEdges, label) {\n    for (var i = dirEdges.iterator(); i.hasNext();) {\n      var de = i.next();\n      de.setLabel(label);\n    }\n  };\n\n  PolygonizeGraph.computeNextCWEdges = function (node) {\n    var deStar = node.getOutEdges();\n    var startDE = null;\n    var prevDE = null;\n\n    for (var i = deStar.getEdges().iterator(); i.hasNext();) {\n      var outDE = i.next();\n      if (outDE.isMarked()) continue;\n      if (startDE === null) startDE = outDE;\n\n      if (prevDE !== null) {\n        var sym = prevDE.getSym();\n        sym.setNext(outDE);\n      }\n\n      prevDE = outDE;\n    }\n\n    if (prevDE !== null) {\n      var sym = prevDE.getSym();\n      sym.setNext(startDE);\n    }\n  };\n\n  PolygonizeGraph.computeNextCCWEdges = function (node, label) {\n    var deStar = node.getOutEdges();\n    var firstOutDE = null;\n    var prevInDE = null;\n    var edges = deStar.getEdges();\n\n    for (var i = edges.size() - 1; i >= 0; i--) {\n      var de = edges.get(i);\n      var sym = de.getSym();\n      var outDE = null;\n      if (de.getLabel() === label) outDE = de;\n      var inDE = null;\n      if (sym.getLabel() === label) inDE = sym;\n      if (outDE === null && inDE === null) continue;\n\n      if (inDE !== null) {\n        prevInDE = inDE;\n      }\n\n      if (outDE !== null) {\n        if (prevInDE !== null) {\n          prevInDE.setNext(outDE);\n          prevInDE = null;\n        }\n\n        if (firstOutDE === null) firstOutDE = outDE;\n      }\n    }\n\n    if (prevInDE !== null) {\n      Assert.isTrue(firstOutDE !== null);\n      prevInDE.setNext(firstOutDE);\n    }\n  };\n\n  PolygonizeGraph.getDegree = function (node, label) {\n    var edges = node.getOutEdges().getEdges();\n    var degree = 0;\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var de = i.next();\n      if (de.getLabel() === label) degree++;\n    }\n\n    return degree;\n  };\n\n  PolygonizeGraph.findIntersectionNodes = function (startDE, label) {\n    var de = startDE;\n    var intNodes = null;\n\n    do {\n      var node = de.getFromNode();\n\n      if (PolygonizeGraph.getDegree(node, label) > 1) {\n        if (intNodes === null) intNodes = new ArrayList();\n        intNodes.add(node);\n      }\n\n      de = de.getNext();\n      Assert.isTrue(de !== null, \"found null DE in ring\");\n      Assert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n    } while (de !== startDE);\n\n    return intNodes;\n  };\n\n  function Polygonizer() {\n    this._lineStringAdder = new LineStringAdder(this);\n    this._graph = null;\n    this._dangles = new ArrayList();\n    this._cutEdges = new ArrayList();\n    this._invalidRingLines = new ArrayList();\n    this._holeList = null;\n    this._shellList = null;\n    this._polyList = null;\n    this._isCheckingRingsValid = true;\n    this._extractOnlyPolygonal = null;\n    this._geomFactory = null;\n\n    if (arguments.length === 0) {\n      Polygonizer.call(this, false);\n    } else if (arguments.length === 1) {\n      var extractOnlyPolygonal = arguments[0];\n      this._extractOnlyPolygonal = extractOnlyPolygonal;\n    }\n  }\n  extend(Polygonizer.prototype, {\n    getGeometry: function getGeometry() {\n      if (this._geomFactory === null) this._geomFactory = new GeometryFactory();\n      this.polygonize();\n\n      if (this._extractOnlyPolygonal) {\n        return this._geomFactory.buildGeometry(this._polyList);\n      }\n\n      return this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));\n    },\n    getInvalidRingLines: function getInvalidRingLines() {\n      this.polygonize();\n      return this._invalidRingLines;\n    },\n    findValidRings: function findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {\n      for (var i = edgeRingList.iterator(); i.hasNext();) {\n        var er = i.next();\n        if (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());\n      }\n    },\n    polygonize: function polygonize() {\n      if (this._polyList !== null) return null;\n      this._polyList = new ArrayList();\n      if (this._graph === null) return null;\n      this._dangles = this._graph.deleteDangles();\n      this._cutEdges = this._graph.deleteCutEdges();\n\n      var edgeRingList = this._graph.getEdgeRings();\n\n      var validEdgeRingList = new ArrayList();\n      this._invalidRingLines = new ArrayList();\n\n      if (this._isCheckingRingsValid) {\n        this.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);\n      } else {\n        validEdgeRingList = edgeRingList;\n      }\n\n      this.findShellsAndHoles(validEdgeRingList);\n      Polygonizer.assignHolesToShells(this._holeList, this._shellList);\n      Collections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());\n      var includeAll = true;\n\n      if (this._extractOnlyPolygonal) {\n        Polygonizer.findDisjointShells(this._shellList);\n        includeAll = false;\n      }\n\n      this._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);\n    },\n    getDangles: function getDangles() {\n      this.polygonize();\n      return this._dangles;\n    },\n    getCutEdges: function getCutEdges() {\n      this.polygonize();\n      return this._cutEdges;\n    },\n    getPolygons: function getPolygons() {\n      this.polygonize();\n      return this._polyList;\n    },\n    add: function add() {\n      if (hasInterface(arguments[0], Collection)) {\n        var geomList = arguments[0];\n\n        for (var i = geomList.iterator(); i.hasNext();) {\n          var geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof LineString) {\n        var line = arguments[0];\n        this._geomFactory = line.getFactory();\n        if (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);\n\n        this._graph.addEdge(line);\n      } else if (arguments[0] instanceof Geometry) {\n        var g = arguments[0];\n        g.apply(this._lineStringAdder);\n      }\n    },\n    setCheckRingsValid: function setCheckRingsValid(isCheckingRingsValid) {\n      this._isCheckingRingsValid = isCheckingRingsValid;\n    },\n    findShellsAndHoles: function findShellsAndHoles(edgeRingList) {\n      this._holeList = new ArrayList();\n      this._shellList = new ArrayList();\n\n      for (var i = edgeRingList.iterator(); i.hasNext();) {\n        var er = i.next();\n        er.computeHole();\n        if (er.isHole()) this._holeList.add(er);else this._shellList.add(er);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Polygonizer;\n    }\n  });\n\n  Polygonizer.findOuterShells = function (shellList) {\n    for (var i = shellList.iterator(); i.hasNext();) {\n      var er = i.next();\n      var outerHoleER = er.getOuterHole();\n\n      if (outerHoleER !== null && !outerHoleER.isProcessed()) {\n        er.setIncluded(true);\n        outerHoleER.setProcessed(true);\n      }\n    }\n  };\n\n  Polygonizer.extractPolygons = function (shellList, includeAll) {\n    var polyList = new ArrayList();\n\n    for (var i = shellList.iterator(); i.hasNext();) {\n      var er = i.next();\n\n      if (includeAll || er.isIncluded()) {\n        polyList.add(er.getPolygon());\n      }\n    }\n\n    return polyList;\n  };\n\n  Polygonizer.assignHolesToShells = function (holeList, shellList) {\n    for (var i = holeList.iterator(); i.hasNext();) {\n      var holeER = i.next();\n      Polygonizer.assignHoleToShell(holeER, shellList);\n    }\n  };\n\n  Polygonizer.assignHoleToShell = function (holeER, shellList) {\n    var shell = EdgeRing$1.findEdgeRingContaining(holeER, shellList);\n\n    if (shell !== null) {\n      shell.addHole(holeER);\n    }\n  };\n\n  Polygonizer.findDisjointShells = function (shellList) {\n    Polygonizer.findOuterShells(shellList);\n    var isMoreToScan = null;\n\n    do {\n      isMoreToScan = false;\n\n      for (var i = shellList.iterator(); i.hasNext();) {\n        var er = i.next();\n        if (er.isIncludedSet()) continue;\n        er.updateIncluded();\n\n        if (!er.isIncludedSet()) {\n          isMoreToScan = true;\n        }\n      }\n    } while (isMoreToScan);\n  };\n\n  function LineStringAdder() {\n    this.p = null;\n    var p = arguments[0];\n    this.p = p;\n  }\n\n  extend(LineStringAdder.prototype, {\n    filter: function filter(g) {\n      if (g instanceof LineString) this.p.add(g);\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryComponentFilter];\n    },\n    getClass: function getClass() {\n      return LineStringAdder;\n    }\n  });\n  Polygonizer.LineStringAdder = LineStringAdder;\n\n\n\n  var polygonize = /*#__PURE__*/Object.freeze({\n    Polygonizer: Polygonizer\n  });\n\n  function EdgeEndBuilder() {}\n  extend(EdgeEndBuilder.prototype, {\n    createEdgeEndForNext: function createEdgeEndForNext(edge, l, eiCurr, eiNext) {\n      var iNext = eiCurr.segmentIndex + 1;\n      if (iNext >= edge.getNumPoints() && eiNext === null) return null;\n      var pNext = edge.getCoordinate(iNext);\n      if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n      var e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n      l.add(e);\n    },\n    createEdgeEndForPrev: function createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n      var iPrev = eiCurr.segmentIndex;\n\n      if (eiCurr.dist === 0.0) {\n        if (iPrev === 0) return null;\n        iPrev--;\n      }\n\n      var pPrev = edge.getCoordinate(iPrev);\n      if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n      var label = new Label(edge.getLabel());\n      label.flip();\n      var e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n      l.add(e);\n    },\n    computeEdgeEnds: function computeEdgeEnds() {\n      if (arguments.length === 1) {\n        var edges = arguments[0];\n        var l = new ArrayList();\n\n        for (var i = edges; i.hasNext();) {\n          var e = i.next();\n          this.computeEdgeEnds(e, l);\n        }\n\n        return l;\n      } else if (arguments.length === 2) {\n        var edge = arguments[0],\n            _l = arguments[1];\n        var eiList = edge.getEdgeIntersectionList();\n        eiList.addEndpoints();\n        var it = eiList.iterator();\n        var eiPrev = null;\n        var eiCurr = null;\n        if (!it.hasNext()) return null;\n        var eiNext = it.next();\n\n        do {\n          eiPrev = eiCurr;\n          eiCurr = eiNext;\n          eiNext = null;\n          if (it.hasNext()) eiNext = it.next();\n\n          if (eiCurr !== null) {\n            this.createEdgeEndForPrev(edge, _l, eiCurr, eiPrev);\n            this.createEdgeEndForNext(edge, _l, eiCurr, eiNext);\n          }\n        } while (eiCurr !== null);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeEndBuilder;\n    }\n  });\n\n  function EdgeEndBundle() {\n    this._edgeEnds = new ArrayList();\n\n    if (arguments.length === 1) {\n      var e = arguments[0];\n      EdgeEndBundle.call(this, null, e);\n    } else if (arguments.length === 2) {\n      var _e = arguments[1];\n      EdgeEnd.call(this, _e.getEdge(), _e.getCoordinate(), _e.getDirectedCoordinate(), new Label(_e.getLabel()));\n      this.insert(_e);\n    }\n  }\n  inherits(EdgeEndBundle, EdgeEnd);\n  extend(EdgeEndBundle.prototype, {\n    insert: function insert(e) {\n      this._edgeEnds.add(e);\n    },\n    print: function print(out) {\n      out.println(\"EdgeEndBundle--> Label: \" + this._label);\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var ee = it.next();\n        ee.print(out);\n        out.println();\n      }\n    },\n    iterator: function iterator() {\n      return this._edgeEnds.iterator();\n    },\n    getEdgeEnds: function getEdgeEnds() {\n      return this._edgeEnds;\n    },\n    computeLabelOn: function computeLabelOn(geomIndex, boundaryNodeRule) {\n      var boundaryCount = 0;\n      var foundInterior = false;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        var loc = e.getLabel().getLocation(geomIndex);\n        if (loc === Location.BOUNDARY) boundaryCount++;\n        if (loc === Location.INTERIOR) foundInterior = true;\n      }\n\n      var loc = Location.NONE;\n      if (foundInterior) loc = Location.INTERIOR;\n\n      if (boundaryCount > 0) {\n        loc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n      }\n\n      this._label.setLocation(geomIndex, loc);\n    },\n    computeLabelSide: function computeLabelSide(geomIndex, side) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n\n        if (e.getLabel().isArea()) {\n          var loc = e.getLabel().getLocation(geomIndex, side);\n\n          if (loc === Location.INTERIOR) {\n            this._label.setLocation(geomIndex, side, Location.INTERIOR);\n\n            return null;\n          } else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n        }\n      }\n    },\n    getLabel: function getLabel() {\n      return this._label;\n    },\n    computeLabelSides: function computeLabelSides(geomIndex) {\n      this.computeLabelSide(geomIndex, Position.LEFT);\n      this.computeLabelSide(geomIndex, Position.RIGHT);\n    },\n    updateIM: function updateIM(im) {\n      Edge.updateIM(this._label, im);\n    },\n    computeLabel: function computeLabel(boundaryNodeRule) {\n      var isArea = false;\n\n      for (var it = this.iterator(); it.hasNext();) {\n        var e = it.next();\n        if (e.getLabel().isArea()) isArea = true;\n      }\n\n      if (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);\n\n      for (var i = 0; i < 2; i++) {\n        this.computeLabelOn(i, boundaryNodeRule);\n        if (isArea) this.computeLabelSides(i);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeEndBundle;\n    }\n  });\n\n  function EdgeEndBundleStar() {\n    EdgeEndStar.apply(this);\n  }\n  inherits(EdgeEndBundleStar, EdgeEndStar);\n  extend(EdgeEndBundleStar.prototype, {\n    updateIM: function updateIM(im) {\n      for (var it = this.iterator(); it.hasNext();) {\n        var esb = it.next();\n        esb.updateIM(im);\n      }\n    },\n    insert: function insert(e) {\n      var eb = this._edgeMap.get(e);\n\n      if (eb === null) {\n        eb = new EdgeEndBundle(e);\n        this.insertEdgeEnd(e, eb);\n      } else {\n        eb.insert(e);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EdgeEndBundleStar;\n    }\n  });\n\n  function RelateNode() {\n    var coord = arguments[0],\n        edges = arguments[1];\n    Node$1.call(this, coord, edges);\n  }\n  inherits(RelateNode, Node$1);\n  extend(RelateNode.prototype, {\n    updateIMFromEdges: function updateIMFromEdges(im) {\n      this._edges.updateIM(im);\n    },\n    computeIM: function computeIM(im) {\n      im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RelateNode;\n    }\n  });\n\n  function RelateNodeFactory() {\n    NodeFactory.apply(this);\n  }\n  inherits(RelateNodeFactory, NodeFactory);\n  extend(RelateNodeFactory.prototype, {\n    createNode: function createNode(coord) {\n      return new RelateNode(coord, new EdgeEndBundleStar());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RelateNodeFactory;\n    }\n  });\n\n  function RelateComputer() {\n    this._li = new RobustLineIntersector();\n    this._ptLocator = new PointLocator();\n    this._arg = null;\n    this._nodes = new NodeMap(new RelateNodeFactory());\n    this._im = null;\n    this._isolatedEdges = new ArrayList();\n    this._invalidPoint = null;\n    var arg = arguments[0];\n    this._arg = arg;\n  }\n  extend(RelateComputer.prototype, {\n    insertEdgeEnds: function insertEdgeEnds(ee) {\n      for (var i = ee.iterator(); i.hasNext();) {\n        var e = i.next();\n\n        this._nodes.add(e);\n      }\n    },\n    computeProperIntersectionIM: function computeProperIntersectionIM(intersector, im) {\n      var dimA = this._arg[0].getGeometry().getDimension();\n\n      var dimB = this._arg[1].getGeometry().getDimension();\n\n      var hasProper = intersector.hasProperIntersection();\n      var hasProperInterior = intersector.hasProperInteriorIntersection();\n\n      if (dimA === 2 && dimB === 2) {\n        if (hasProper) im.setAtLeast(\"212101212\");\n      } else if (dimA === 2 && dimB === 1) {\n        if (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n        if (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n      } else if (dimA === 1 && dimB === 2) {\n        if (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n        if (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n      } else if (dimA === 1 && dimB === 1) {\n        if (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n      }\n    },\n    labelIsolatedEdges: function labelIsolatedEdges(thisIndex, targetIndex) {\n      for (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {\n        var e = ei.next();\n\n        if (e.isIsolated()) {\n          this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\n          this._isolatedEdges.add(e);\n        }\n      }\n    },\n    labelIsolatedEdge: function labelIsolatedEdge(e, targetIndex, target) {\n      if (target.getDimension() > 0) {\n        var loc = this._ptLocator.locate(e.getCoordinate(), target);\n\n        e.getLabel().setAllLocations(targetIndex, loc);\n      } else {\n        e.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n      }\n    },\n    computeIM: function computeIM() {\n      var im = new IntersectionMatrix();\n      im.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\n      if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n        this.computeDisjointIM(im);\n        return im;\n      }\n\n      this._arg[0].computeSelfNodes(this._li, false);\n\n      this._arg[1].computeSelfNodes(this._li, false);\n\n      var intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\n      this.computeIntersectionNodes(0);\n      this.computeIntersectionNodes(1);\n      this.copyNodesAndLabels(0);\n      this.copyNodesAndLabels(1);\n      this.labelIsolatedNodes();\n      this.computeProperIntersectionIM(intersector, im);\n      var eeBuilder = new EdgeEndBuilder();\n      var ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n      this.insertEdgeEnds(ee0);\n      var ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n      this.insertEdgeEnds(ee1);\n      this.labelNodeEdges();\n      this.labelIsolatedEdges(0, 1);\n      this.labelIsolatedEdges(1, 0);\n      this.updateIM(im);\n      return im;\n    },\n    labelNodeEdges: function labelNodeEdges() {\n      for (var ni = this._nodes.iterator(); ni.hasNext();) {\n        var node = ni.next();\n        node.getEdges().computeLabelling(this._arg);\n      }\n    },\n    copyNodesAndLabels: function copyNodesAndLabels(argIndex) {\n      for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n        var graphNode = i.next();\n\n        var newNode = this._nodes.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    },\n    labelIntersectionNodes: function labelIntersectionNodes(argIndex) {\n      for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n        var e = i.next();\n        var eLoc = e.getLabel().getLocation(argIndex);\n\n        for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          var ei = eiIt.next();\n\n          var n = this._nodes.find(ei.coord);\n\n          if (n.getLabel().isNull(argIndex)) {\n            if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);\n          }\n        }\n      }\n    },\n    labelIsolatedNode: function labelIsolatedNode(n, targetIndex) {\n      var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\n      n.getLabel().setAllLocations(targetIndex, loc);\n    },\n    computeIntersectionNodes: function computeIntersectionNodes(argIndex) {\n      for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n        var e = i.next();\n        var eLoc = e.getLabel().getLocation(argIndex);\n\n        for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          var ei = eiIt.next();\n\n          var n = this._nodes.addNode(ei.coord);\n\n          if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n            if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n          }\n        }\n      }\n    },\n    labelIsolatedNodes: function labelIsolatedNodes() {\n      for (var ni = this._nodes.iterator(); ni.hasNext();) {\n        var n = ni.next();\n        var label = n.getLabel();\n        Assert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\n        if (n.isIsolated()) {\n          if (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);\n        }\n      }\n    },\n    updateIM: function updateIM(im) {\n      for (var ei = this._isolatedEdges.iterator(); ei.hasNext();) {\n        var e = ei.next();\n        e.updateIM(im);\n      }\n\n      for (var ni = this._nodes.iterator(); ni.hasNext();) {\n        var node = ni.next();\n        node.updateIM(im);\n        node.updateIMFromEdges(im);\n      }\n    },\n    computeDisjointIM: function computeDisjointIM(im) {\n      var ga = this._arg[0].getGeometry();\n\n      if (!ga.isEmpty()) {\n        im.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n        im.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n      }\n\n      var gb = this._arg[1].getGeometry();\n\n      if (!gb.isEmpty()) {\n        im.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n        im.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RelateComputer;\n    }\n  });\n\n  function RectangleContains() {\n    this._rectEnv = null;\n    var rectangle = arguments[0];\n    this._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleContains.prototype, {\n    isContainedInBoundary: function isContainedInBoundary(geom) {\n      if (geom instanceof Polygon) return false;\n      if (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n      if (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var comp = geom.getGeometryN(i);\n        if (!this.isContainedInBoundary(comp)) return false;\n      }\n\n      return true;\n    },\n    isLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(p0, p1) {\n      if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\n      if (p0.x === p1.x) {\n        if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n      } else if (p0.y === p1.y) {\n        if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n      }\n\n      return false;\n    },\n    isLineStringContainedInBoundary: function isLineStringContainedInBoundary(line) {\n      var seq = line.getCoordinateSequence();\n      var p0 = new Coordinate();\n      var p1 = new Coordinate();\n\n      for (var i = 0; i < seq.size() - 1; i++) {\n        seq.getCoordinate(i, p0);\n        seq.getCoordinate(i + 1, p1);\n        if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n      }\n\n      return true;\n    },\n    isPointContainedInBoundary: function isPointContainedInBoundary() {\n      if (arguments[0] instanceof Point) {\n        var point = arguments[0];\n        return this.isPointContainedInBoundary(point.getCoordinate());\n      } else if (arguments[0] instanceof Coordinate) {\n        var pt = arguments[0];\n        return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n      }\n    },\n    contains: function contains(geom) {\n      if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n      if (this.isContainedInBoundary(geom)) return false;\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RectangleContains;\n    }\n  });\n\n  RectangleContains.contains = function (rectangle, b) {\n    var rc = new RectangleContains(rectangle);\n    return rc.contains(b);\n  };\n\n  function RectangleLineIntersector() {\n    this._li = new RobustLineIntersector();\n    this._rectEnv = null;\n    this._diagUp0 = null;\n    this._diagUp1 = null;\n    this._diagDown0 = null;\n    this._diagDown1 = null;\n    var rectEnv = arguments[0];\n    this._rectEnv = rectEnv;\n    this._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n    this._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n    this._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n    this._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n  }\n  extend(RectangleLineIntersector.prototype, {\n    intersects: function intersects(p0, p1) {\n      var segEnv = new Envelope(p0, p1);\n      if (!this._rectEnv.intersects(segEnv)) return false;\n      if (this._rectEnv.intersects(p0)) return true;\n      if (this._rectEnv.intersects(p1)) return true;\n\n      if (p0.compareTo(p1) > 0) {\n        var tmp = p0;\n        p0 = p1;\n        p1 = tmp;\n      }\n\n      var isSegUpwards = false;\n      if (p1.y > p0.y) isSegUpwards = true;\n\n      if (isSegUpwards) {\n        this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);\n      } else {\n        this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n      }\n\n      if (this._li.hasIntersection()) return true;\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RectangleLineIntersector;\n    }\n  });\n\n  function ShortCircuitedGeometryVisitor() {\n    this._isDone = false;\n  }\n  extend(ShortCircuitedGeometryVisitor.prototype, {\n    applyTo: function applyTo(geom) {\n      for (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n        var element = geom.getGeometryN(i);\n\n        if (!(element instanceof GeometryCollection)) {\n          this.visit(element);\n\n          if (this.isDone()) {\n            this._isDone = true;\n            return null;\n          }\n        } else this.applyTo(element);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ShortCircuitedGeometryVisitor;\n    }\n  });\n\n  function RectangleIntersects() {\n    this._rectangle = null;\n    this._rectEnv = null;\n    var rectangle = arguments[0];\n    this._rectangle = rectangle;\n    this._rectEnv = rectangle.getEnvelopeInternal();\n  }\n  extend(RectangleIntersects.prototype, {\n    intersects: function intersects(geom) {\n      if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n      var visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n      visitor.applyTo(geom);\n      if (visitor.intersects()) return true;\n      var ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n      ecpVisitor.applyTo(geom);\n      if (ecpVisitor.containsPoint()) return true;\n      var riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n      riVisitor.applyTo(geom);\n      if (riVisitor.intersects()) return true;\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RectangleIntersects;\n    }\n  });\n\n  RectangleIntersects.intersects = function (rectangle, b) {\n    var rp = new RectangleIntersects(rectangle);\n    return rp.intersects(b);\n  };\n\n  function EnvelopeIntersectsVisitor() {\n    ShortCircuitedGeometryVisitor.apply(this);\n    this._rectEnv = null;\n    this._intersects = false;\n    var rectEnv = arguments[0];\n    this._rectEnv = rectEnv;\n  }\n\n  inherits(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);\n  extend(EnvelopeIntersectsVisitor.prototype, {\n    isDone: function isDone() {\n      return this._intersects === true;\n    },\n    visit: function visit(element) {\n      var elementEnv = element.getEnvelopeInternal();\n\n      if (!this._rectEnv.intersects(elementEnv)) {\n        return null;\n      }\n\n      if (this._rectEnv.contains(elementEnv)) {\n        this._intersects = true;\n        return null;\n      }\n\n      if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n        this._intersects = true;\n        return null;\n      }\n\n      if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n        this._intersects = true;\n        return null;\n      }\n    },\n    intersects: function intersects() {\n      return this._intersects;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return EnvelopeIntersectsVisitor;\n    }\n  });\n\n  function GeometryContainsPointVisitor() {\n    ShortCircuitedGeometryVisitor.apply(this);\n    this._rectSeq = null;\n    this._rectEnv = null;\n    this._containsPoint = false;\n    var rectangle = arguments[0];\n    this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n    this._rectEnv = rectangle.getEnvelopeInternal();\n  }\n\n  inherits(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);\n  extend(GeometryContainsPointVisitor.prototype, {\n    isDone: function isDone() {\n      return this._containsPoint === true;\n    },\n    visit: function visit(geom) {\n      if (!(geom instanceof Polygon)) return null;\n      var elementEnv = geom.getEnvelopeInternal();\n      if (!this._rectEnv.intersects(elementEnv)) return null;\n      var rectPt = new Coordinate();\n\n      for (var i = 0; i < 4; i++) {\n        this._rectSeq.getCoordinate(i, rectPt);\n\n        if (!elementEnv.contains(rectPt)) continue;\n\n        if (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n          this._containsPoint = true;\n          return null;\n        }\n      }\n    },\n    containsPoint: function containsPoint() {\n      return this._containsPoint;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryContainsPointVisitor;\n    }\n  });\n\n  function RectangleIntersectsSegmentVisitor() {\n    ShortCircuitedGeometryVisitor.apply(this);\n    this._rectEnv = null;\n    this._rectIntersector = null;\n    this._hasIntersection = false;\n    this._p0 = new Coordinate();\n    this._p1 = new Coordinate();\n    var rectangle = arguments[0];\n    this._rectEnv = rectangle.getEnvelopeInternal();\n    this._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n  }\n\n  inherits(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);\n  extend(RectangleIntersectsSegmentVisitor.prototype, {\n    intersects: function intersects() {\n      return this._hasIntersection;\n    },\n    isDone: function isDone() {\n      return this._hasIntersection === true;\n    },\n    visit: function visit(geom) {\n      var elementEnv = geom.getEnvelopeInternal();\n      if (!this._rectEnv.intersects(elementEnv)) return null;\n      var lines = LinearComponentExtracter.getLines(geom);\n      this.checkIntersectionWithLineStrings(lines);\n    },\n    checkIntersectionWithLineStrings: function checkIntersectionWithLineStrings(lines) {\n      for (var i = lines.iterator(); i.hasNext();) {\n        var testLine = i.next();\n        this.checkIntersectionWithSegments(testLine);\n        if (this._hasIntersection) return null;\n      }\n    },\n    checkIntersectionWithSegments: function checkIntersectionWithSegments(testLine) {\n      var seq1 = testLine.getCoordinateSequence();\n\n      for (var j = 1; j < seq1.size(); j++) {\n        seq1.getCoordinate(j - 1, this._p0);\n        seq1.getCoordinate(j, this._p1);\n\n        if (this._rectIntersector.intersects(this._p0, this._p1)) {\n          this._hasIntersection = true;\n          return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RectangleIntersectsSegmentVisitor;\n    }\n  });\n\n  function RelateOp() {\n    this._relate = null;\n\n    if (arguments.length === 2) {\n      var g0 = arguments[0],\n          g1 = arguments[1];\n      GeometryGraphOperation.call(this, g0, g1);\n      this._relate = new RelateComputer(this._arg);\n    } else if (arguments.length === 3) {\n      var _g = arguments[0],\n          _g2 = arguments[1],\n          boundaryNodeRule = arguments[2];\n      GeometryGraphOperation.call(this, _g, _g2, boundaryNodeRule);\n      this._relate = new RelateComputer(this._arg);\n    }\n  }\n  inherits(RelateOp, GeometryGraphOperation);\n  extend(RelateOp.prototype, {\n    getIntersectionMatrix: function getIntersectionMatrix() {\n      return this._relate.computeIM();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RelateOp;\n    }\n  });\n\n  RelateOp.covers = function (g1, g2) {\n    if (g2.getDimension() === 2 && g1.getDimension() < 2) {\n      return false;\n    }\n\n    if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n      return false;\n    }\n\n    if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\n    if (g1.isRectangle()) {\n      return true;\n    }\n\n    return new RelateOp(g1, g2).getIntersectionMatrix().isCovers();\n  };\n\n  RelateOp.intersects = function (g1, g2) {\n    if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\n    if (g1.isRectangle()) {\n      return RectangleIntersects.intersects(g1, g2);\n    }\n\n    if (g2.isRectangle()) {\n      return RectangleIntersects.intersects(g2, g1);\n    }\n\n    if (g1.isGeometryCollection() || g2.isGeometryCollection()) {\n\n      for (var i = 0; i < g1.getNumGeometries(); i++) {\n        for (var j = 0; j < g2.getNumGeometries(); j++) {\n          if (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();\n  };\n\n  RelateOp.touches = function (g1, g2) {\n    if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n    return new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());\n  };\n\n  RelateOp.relate = function () {\n    if (arguments.length === 2) {\n      var a = arguments[0],\n          b = arguments[1];\n      var relOp = new RelateOp(a, b);\n      var im = relOp.getIntersectionMatrix();\n      return im;\n    } else if (arguments.length === 3) {\n      var _a = arguments[0],\n          _b = arguments[1],\n          boundaryNodeRule = arguments[2];\n      var relOp = new RelateOp(_a, _b, boundaryNodeRule);\n      var im = relOp.getIntersectionMatrix();\n      return im;\n    }\n  };\n\n  RelateOp.overlaps = function (g1, g2) {\n    if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n    return new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());\n  };\n\n  RelateOp.crosses = function (g1, g2) {\n    if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n    return new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());\n  };\n\n  RelateOp.contains = function (g1, g2) {\n    if (g2.getDimension() === 2 && g1.getDimension() < 2) {\n      return false;\n    }\n\n    if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {\n      return false;\n    }\n\n    if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\n    if (g1.isRectangle()) {\n      return RectangleContains.contains(g1, g2);\n    }\n\n    return new RelateOp(g1, g2).getIntersectionMatrix().isContains();\n  };\n\n\n\n  var relate = /*#__PURE__*/Object.freeze({\n    RelateOp: RelateOp\n  });\n\n  function GeometryCombiner() {\n    this._geomFactory = null;\n    this._skipEmpty = false;\n    this._inputGeoms = null;\n    var geoms = arguments[0];\n    this._geomFactory = GeometryCombiner.extractFactory(geoms);\n    this._inputGeoms = geoms;\n  }\n  extend(GeometryCombiner.prototype, {\n    extractElements: function extractElements(geom, elems) {\n      if (geom === null) return null;\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var elemGeom = geom.getGeometryN(i);\n        if (this._skipEmpty && elemGeom.isEmpty()) continue;\n        elems.add(elemGeom);\n      }\n    },\n    combine: function combine() {\n      var elems = new ArrayList();\n\n      for (var i = this._inputGeoms.iterator(); i.hasNext();) {\n        var g = i.next();\n        this.extractElements(g, elems);\n      }\n\n      if (elems.size() === 0) {\n        if (this._geomFactory !== null) {\n          return this._geomFactory.createGeometryCollection();\n        }\n\n        return null;\n      }\n\n      return this._geomFactory.buildGeometry(elems);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryCombiner;\n    }\n  });\n\n  GeometryCombiner.combine = function () {\n    if (arguments.length === 1) {\n      var geoms = arguments[0];\n      var combiner = new GeometryCombiner(geoms);\n      return combiner.combine();\n    } else if (arguments.length === 2) {\n      var g0 = arguments[0],\n          g1 = arguments[1];\n      var combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n      return combiner.combine();\n    } else if (arguments.length === 3) {\n      var _g = arguments[0],\n          _g2 = arguments[1],\n          g2 = arguments[2];\n      var combiner = new GeometryCombiner(GeometryCombiner.createList(_g, _g2, g2));\n      return combiner.combine();\n    }\n  };\n\n  GeometryCombiner.extractFactory = function (geoms) {\n    if (geoms.isEmpty()) return null;\n    return geoms.iterator().next().getFactory();\n  };\n\n  GeometryCombiner.createList = function () {\n    if (arguments.length === 2) {\n      var obj0 = arguments[0],\n          obj1 = arguments[1];\n      var list = new ArrayList();\n      list.add(obj0);\n      list.add(obj1);\n      return list;\n    } else if (arguments.length === 3) {\n      var _obj = arguments[0],\n          _obj2 = arguments[1],\n          obj2 = arguments[2];\n      var list = new ArrayList();\n      list.add(_obj);\n      list.add(_obj2);\n      list.add(obj2);\n      return list;\n    }\n  };\n\n  function PointGeometryUnion() {\n    this._pointGeom = null;\n    this._otherGeom = null;\n    this._geomFact = null;\n    var pointGeom = arguments[0],\n        otherGeom = arguments[1];\n    this._pointGeom = pointGeom;\n    this._otherGeom = otherGeom;\n    this._geomFact = otherGeom.getFactory();\n  }\n  extend(PointGeometryUnion.prototype, {\n    union: function union() {\n      var locater = new PointLocator();\n      var exteriorCoords = new TreeSet();\n\n      for (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {\n        var point = this._pointGeom.getGeometryN(i);\n\n        var coord = point.getCoordinate();\n        var loc = locater.locate(coord, this._otherGeom);\n        if (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n      }\n\n      if (exteriorCoords.size() === 0) return this._otherGeom;\n      var ptComp = null;\n      var coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n\n      if (coords.length === 1) {\n        ptComp = this._geomFact.createPoint(coords[0]);\n      } else {\n        ptComp = this._geomFact.createMultiPointFromCoords(coords);\n      }\n\n      return GeometryCombiner.combine(ptComp, this._otherGeom);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PointGeometryUnion;\n    }\n  });\n\n  PointGeometryUnion.union = function (pointGeom, otherGeom) {\n    var unioner = new PointGeometryUnion(pointGeom, otherGeom);\n    return unioner.union();\n  };\n\n  function GeometryExtracter() {\n    this._geometryType = null;\n    this._comps = null;\n    var geometryType = arguments[0],\n        comps = arguments[1];\n    this._geometryType = geometryType;\n    this._comps = comps;\n  }\n  extend(GeometryExtracter.prototype, {\n    filter: function filter(geom) {\n      if (this._geometryType === null || GeometryExtracter.isOfType(geom, this._geometryType)) this._comps.add(geom);\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryFilter];\n    },\n    getClass: function getClass() {\n      return GeometryExtracter;\n    }\n  });\n\n  GeometryExtracter.isOfType = function (geom, geometryType) {\n    if (geom.getGeometryType() === geometryType) return true;\n    if (geometryType === Geometry.TYPENAME_LINESTRING && geom.getGeometryType() === Geometry.TYPENAME_LINEARRING) return true;\n    return false;\n  };\n\n  GeometryExtracter.extract = function () {\n    if (arguments.length === 2) {\n      var geom = arguments[0],\n          geometryType = arguments[1];\n      return GeometryExtracter.extract(geom, geometryType, new ArrayList());\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], List) && arguments[0] instanceof Geometry && typeof arguments[1] === \"string\") {\n        var _geom = arguments[0],\n            _geometryType = arguments[1],\n            list = arguments[2];\n\n        if (_geom.getGeometryType() === _geometryType) {\n          list.add(_geom);\n        } else if (_geom instanceof GeometryCollection) {\n          _geom.apply(new GeometryExtracter(_geometryType, list));\n        }\n\n        return list;\n      } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Geometry && arguments[1] instanceof Class) {\n        var _geom2 = arguments[0],\n            clz = arguments[1],\n            _list = arguments[2];\n        return GeometryExtracter.extract(_geom2, GeometryExtracter.toGeometryType(clz), _list);\n      }\n    }\n  };\n\n  function CascadedPolygonUnion() {\n    this._inputPolys = null;\n    this._geomFactory = null;\n    var polys = arguments[0];\n    this._inputPolys = polys;\n    if (this._inputPolys === null) this._inputPolys = new ArrayList();\n  }\n  extend(CascadedPolygonUnion.prototype, {\n    reduceToGeometries: function reduceToGeometries(geomTree) {\n      var geoms = new ArrayList();\n\n      for (var i = geomTree.iterator(); i.hasNext();) {\n        var o = i.next();\n        var geom = null;\n\n        if (hasInterface(o, List)) {\n          geom = this.unionTree(o);\n        } else if (o instanceof Geometry) {\n          geom = o;\n        }\n\n        geoms.add(geom);\n      }\n\n      return geoms;\n    },\n    extractByEnvelope: function extractByEnvelope(env, geom, disjointGeoms) {\n      var intersectingGeoms = new ArrayList();\n\n      for (var i = 0; i < geom.getNumGeometries(); i++) {\n        var elem = geom.getGeometryN(i);\n        if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);\n      }\n\n      return this._geomFactory.buildGeometry(intersectingGeoms);\n    },\n    unionOptimized: function unionOptimized(g0, g1) {\n      var g0Env = g0.getEnvelopeInternal();\n      var g1Env = g1.getEnvelopeInternal();\n\n      if (!g0Env.intersects(g1Env)) {\n        var combo = GeometryCombiner.combine(g0, g1);\n        return combo;\n      }\n\n      if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);\n      var commonEnv = g0Env.intersection(g1Env);\n      return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n    },\n    union: function union() {\n      if (this._inputPolys === null) throw new IllegalStateException(\"union() method cannot be called twice\");\n      if (this._inputPolys.isEmpty()) return null;\n      this._geomFactory = this._inputPolys.iterator().next().getFactory();\n      var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n\n      for (var i = this._inputPolys.iterator(); i.hasNext();) {\n        var item = i.next();\n        index.insert(item.getEnvelopeInternal(), item);\n      }\n\n      this._inputPolys = null;\n      var itemTree = index.itemsTree();\n      var unionAll = this.unionTree(itemTree);\n      return unionAll;\n    },\n    binaryUnion: function binaryUnion() {\n      if (arguments.length === 1) {\n        var geoms = arguments[0];\n        return this.binaryUnion(geoms, 0, geoms.size());\n      } else if (arguments.length === 3) {\n        var _geoms = arguments[0],\n            start = arguments[1],\n            end = arguments[2];\n\n        if (end - start <= 1) {\n          var g0 = CascadedPolygonUnion.getGeometry(_geoms, start);\n          return this.unionSafe(g0, null);\n        } else if (end - start === 2) {\n          return this.unionSafe(CascadedPolygonUnion.getGeometry(_geoms, start), CascadedPolygonUnion.getGeometry(_geoms, start + 1));\n        } else {\n          var mid = Math.trunc((end + start) / 2);\n          var g0 = this.binaryUnion(_geoms, start, mid);\n          var g1 = this.binaryUnion(_geoms, mid, end);\n          return this.unionSafe(g0, g1);\n        }\n      }\n    },\n    repeatedUnion: function repeatedUnion(geoms) {\n      var union = null;\n\n      for (var i = geoms.iterator(); i.hasNext();) {\n        var g = i.next();\n        if (union === null) union = g.copy();else union = union.union(g);\n      }\n\n      return union;\n    },\n    unionSafe: function unionSafe(g0, g1) {\n      if (g0 === null && g1 === null) return null;\n      if (g0 === null) return g1.copy();\n      if (g1 === null) return g0.copy();\n      return this.unionOptimized(g0, g1);\n    },\n    unionActual: function unionActual(g0, g1) {\n      return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n    },\n    unionTree: function unionTree(geomTree) {\n      var geoms = this.reduceToGeometries(geomTree);\n      var union = this.binaryUnion(geoms);\n      return union;\n    },\n    unionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(g0, g1, common) {\n      var disjointPolys = new ArrayList();\n      var g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n      var g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n      var union = this.unionActual(g0Int, g1Int);\n      disjointPolys.add(union);\n      var overallUnion = GeometryCombiner.combine(disjointPolys);\n      return overallUnion;\n    },\n    bufferUnion: function bufferUnion() {\n      if (arguments.length === 1) {\n        var geoms = arguments[0];\n        var factory = geoms.get(0).getFactory();\n        var gColl = factory.buildGeometry(geoms);\n        var unionAll = gColl.buffer(0.0);\n        return unionAll;\n      } else if (arguments.length === 2) {\n        var g0 = arguments[0],\n            g1 = arguments[1];\n        var factory = g0.getFactory();\n        var gColl = factory.createGeometryCollection([g0, g1]);\n        var unionAll = gColl.buffer(0.0);\n        return unionAll;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return CascadedPolygonUnion;\n    }\n  });\n\n  CascadedPolygonUnion.restrictToPolygons = function (g) {\n    if (hasInterface(g, Polygonal)) {\n      return g;\n    }\n\n    var polygons = PolygonExtracter.getPolygons(g);\n    if (polygons.size() === 1) return polygons.get(0);\n    return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n  };\n\n  CascadedPolygonUnion.getGeometry = function (list, index) {\n    if (index >= list.size()) return null;\n    return list.get(index);\n  };\n\n  CascadedPolygonUnion.union = function (polys) {\n    var op = new CascadedPolygonUnion(polys);\n    return op.union();\n  };\n\n  CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n\n  function UnaryUnionOp() {\n    this._polygons = new ArrayList();\n    this._lines = new ArrayList();\n    this._points = new ArrayList();\n    this._geomFact = null;\n\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], Collection)) {\n        var geoms = arguments[0];\n        this.extract(geoms);\n      } else if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n        this.extract(geom);\n      }\n    } else if (arguments.length === 2) {\n      var _geoms = arguments[0],\n          geomFact = arguments[1];\n      this._geomFact = geomFact;\n      this.extract(_geoms);\n    }\n  }\n  extend(UnaryUnionOp.prototype, {\n    unionNoOpt: function unionNoOpt(g0) {\n      var empty = this._geomFact.createPoint();\n\n      return SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n    },\n    unionWithNull: function unionWithNull(g0, g1) {\n      if (g0 === null && g1 === null) return null;\n      if (g1 === null) return g0;\n      if (g0 === null) return g1;\n      return g0.union(g1);\n    },\n    extract: function extract() {\n      if (hasInterface(arguments[0], Collection)) {\n        var geoms = arguments[0];\n\n        for (var i = geoms.iterator(); i.hasNext();) {\n          var geom = i.next();\n          this.extract(geom);\n        }\n      } else if (arguments[0] instanceof Geometry) {\n        var _geom = arguments[0];\n        if (this._geomFact === null) this._geomFact = _geom.getFactory();\n        GeometryExtracter.extract(_geom, Geometry.TYPENAME_POLYGON, this._polygons);\n        GeometryExtracter.extract(_geom, Geometry.TYPENAME_LINESTRING, this._lines);\n        GeometryExtracter.extract(_geom, Geometry.TYPENAME_POINT, this._points);\n      }\n    },\n    union: function union() {\n      if (this._geomFact === null) {\n        return null;\n      }\n\n      var unionPoints = null;\n\n      if (this._points.size() > 0) {\n        var ptGeom = this._geomFact.buildGeometry(this._points);\n\n        unionPoints = this.unionNoOpt(ptGeom);\n      }\n\n      var unionLines = null;\n\n      if (this._lines.size() > 0) {\n        var lineGeom = this._geomFact.buildGeometry(this._lines);\n\n        unionLines = this.unionNoOpt(lineGeom);\n      }\n\n      var unionPolygons = null;\n\n      if (this._polygons.size() > 0) {\n        unionPolygons = CascadedPolygonUnion.union(this._polygons);\n      }\n\n      var unionLA = this.unionWithNull(unionLines, unionPolygons);\n      var union = null;\n      if (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);\n      if (union === null) return this._geomFact.createGeometryCollection();\n      return union;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return UnaryUnionOp;\n    }\n  });\n\n  UnaryUnionOp.union = function () {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], Collection)) {\n        var geoms = arguments[0];\n        var op = new UnaryUnionOp(geoms);\n        return op.union();\n      } else if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n        var op = new UnaryUnionOp(geom);\n        return op.union();\n      }\n    } else if (arguments.length === 2) {\n      var _geoms2 = arguments[0],\n          geomFact = arguments[1];\n      var op = new UnaryUnionOp(_geoms2, geomFact);\n      return op.union();\n    }\n  };\n\n\n\n  var union = /*#__PURE__*/Object.freeze({\n    UnaryUnionOp: UnaryUnionOp\n  });\n\n  function ConnectedInteriorTester() {\n    this._geometryFactory = new GeometryFactory();\n    this._geomGraph = null;\n    this._disconnectedRingcoord = null;\n    var geomGraph = arguments[0];\n    this._geomGraph = geomGraph;\n  }\n  extend(ConnectedInteriorTester.prototype, {\n    visitInteriorRing: function visitInteriorRing(ring, graph) {\n      var pts = ring.getCoordinates();\n      var pt0 = pts[0];\n      var pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n      var e = graph.findEdgeInSameDirection(pt0, pt1);\n      var de = graph.findEdgeEnd(e);\n      var intDe = null;\n\n      if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n        intDe = de;\n      } else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n        intDe = de.getSym();\n      }\n\n      Assert.isTrue(intDe !== null, \"unable to find dirEdge with Interior on RHS\");\n      this.visitLinkedDirectedEdges(intDe);\n    },\n    visitShellInteriors: function visitShellInteriors(g, graph) {\n      if (g instanceof Polygon) {\n        var p = g;\n        this.visitInteriorRing(p.getExteriorRing(), graph);\n      }\n\n      if (g instanceof MultiPolygon) {\n        var mp = g;\n\n        for (var i = 0; i < mp.getNumGeometries(); i++) {\n          var p = mp.getGeometryN(i);\n          this.visitInteriorRing(p.getExteriorRing(), graph);\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this._disconnectedRingcoord;\n    },\n    setInteriorEdgesInResult: function setInteriorEdgesInResult(graph) {\n      for (var it = graph.getEdgeEnds().iterator(); it.hasNext();) {\n        var de = it.next();\n\n        if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n          de.setInResult(true);\n        }\n      }\n    },\n    visitLinkedDirectedEdges: function visitLinkedDirectedEdges(start) {\n      var startDe = start;\n      var de = start;\n\n      do {\n        Assert.isTrue(de !== null, \"found null Directed Edge\");\n        de.setVisited(true);\n        de = de.getNext();\n      } while (de !== startDe);\n    },\n    buildEdgeRings: function buildEdgeRings(dirEdges) {\n      var edgeRings = new ArrayList();\n\n      for (var it = dirEdges.iterator(); it.hasNext();) {\n        var de = it.next();\n\n        if (de.isInResult() && de.getEdgeRing() === null) {\n          var er = new MaximalEdgeRing(de, this._geometryFactory);\n          er.linkDirectedEdgesForMinimalEdgeRings();\n          var minEdgeRings = er.buildMinimalRings();\n          edgeRings.addAll(minEdgeRings);\n        }\n      }\n\n      return edgeRings;\n    },\n    hasUnvisitedShellEdge: function hasUnvisitedShellEdge(edgeRings) {\n      for (var i = 0; i < edgeRings.size(); i++) {\n        var er = edgeRings.get(i);\n        if (er.isHole()) continue;\n        var edges = er.getEdges();\n        var de = edges.get(0);\n        if (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n\n        for (var j = 0; j < edges.size(); j++) {\n          de = edges.get(j);\n\n          if (!de.isVisited()) {\n            this._disconnectedRingcoord = de.getCoordinate();\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    isInteriorsConnected: function isInteriorsConnected() {\n      var splitEdges = new ArrayList();\n\n      this._geomGraph.computeSplitEdges(splitEdges);\n\n      var graph = new PlanarGraph(new OverlayNodeFactory());\n      graph.addEdges(splitEdges);\n      this.setInteriorEdgesInResult(graph);\n      graph.linkResultDirectedEdges();\n      var edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n      this.visitShellInteriors(this._geomGraph.getGeometry(), graph);\n      return !this.hasUnvisitedShellEdge(edgeRings);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConnectedInteriorTester;\n    }\n  });\n\n  ConnectedInteriorTester.findDifferentPoint = function (coord, pt) {\n    for (var i = 0; i < coord.length; i++) {\n      if (!coord[i].equals(pt)) return coord[i];\n    }\n\n    return null;\n  };\n\n  function RelateNodeGraph() {\n    this._nodes = new NodeMap(new RelateNodeFactory());\n  }\n  extend(RelateNodeGraph.prototype, {\n    insertEdgeEnds: function insertEdgeEnds(ee) {\n      for (var i = ee.iterator(); i.hasNext();) {\n        var e = i.next();\n\n        this._nodes.add(e);\n      }\n    },\n    getNodeIterator: function getNodeIterator() {\n      return this._nodes.iterator();\n    },\n    copyNodesAndLabels: function copyNodesAndLabels(geomGraph, argIndex) {\n      for (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {\n        var graphNode = nodeIt.next();\n\n        var newNode = this._nodes.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    },\n    build: function build(geomGraph) {\n      this.computeIntersectionNodes(geomGraph, 0);\n      this.copyNodesAndLabels(geomGraph, 0);\n      var eeBuilder = new EdgeEndBuilder();\n      var eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n      this.insertEdgeEnds(eeList);\n    },\n    computeIntersectionNodes: function computeIntersectionNodes(geomGraph, argIndex) {\n      for (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {\n        var e = edgeIt.next();\n        var eLoc = e.getLabel().getLocation(argIndex);\n\n        for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          var ei = eiIt.next();\n\n          var n = this._nodes.addNode(ei.coord);\n\n          if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {\n            if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n          }\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return RelateNodeGraph;\n    }\n  });\n\n  function ConsistentAreaTester() {\n    this._li = new RobustLineIntersector();\n    this._geomGraph = null;\n    this._nodeGraph = new RelateNodeGraph();\n    this._invalidPoint = null;\n    var geomGraph = arguments[0];\n    this._geomGraph = geomGraph;\n  }\n  extend(ConsistentAreaTester.prototype, {\n    isNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {\n      for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n        var node = nodeIt.next();\n\n        if (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {\n          this._invalidPoint = node.getCoordinate().copy();\n          return false;\n        }\n      }\n\n      return true;\n    },\n    getInvalidPoint: function getInvalidPoint() {\n      return this._invalidPoint;\n    },\n    hasDuplicateRings: function hasDuplicateRings() {\n      for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n        var node = nodeIt.next();\n\n        for (var i = node.getEdges().iterator(); i.hasNext();) {\n          var eeb = i.next();\n\n          if (eeb.getEdgeEnds().size() > 1) {\n            this._invalidPoint = eeb.getEdge().getCoordinate(0);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    isNodeConsistentArea: function isNodeConsistentArea() {\n      var intersector = this._geomGraph.computeSelfNodes(this._li, true, true);\n\n      if (intersector.hasProperIntersection()) {\n        this._invalidPoint = intersector.getProperIntersectionPoint();\n        return false;\n      }\n\n      this._nodeGraph.build(this._geomGraph);\n\n      return this.isNodeEdgeAreaLabelsConsistent();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConsistentAreaTester;\n    }\n  });\n\n  function IndexedNestedRingTester() {\n    this._graph = null;\n    this._rings = new ArrayList();\n    this._totalEnv = new Envelope();\n    this._index = null;\n    this._nestedPt = null;\n    var graph = arguments[0];\n    this._graph = graph;\n  }\n  extend(IndexedNestedRingTester.prototype, {\n    buildIndex: function buildIndex() {\n      this._index = new STRtree();\n\n      for (var i = 0; i < this._rings.size(); i++) {\n        var ring = this._rings.get(i);\n\n        var env = ring.getEnvelopeInternal();\n\n        this._index.insert(env, ring);\n      }\n    },\n    getNestedPoint: function getNestedPoint() {\n      return this._nestedPt;\n    },\n    isNonNested: function isNonNested() {\n      this.buildIndex();\n\n      for (var i = 0; i < this._rings.size(); i++) {\n        var innerRing = this._rings.get(i);\n\n        var innerRingPts = innerRing.getCoordinates();\n\n        var results = this._index.query(innerRing.getEnvelopeInternal());\n\n        for (var j = 0; j < results.size(); j++) {\n          var searchRing = results.get(j);\n          var searchRingPts = searchRing.getCoordinates();\n          if (innerRing === searchRing) continue;\n          if (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n          var innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);\n          if (innerRingPt === null) continue;\n          var isInside = PointLocation.isInRing(innerRingPt, searchRingPts);\n\n          if (isInside) {\n            this._nestedPt = innerRingPt;\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    add: function add(ring) {\n      this._rings.add(ring);\n\n      this._totalEnv.expandToInclude(ring.getEnvelopeInternal());\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IndexedNestedRingTester;\n    }\n  });\n\n  function TopologyValidationError() {\n    this._errorType = null;\n    this._pt = null;\n\n    if (arguments.length === 1) {\n      var errorType = arguments[0];\n      TopologyValidationError.call(this, errorType, null);\n    } else if (arguments.length === 2) {\n      var _errorType = arguments[0],\n          pt = arguments[1];\n      this._errorType = _errorType;\n      if (pt !== null) this._pt = pt.copy();\n    }\n  }\n  extend(TopologyValidationError.prototype, {\n    getErrorType: function getErrorType() {\n      return this._errorType;\n    },\n    getMessage: function getMessage() {\n      return TopologyValidationError.errMsg[this._errorType];\n    },\n    getCoordinate: function getCoordinate() {\n      return this._pt;\n    },\n    toString: function toString() {\n      var locStr = \"\";\n      if (this._pt !== null) locStr = \" at or near point \" + this._pt;\n      return this.getMessage() + locStr;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TopologyValidationError;\n    }\n  });\n  TopologyValidationError.ERROR = 0;\n  TopologyValidationError.REPEATED_POINT = 1;\n  TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\n  TopologyValidationError.NESTED_HOLES = 3;\n  TopologyValidationError.DISCONNECTED_INTERIOR = 4;\n  TopologyValidationError.SELF_INTERSECTION = 5;\n  TopologyValidationError.RING_SELF_INTERSECTION = 6;\n  TopologyValidationError.NESTED_SHELLS = 7;\n  TopologyValidationError.DUPLICATE_RINGS = 8;\n  TopologyValidationError.TOO_FEW_POINTS = 9;\n  TopologyValidationError.INVALID_COORDINATE = 10;\n  TopologyValidationError.RING_NOT_CLOSED = 11;\n  TopologyValidationError.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"];\n\n  function IsValidOp() {\n    this._parentGeometry = null;\n    this._isSelfTouchingRingFormingHoleValid = false;\n    this._validErr = null;\n    var parentGeometry = arguments[0];\n    this._parentGeometry = parentGeometry;\n  }\n  extend(IsValidOp.prototype, {\n    checkInvalidCoordinates: function checkInvalidCoordinates() {\n      if (arguments[0] instanceof Array) {\n        var coords = arguments[0];\n\n        for (var i = 0; i < coords.length; i++) {\n          if (!IsValidOp.isValid(coords[i])) {\n            this._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n            return null;\n          }\n        }\n      } else if (arguments[0] instanceof Polygon) {\n        var poly = arguments[0];\n        this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n        if (this._validErr !== null) return null;\n\n        for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n          this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n          if (this._validErr !== null) return null;\n        }\n      }\n    },\n    checkHolesNotNested: function checkHolesNotNested(p, graph) {\n      var nestedTester = new IndexedNestedRingTester(graph);\n\n      for (var i = 0; i < p.getNumInteriorRing(); i++) {\n        var innerHole = p.getInteriorRingN(i);\n        nestedTester.add(innerHole);\n      }\n\n      var isNonNested = nestedTester.isNonNested();\n\n      if (!isNonNested) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n      }\n    },\n    checkConsistentArea: function checkConsistentArea(graph) {\n      var cat = new ConsistentAreaTester(graph);\n      var isValidArea = cat.isNodeConsistentArea();\n\n      if (!isValidArea) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n        return null;\n      }\n\n      if (cat.hasDuplicateRings()) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n      }\n    },\n    isValid: function isValid() {\n      this.checkValid(this._parentGeometry);\n      return this._validErr === null;\n    },\n    checkShellInsideHole: function checkShellInsideHole(shell, hole, graph) {\n      var shellPts = shell.getCoordinates();\n      var holePts = hole.getCoordinates();\n      var shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n\n      if (shellPt !== null) {\n        var insideHole = PointLocation.isInRing(shellPt, holePts);\n\n        if (!insideHole) {\n          return shellPt;\n        }\n      }\n\n      var holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n\n      if (holePt !== null) {\n        var insideShell = PointLocation.isInRing(holePt, shellPts);\n\n        if (insideShell) {\n          return holePt;\n        }\n\n        return null;\n      }\n\n      Assert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\n      return null;\n    },\n    checkNoSelfIntersectingRings: function checkNoSelfIntersectingRings(graph) {\n      for (var i = graph.getEdgeIterator(); i.hasNext();) {\n        var e = i.next();\n        this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n        if (this._validErr !== null) return null;\n      }\n    },\n    checkConnectedInteriors: function checkConnectedInteriors(graph) {\n      var cit = new ConnectedInteriorTester(graph);\n      if (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n    },\n    checkNoSelfIntersectingRing: function checkNoSelfIntersectingRing(eiList) {\n      var nodeSet = new TreeSet();\n      var isFirst = true;\n\n      for (var i = eiList.iterator(); i.hasNext();) {\n        var ei = i.next();\n\n        if (isFirst) {\n          isFirst = false;\n          continue;\n        }\n\n        if (nodeSet.contains(ei.coord)) {\n          this._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n          return null;\n        } else {\n          nodeSet.add(ei.coord);\n        }\n      }\n    },\n    checkHolesInShell: function checkHolesInShell(p, graph) {\n      var shell = p.getExteriorRing();\n      var pir = new IndexedPointInAreaLocator(shell);\n\n      for (var i = 0; i < p.getNumInteriorRing(); i++) {\n        var hole = p.getInteriorRingN(i);\n        var holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n        if (holePt === null) return null;\n        var outside = Location.EXTERIOR === pir.locate(holePt);\n\n        if (outside) {\n          this._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n          return null;\n        }\n      }\n    },\n    checkTooFewPoints: function checkTooFewPoints(graph) {\n      if (graph.hasTooFewPoints()) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n        return null;\n      }\n    },\n    getValidationError: function getValidationError() {\n      this.checkValid(this._parentGeometry);\n      return this._validErr;\n    },\n    checkValid: function checkValid() {\n      if (arguments[0] instanceof Point) {\n        var _g = arguments[0];\n        this.checkInvalidCoordinates(_g.getCoordinates());\n      } else if (arguments[0] instanceof MultiPoint) {\n        var _g2 = arguments[0];\n        this.checkInvalidCoordinates(_g2.getCoordinates());\n      } else if (arguments[0] instanceof LinearRing) {\n        var _g3 = arguments[0];\n        this.checkInvalidCoordinates(_g3.getCoordinates());\n        if (this._validErr !== null) return null;\n        this.checkClosedRing(_g3);\n        if (this._validErr !== null) return null;\n        var graph = new GeometryGraph(0, _g3);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        var li = new RobustLineIntersector();\n        graph.computeSelfNodes(li, true, true);\n        this.checkNoSelfIntersectingRings(graph);\n      } else if (arguments[0] instanceof LineString) {\n        var _g4 = arguments[0];\n        this.checkInvalidCoordinates(_g4.getCoordinates());\n        if (this._validErr !== null) return null;\n        var graph = new GeometryGraph(0, _g4);\n        this.checkTooFewPoints(graph);\n      } else if (arguments[0] instanceof Polygon) {\n        var _g5 = arguments[0];\n        this.checkInvalidCoordinates(_g5);\n        if (this._validErr !== null) return null;\n        this.checkClosedRings(_g5);\n        if (this._validErr !== null) return null;\n        var graph = new GeometryGraph(0, _g5);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        this.checkConsistentArea(graph);\n        if (this._validErr !== null) return null;\n\n        if (!this._isSelfTouchingRingFormingHoleValid) {\n          this.checkNoSelfIntersectingRings(graph);\n          if (this._validErr !== null) return null;\n        }\n\n        this.checkHolesInShell(_g5, graph);\n        if (this._validErr !== null) return null;\n        this.checkHolesNotNested(_g5, graph);\n        if (this._validErr !== null) return null;\n        this.checkConnectedInteriors(graph);\n      } else if (arguments[0] instanceof MultiPolygon) {\n        var _g6 = arguments[0];\n\n        for (var i = 0; i < _g6.getNumGeometries(); i++) {\n          var p = _g6.getGeometryN(i);\n\n          this.checkInvalidCoordinates(p);\n          if (this._validErr !== null) return null;\n          this.checkClosedRings(p);\n          if (this._validErr !== null) return null;\n        }\n\n        var graph = new GeometryGraph(0, _g6);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        this.checkConsistentArea(graph);\n        if (this._validErr !== null) return null;\n\n        if (!this._isSelfTouchingRingFormingHoleValid) {\n          this.checkNoSelfIntersectingRings(graph);\n          if (this._validErr !== null) return null;\n        }\n\n        for (var i = 0; i < _g6.getNumGeometries(); i++) {\n          var p = _g6.getGeometryN(i);\n\n          this.checkHolesInShell(p, graph);\n          if (this._validErr !== null) return null;\n        }\n\n        for (var i = 0; i < _g6.getNumGeometries(); i++) {\n          var p = _g6.getGeometryN(i);\n\n          this.checkHolesNotNested(p, graph);\n          if (this._validErr !== null) return null;\n        }\n\n        this.checkShellsNotNested(_g6, graph);\n        if (this._validErr !== null) return null;\n        this.checkConnectedInteriors(graph);\n      } else if (arguments[0] instanceof GeometryCollection) {\n        var gc = arguments[0];\n\n        for (var i = 0; i < gc.getNumGeometries(); i++) {\n          var g = gc.getGeometryN(i);\n          this.checkValid(g);\n          if (this._validErr !== null) return null;\n        }\n      } else if (arguments[0] instanceof Geometry) {\n        var _g7 = arguments[0];\n        this._validErr = null;\n        if (_g7.isEmpty()) return null;\n        if (_g7 instanceof Point) this.checkValid(_g7);else if (_g7 instanceof MultiPoint) this.checkValid(_g7);else if (_g7 instanceof LinearRing) this.checkValid(_g7);else if (_g7 instanceof LineString) this.checkValid(_g7);else if (_g7 instanceof Polygon) this.checkValid(_g7);else if (_g7 instanceof MultiPolygon) this.checkValid(_g7);else if (_g7 instanceof GeometryCollection) this.checkValid(_g7);else throw new UnsupportedOperationException(_g7.getClass().getName());\n      }\n    },\n    setSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(isValid) {\n      this._isSelfTouchingRingFormingHoleValid = isValid;\n    },\n    checkShellNotNested: function checkShellNotNested(shell, p, graph) {\n      var shellPts = shell.getCoordinates();\n      var polyShell = p.getExteriorRing();\n      var polyPts = polyShell.getCoordinates();\n      var shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n      if (shellPt === null) return null;\n      var insidePolyShell = PointLocation.isInRing(shellPt, polyPts);\n      if (!insidePolyShell) return null;\n\n      if (p.getNumInteriorRing() <= 0) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n        return null;\n      }\n\n      var badNestedPt = null;\n\n      for (var i = 0; i < p.getNumInteriorRing(); i++) {\n        var hole = p.getInteriorRingN(i);\n        badNestedPt = this.checkShellInsideHole(shell, hole, graph);\n        if (badNestedPt === null) return null;\n      }\n\n      this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n    },\n    checkClosedRings: function checkClosedRings(poly) {\n      this.checkClosedRing(poly.getExteriorRing());\n      if (this._validErr !== null) return null;\n\n      for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n        this.checkClosedRing(poly.getInteriorRingN(i));\n        if (this._validErr !== null) return null;\n      }\n    },\n    checkClosedRing: function checkClosedRing(ring) {\n      if (!ring.isClosed()) {\n        var pt = null;\n        if (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n        this._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n      }\n    },\n    checkShellsNotNested: function checkShellsNotNested(mp, graph) {\n      for (var i = 0; i < mp.getNumGeometries(); i++) {\n        var p = mp.getGeometryN(i);\n        var shell = p.getExteriorRing();\n\n        for (var j = 0; j < mp.getNumGeometries(); j++) {\n          if (i === j) continue;\n          var p2 = mp.getGeometryN(j);\n          this.checkShellNotNested(shell, p2, graph);\n          if (this._validErr !== null) return null;\n        }\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IsValidOp;\n    }\n  });\n\n  IsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {\n    var searchEdge = graph.findEdge(searchRing);\n    var eiList = searchEdge.getEdgeIntersectionList();\n\n    for (var i = 0; i < testCoords.length; i++) {\n      var pt = testCoords[i];\n      if (!eiList.isIntersection(pt)) return pt;\n    }\n\n    return null;\n  };\n\n  IsValidOp.isValid = function () {\n    if (arguments[0] instanceof Geometry) {\n      var geom = arguments[0];\n      var isValidOp = new IsValidOp(geom);\n      return isValidOp.isValid();\n    } else if (arguments[0] instanceof Coordinate) {\n      var coord = arguments[0];\n      if (Double.isNaN(coord.x)) return false;\n      if (Double.isInfinite(coord.x)) return false;\n      if (Double.isNaN(coord.y)) return false;\n      if (Double.isInfinite(coord.y)) return false;\n      return true;\n    }\n  };\n\n\n\n  var valid = /*#__PURE__*/Object.freeze({\n    IsValidOp: IsValidOp,\n    ConsistentAreaTester: ConsistentAreaTester\n  });\n\n\n\n  var operation = /*#__PURE__*/Object.freeze({\n    BoundaryOp: BoundaryOp,\n    IsSimpleOp: IsSimpleOp,\n    buffer: buffer,\n    distance: distance,\n    linemerge: linemerge,\n    overlay: overlay,\n    polygonize: polygonize,\n    relate: relate,\n    union: union,\n    valid: valid\n  });\n\n  function PrecisionReducerCoordinateOperation() {\n    GeometryEditor.CoordinateOperation.apply(this);\n    this._targetPM = null;\n    this._removeCollapsed = true;\n    var targetPM = arguments[0],\n        removeCollapsed = arguments[1];\n    this._targetPM = targetPM;\n    this._removeCollapsed = removeCollapsed;\n  }\n  inherits(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);\n  extend(PrecisionReducerCoordinateOperation.prototype, {\n    edit: function edit() {\n      if (arguments.length === 2 && arguments[1] instanceof Geometry && arguments[0] instanceof Array) {\n        var coordinates = arguments[0],\n            geom = arguments[1];\n        if (coordinates.length === 0) return null;\n        var reducedCoords = new Array(coordinates.length).fill(null);\n\n        for (var i = 0; i < coordinates.length; i++) {\n          var coord = new Coordinate(coordinates[i]);\n\n          this._targetPM.makePrecise(coord);\n\n          reducedCoords[i] = coord;\n        }\n\n        var noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n        var noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n        var minLength = 0;\n        if (geom instanceof LineString) minLength = 2;\n        if (geom instanceof LinearRing) minLength = 4;\n        var collapsedCoords = reducedCoords;\n        if (this._removeCollapsed) collapsedCoords = null;\n\n        if (noRepeatedCoords.length < minLength) {\n          return collapsedCoords;\n        }\n\n        return noRepeatedCoords;\n      } else return GeometryEditor.CoordinateOperation.prototype.edit.apply(this, arguments);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return PrecisionReducerCoordinateOperation;\n    }\n  });\n\n  function GeometryPrecisionReducer() {\n    this._targetPM = null;\n    this._removeCollapsed = true;\n    this._changePrecisionModel = false;\n    this._isPointwise = false;\n    var pm = arguments[0];\n    this._targetPM = pm;\n  }\n  extend(GeometryPrecisionReducer.prototype, {\n    fixPolygonalTopology: function fixPolygonalTopology(geom) {\n      var geomToBuffer = geom;\n\n      if (!this._changePrecisionModel) {\n        geomToBuffer = this.changePM(geom, this._targetPM);\n      }\n\n      var bufGeom = BufferOp.bufferOp(geomToBuffer, 0);\n      var finalGeom = bufGeom;\n\n      if (!this._changePrecisionModel) {\n        finalGeom = bufGeom.copy();\n        this.changePM(finalGeom, geom.getPrecisionModel());\n      }\n\n      return finalGeom;\n    },\n    reducePointwise: function reducePointwise(geom) {\n      var geomEdit = null;\n\n      if (this._changePrecisionModel) {\n        var newFactory = this.createFactory(geom.getFactory(), this._targetPM);\n        geomEdit = new GeometryEditor(newFactory);\n      } else geomEdit = new GeometryEditor();\n\n      var finalRemoveCollapsed = this._removeCollapsed;\n      if (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n      var reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));\n      return reduceGeom;\n    },\n    changePM: function changePM(geom, newPM) {\n      var geomEditor = this.createEditor(geom.getFactory(), newPM);\n      return geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n    },\n    setRemoveCollapsedComponents: function setRemoveCollapsedComponents(removeCollapsed) {\n      this._removeCollapsed = removeCollapsed;\n    },\n    createFactory: function createFactory(inputFactory, pm) {\n      var newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n      return newFactory;\n    },\n    setChangePrecisionModel: function setChangePrecisionModel(changePrecisionModel) {\n      this._changePrecisionModel = changePrecisionModel;\n    },\n    reduce: function reduce(geom) {\n      var reducePW = this.reducePointwise(geom);\n      if (this._isPointwise) return reducePW;\n      if (!hasInterface(reducePW, Polygonal)) return reducePW;\n      if (IsValidOp.isValid(reducePW)) return reducePW;\n      return this.fixPolygonalTopology(reducePW);\n    },\n    setPointwise: function setPointwise(isPointwise) {\n      this._isPointwise = isPointwise;\n    },\n    createEditor: function createEditor(geomFactory, newPM) {\n      if (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n      var newFactory = this.createFactory(geomFactory, newPM);\n      var geomEdit = new GeometryEditor(newFactory);\n      return geomEdit;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return GeometryPrecisionReducer;\n    }\n  });\n\n  GeometryPrecisionReducer.reduce = function (g, precModel) {\n    var reducer = new GeometryPrecisionReducer(precModel);\n    return reducer.reduce(g);\n  };\n\n  GeometryPrecisionReducer.reducePointwise = function (g, precModel) {\n    var reducer = new GeometryPrecisionReducer(precModel);\n    reducer.setPointwise(true);\n    return reducer.reduce(g);\n  };\n\n\n\n  var precision = /*#__PURE__*/Object.freeze({\n    GeometryPrecisionReducer: GeometryPrecisionReducer\n  });\n\n  function DouglasPeuckerLineSimplifier() {\n    this._pts = null;\n    this._usePt = null;\n    this._distanceTolerance = null;\n    this._seg = new LineSegment();\n    var pts = arguments[0];\n    this._pts = pts;\n  }\n  extend(DouglasPeuckerLineSimplifier.prototype, {\n    simplifySection: function simplifySection(i, j) {\n      if (i + 1 === j) {\n        return null;\n      }\n\n      this._seg.p0 = this._pts[i];\n      this._seg.p1 = this._pts[j];\n      var maxDistance = -1.0;\n      var maxIndex = i;\n\n      for (var k = i + 1; k < j; k++) {\n        var distance = this._seg.distance(this._pts[k]);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          maxIndex = k;\n        }\n      }\n\n      if (maxDistance <= this._distanceTolerance) {\n        for (var k = i + 1; k < j; k++) {\n          this._usePt[k] = false;\n        }\n      } else {\n        this.simplifySection(i, maxIndex);\n        this.simplifySection(maxIndex, j);\n      }\n    },\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    },\n    simplify: function simplify() {\n      this._usePt = new Array(this._pts.length).fill(null);\n\n      for (var i = 0; i < this._pts.length; i++) {\n        this._usePt[i] = true;\n      }\n\n      this.simplifySection(0, this._pts.length - 1);\n      var coordList = new CoordinateList();\n\n      for (var i = 0; i < this._pts.length; i++) {\n        if (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));\n      }\n\n      return coordList.toCoordinateArray();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DouglasPeuckerLineSimplifier;\n    }\n  });\n\n  DouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {\n    var simp = new DouglasPeuckerLineSimplifier(pts);\n    simp.setDistanceTolerance(distanceTolerance);\n    return simp.simplify();\n  };\n\n  function DouglasPeuckerSimplifier() {\n    this._inputGeom = null;\n    this._distanceTolerance = null;\n    this._isEnsureValidTopology = true;\n    var inputGeom = arguments[0];\n    this._inputGeom = inputGeom;\n  }\n  extend(DouglasPeuckerSimplifier.prototype, {\n    setEnsureValid: function setEnsureValid(isEnsureValidTopology) {\n      this._isEnsureValidTopology = isEnsureValidTopology;\n    },\n    getResultGeometry: function getResultGeometry() {\n      if (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n      return new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n    },\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n      this._distanceTolerance = distanceTolerance;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DouglasPeuckerSimplifier;\n    }\n  });\n\n  DouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {\n    var tss = new DouglasPeuckerSimplifier(geom);\n    tss.setDistanceTolerance(distanceTolerance);\n    return tss.getResultGeometry();\n  };\n\n  function DPTransformer() {\n    GeometryTransformer.apply(this);\n    this._isEnsureValidTopology = true;\n    this._distanceTolerance = null;\n    var isEnsureValidTopology = arguments[0],\n        distanceTolerance = arguments[1];\n    this._isEnsureValidTopology = isEnsureValidTopology;\n    this._distanceTolerance = distanceTolerance;\n  }\n\n  inherits(DPTransformer, GeometryTransformer);\n  extend(DPTransformer.prototype, {\n    transformPolygon: function transformPolygon(geom, parent) {\n      if (geom.isEmpty()) return null;\n      var rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\n      if (parent instanceof MultiPolygon) {\n        return rawGeom;\n      }\n\n      return this.createValidArea(rawGeom);\n    },\n    createValidArea: function createValidArea(rawAreaGeom) {\n      if (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n      return rawAreaGeom;\n    },\n    transformCoordinates: function transformCoordinates(coords, parent) {\n      var inputPts = coords.toCoordinateArray();\n      var newPts = null;\n\n      if (inputPts.length === 0) {\n        newPts = new Array(0).fill(null);\n      } else {\n        newPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);\n      }\n\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    },\n    transformMultiPolygon: function transformMultiPolygon(geom, parent) {\n      var rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n      return this.createValidArea(rawGeom);\n    },\n    transformLinearRing: function transformLinearRing(geom, parent) {\n      var removeDegenerateRings = parent instanceof Polygon;\n      var simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);\n      if (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n      return simpResult;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DPTransformer;\n    }\n  });\n  DouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n\n  function TaggedLineSegment() {\n    this._parent = null;\n    this._index = null;\n\n    if (arguments.length === 2) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      TaggedLineSegment.call(this, p0, p1, null, -1);\n    } else if (arguments.length === 4) {\n      var _p = arguments[0],\n          _p2 = arguments[1],\n          parent = arguments[2],\n          index = arguments[3];\n      LineSegment.call(this, _p, _p2);\n      this._parent = parent;\n      this._index = index;\n    }\n  }\n  inherits(TaggedLineSegment, LineSegment);\n  extend(TaggedLineSegment.prototype, {\n    getIndex: function getIndex() {\n      return this._index;\n    },\n    getParent: function getParent() {\n      return this._parent;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TaggedLineSegment;\n    }\n  });\n\n  function TaggedLineString() {\n    this._parentLine = null;\n    this._segs = null;\n    this._resultSegs = new ArrayList();\n    this._minimumSize = null;\n\n    if (arguments.length === 1) {\n      var parentLine = arguments[0];\n      TaggedLineString.call(this, parentLine, 2);\n    } else if (arguments.length === 2) {\n      var _parentLine = arguments[0],\n          minimumSize = arguments[1];\n      this._parentLine = _parentLine;\n      this._minimumSize = minimumSize;\n      this.init();\n    }\n  }\n  extend(TaggedLineString.prototype, {\n    addToResult: function addToResult(seg) {\n      this._resultSegs.add(seg);\n    },\n    asLineString: function asLineString() {\n      return this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));\n    },\n    getResultSize: function getResultSize() {\n      var resultSegsSize = this._resultSegs.size();\n\n      return resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n    },\n    getParent: function getParent() {\n      return this._parentLine;\n    },\n    getSegment: function getSegment(i) {\n      return this._segs[i];\n    },\n    getParentCoordinates: function getParentCoordinates() {\n      return this._parentLine.getCoordinates();\n    },\n    getMinimumSize: function getMinimumSize() {\n      return this._minimumSize;\n    },\n    asLinearRing: function asLinearRing() {\n      return this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));\n    },\n    getSegments: function getSegments() {\n      return this._segs;\n    },\n    init: function init() {\n      var pts = this._parentLine.getCoordinates();\n\n      this._segs = new Array(pts.length - 1).fill(null);\n\n      for (var i = 0; i < pts.length - 1; i++) {\n        var seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);\n        this._segs[i] = seg;\n      }\n    },\n    getResultCoordinates: function getResultCoordinates() {\n      return TaggedLineString.extractCoordinates(this._resultSegs);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TaggedLineString;\n    }\n  });\n\n  TaggedLineString.extractCoordinates = function (segs) {\n    var pts = new Array(segs.size() + 1).fill(null);\n    var seg = null;\n\n    for (var i = 0; i < segs.size(); i++) {\n      seg = segs.get(i);\n      pts[i] = seg.p0;\n    }\n\n    pts[pts.length - 1] = seg.p1;\n    return pts;\n  };\n\n  function LineSegmentIndex() {\n    this._index = new Quadtree();\n  }\n  extend(LineSegmentIndex.prototype, {\n    remove: function remove(seg) {\n      this._index.remove(new Envelope(seg.p0, seg.p1), seg);\n    },\n    add: function add() {\n      if (arguments[0] instanceof TaggedLineString) {\n        var line = arguments[0];\n        var segs = line.getSegments();\n\n        for (var i = 0; i < segs.length; i++) {\n          var seg = segs[i];\n          this.add(seg);\n        }\n      } else if (arguments[0] instanceof LineSegment) {\n        var _seg = arguments[0];\n\n        this._index.insert(new Envelope(_seg.p0, _seg.p1), _seg);\n      }\n    },\n    query: function query(querySeg) {\n      var env = new Envelope(querySeg.p0, querySeg.p1);\n      var visitor = new LineSegmentVisitor(querySeg);\n\n      this._index.query(env, visitor);\n\n      var itemsFound = visitor.getItems();\n      return itemsFound;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineSegmentIndex;\n    }\n  });\n\n  function LineSegmentVisitor() {\n    this._querySeg = null;\n    this._items = new ArrayList();\n    var querySeg = arguments[0];\n    this._querySeg = querySeg;\n  }\n\n  extend(LineSegmentVisitor.prototype, {\n    visitItem: function visitItem(item) {\n      var seg = item;\n      if (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);\n    },\n    getItems: function getItems() {\n      return this._items;\n    },\n    interfaces_: function interfaces_() {\n      return [ItemVisitor];\n    },\n    getClass: function getClass() {\n      return LineSegmentVisitor;\n    }\n  });\n\n  function TaggedLineStringSimplifier() {\n    this._li = new RobustLineIntersector();\n    this._inputIndex = new LineSegmentIndex();\n    this._outputIndex = new LineSegmentIndex();\n    this._line = null;\n    this._linePts = null;\n    this._distanceTolerance = 0.0;\n    var inputIndex = arguments[0],\n        outputIndex = arguments[1];\n    this._inputIndex = inputIndex;\n    this._outputIndex = outputIndex;\n  }\n  extend(TaggedLineStringSimplifier.prototype, {\n    flatten: function flatten(start, end) {\n      var p0 = this._linePts[start];\n      var p1 = this._linePts[end];\n      var newSeg = new LineSegment(p0, p1);\n      this.remove(this._line, start, end);\n\n      this._outputIndex.add(newSeg);\n\n      return newSeg;\n    },\n    hasBadIntersection: function hasBadIntersection(parentLine, sectionIndex, candidateSeg) {\n      if (this.hasBadOutputIntersection(candidateSeg)) return true;\n      if (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n      return false;\n    },\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    },\n    simplifySection: function simplifySection(i, j, depth) {\n      depth += 1;\n      var sectionIndex = new Array(2).fill(null);\n\n      if (i + 1 === j) {\n        var newSeg = this._line.getSegment(i);\n\n        this._line.addToResult(newSeg);\n\n        return null;\n      }\n\n      var isValidToSimplify = true;\n\n      if (this._line.getResultSize() < this._line.getMinimumSize()) {\n        var worstCaseSize = depth + 1;\n        if (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;\n      }\n\n      var distance = new Array(1).fill(null);\n      var furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);\n      if (distance[0] > this._distanceTolerance) isValidToSimplify = false;\n      var candidateSeg = new LineSegment();\n      candidateSeg.p0 = this._linePts[i];\n      candidateSeg.p1 = this._linePts[j];\n      sectionIndex[0] = i;\n      sectionIndex[1] = j;\n      if (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n\n      if (isValidToSimplify) {\n        var newSeg = this.flatten(i, j);\n\n        this._line.addToResult(newSeg);\n\n        return null;\n      }\n\n      this.simplifySection(i, furthestPtIndex, depth);\n      this.simplifySection(furthestPtIndex, j, depth);\n    },\n    hasBadOutputIntersection: function hasBadOutputIntersection(candidateSeg) {\n      var querySegs = this._outputIndex.query(candidateSeg);\n\n      for (var i = querySegs.iterator(); i.hasNext();) {\n        var querySeg = i.next();\n\n        if (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    findFurthestPoint: function findFurthestPoint(pts, i, j, maxDistance) {\n      var seg = new LineSegment();\n      seg.p0 = pts[i];\n      seg.p1 = pts[j];\n      var maxDist = -1.0;\n      var maxIndex = i;\n\n      for (var k = i + 1; k < j; k++) {\n        var midPt = pts[k];\n        var distance = seg.distance(midPt);\n\n        if (distance > maxDist) {\n          maxDist = distance;\n          maxIndex = k;\n        }\n      }\n\n      maxDistance[0] = maxDist;\n      return maxIndex;\n    },\n    simplify: function simplify(line) {\n      this._line = line;\n      this._linePts = line.getParentCoordinates();\n      this.simplifySection(0, this._linePts.length - 1, 0);\n    },\n    remove: function remove(line, start, end) {\n      for (var i = start; i < end; i++) {\n        var seg = line.getSegment(i);\n\n        this._inputIndex.remove(seg);\n      }\n    },\n    hasInteriorIntersection: function hasInteriorIntersection(seg0, seg1) {\n      this._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n\n      return this._li.isInteriorIntersection();\n    },\n    hasBadInputIntersection: function hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {\n      var querySegs = this._inputIndex.query(candidateSeg);\n\n      for (var i = querySegs.iterator(); i.hasNext();) {\n        var querySeg = i.next();\n\n        if (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n          if (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n          return true;\n        }\n      }\n\n      return false;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TaggedLineStringSimplifier;\n    }\n  });\n\n  TaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {\n    if (seg.getParent() !== line.getParent()) return false;\n    var segIndex = seg.getIndex();\n    if (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n    return false;\n  };\n\n  function TaggedLinesSimplifier() {\n    this._inputIndex = new LineSegmentIndex();\n    this._outputIndex = new LineSegmentIndex();\n    this._distanceTolerance = 0.0;\n  }\n  extend(TaggedLinesSimplifier.prototype, {\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    },\n    simplify: function simplify(taggedLines) {\n      for (var i = taggedLines.iterator(); i.hasNext();) {\n        this._inputIndex.add(i.next());\n      }\n\n      for (var i = taggedLines.iterator(); i.hasNext();) {\n        var tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);\n        tlss.setDistanceTolerance(this._distanceTolerance);\n        tlss.simplify(i.next());\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TaggedLinesSimplifier;\n    }\n  });\n\n  function TopologyPreservingSimplifier() {\n    this._inputGeom = null;\n    this._lineSimplifier = new TaggedLinesSimplifier();\n    this._linestringMap = null;\n    var inputGeom = arguments[0];\n    this._inputGeom = inputGeom;\n  }\n  extend(TopologyPreservingSimplifier.prototype, {\n    getResultGeometry: function getResultGeometry() {\n      if (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n      this._linestringMap = new HashMap();\n\n      this._inputGeom.apply(new LineStringMapBuilderFilter(this));\n\n      this._lineSimplifier.simplify(this._linestringMap.values());\n\n      var result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);\n      return result;\n    },\n    setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n\n      this._lineSimplifier.setDistanceTolerance(distanceTolerance);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TopologyPreservingSimplifier;\n    }\n  });\n\n  TopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {\n    var tss = new TopologyPreservingSimplifier(geom);\n    tss.setDistanceTolerance(distanceTolerance);\n    return tss.getResultGeometry();\n  };\n\n  function LineStringTransformer() {\n    GeometryTransformer.apply(this);\n    this._linestringMap = null;\n    var linestringMap = arguments[0];\n    this._linestringMap = linestringMap;\n  }\n\n  inherits(LineStringTransformer, GeometryTransformer);\n  extend(LineStringTransformer.prototype, {\n    transformCoordinates: function transformCoordinates(coords, parent) {\n      if (coords.size() === 0) return null;\n\n      if (parent instanceof LineString) {\n        var taggedLine = this._linestringMap.get(parent);\n\n        return this.createCoordinateSequence(taggedLine.getResultCoordinates());\n      }\n\n      return GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LineStringTransformer;\n    }\n  });\n\n  function LineStringMapBuilderFilter() {\n    this.tps = null;\n    var tps = arguments[0];\n    this.tps = tps;\n  }\n\n  extend(LineStringMapBuilderFilter.prototype, {\n    filter: function filter(geom) {\n      if (geom instanceof LineString) {\n        var line = geom;\n        if (line.isEmpty()) return null;\n        var minSize = line.isClosed() ? 4 : 2;\n        var taggedLine = new TaggedLineString(line, minSize);\n\n        this.tps._linestringMap.put(line, taggedLine);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [GeometryComponentFilter];\n    },\n    getClass: function getClass() {\n      return LineStringMapBuilderFilter;\n    }\n  });\n  TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\n  TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n\n\n\n  var simplify = /*#__PURE__*/Object.freeze({\n    DouglasPeuckerSimplifier: DouglasPeuckerSimplifier,\n    TopologyPreservingSimplifier: TopologyPreservingSimplifier\n  });\n\n  function SplitSegment() {\n    this._seg = null;\n    this._segLen = null;\n    this._splitPt = null;\n    this._minimumLen = 0.0;\n    var seg = arguments[0];\n    this._seg = seg;\n    this._segLen = seg.getLength();\n  }\n  extend(SplitSegment.prototype, {\n    splitAt: function splitAt() {\n      if (arguments.length === 1) {\n        var pt = arguments[0];\n        var minFrac = this._minimumLen / this._segLen;\n\n        if (pt.distance(this._seg.p0) < this._minimumLen) {\n          this._splitPt = this._seg.pointAlong(minFrac);\n          return null;\n        }\n\n        if (pt.distance(this._seg.p1) < this._minimumLen) {\n          this._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);\n          return null;\n        }\n\n        this._splitPt = pt;\n      } else if (arguments.length === 2) {\n        var length = arguments[0],\n            endPt = arguments[1];\n        var actualLen = this.getConstrainedLength(length);\n        var frac = actualLen / this._segLen;\n        if (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);\n      }\n    },\n    setMinimumLength: function setMinimumLength(minLen) {\n      this._minimumLen = minLen;\n    },\n    getConstrainedLength: function getConstrainedLength(len) {\n      if (len < this._minimumLen) return this._minimumLen;\n      return len;\n    },\n    getSplitPoint: function getSplitPoint() {\n      return this._splitPt;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return SplitSegment;\n    }\n  });\n\n  SplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {\n    var coord = new Coordinate();\n    coord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n    coord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n    return coord;\n  };\n\n  function ConstraintSplitPointFinder() {}\n  extend(ConstraintSplitPointFinder.prototype, {\n    findSplitPoint: function findSplitPoint(seg, encroachPt) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConstraintSplitPointFinder;\n    }\n  });\n\n  function NonEncroachingSplitPointFinder() {}\n  extend(NonEncroachingSplitPointFinder.prototype, {\n    findSplitPoint: function findSplitPoint(seg, encroachPt) {\n      var lineSeg = seg.getLineSegment();\n      var segLen = lineSeg.getLength();\n      var midPtLen = segLen / 2;\n      var splitSeg = new SplitSegment(lineSeg);\n      var projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n      var nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n      var maxSplitLen = nonEncroachDiam;\n\n      if (maxSplitLen > midPtLen) {\n        maxSplitLen = midPtLen;\n      }\n\n      splitSeg.setMinimumLength(maxSplitLen);\n      splitSeg.splitAt(projPt);\n      return splitSeg.getSplitPoint();\n    },\n    interfaces_: function interfaces_() {\n      return [ConstraintSplitPointFinder];\n    },\n    getClass: function getClass() {\n      return NonEncroachingSplitPointFinder;\n    }\n  });\n\n  NonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {\n    var lineSeg = seg.getLineSegment();\n    var projPt = lineSeg.project(encroachPt);\n    return projPt;\n  };\n\n  function TrianglePredicate() {}\n  extend(TrianglePredicate.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TrianglePredicate;\n    }\n  });\n\n  TrianglePredicate.triArea = function (a, b, c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n  };\n\n  TrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {\n    var adx = DD.valueOf(a.x).selfSubtract(p.x);\n    var ady = DD.valueOf(a.y).selfSubtract(p.y);\n    var bdx = DD.valueOf(b.x).selfSubtract(p.x);\n    var bdy = DD.valueOf(b.y).selfSubtract(p.y);\n    var cdx = DD.valueOf(c.x).selfSubtract(p.x);\n    var cdy = DD.valueOf(c.y).selfSubtract(p.y);\n    var abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n    var bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n    var cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n    var alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n    var blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n    var clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n    var sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n    var isInCircle = sum.doubleValue() > 0;\n    return isInCircle;\n  };\n\n  TrianglePredicate.checkRobustInCircle = function (a, b, c, p) {\n    var nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n    var isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n    var isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n    var circumCentre = Triangle.circumcentre(a, b, c);\n    System.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n\n    if (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n      System.out.println(\"inCircle robustness failure (double result = \" + nonRobustInCircle + \", DD result = \" + isInCircleDD + \", CC result = \" + isInCircleCC + \")\");\n      System.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n      System.out.println(\"Circumcentre = \" + WKTWriter.toPoint(circumCentre) + \" radius = \" + a.distance(circumCentre));\n      System.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n      System.out.println(\"p radius diff b = \" + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n      System.out.println(\"p radius diff c = \" + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n      System.out.println();\n    }\n  };\n\n  TrianglePredicate.isInCircleDDFast = function (a, b, c, p) {\n    var aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n    var bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n    var cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n    var pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n    var sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n    var isInCircle = sum.doubleValue() > 0;\n    return isInCircle;\n  };\n\n  TrianglePredicate.isInCircleCC = function (a, b, c, p) {\n    var cc = Triangle.circumcentre(a, b, c);\n    var ccRadius = a.distance(cc);\n    var pRadiusDiff = p.distance(cc) - ccRadius;\n    return pRadiusDiff <= 0;\n  };\n\n  TrianglePredicate.isInCircleNormalized = function (a, b, c, p) {\n    var adx = a.x - p.x;\n    var ady = a.y - p.y;\n    var bdx = b.x - p.x;\n    var bdy = b.y - p.y;\n    var cdx = c.x - p.x;\n    var cdy = c.y - p.y;\n    var abdet = adx * bdy - bdx * ady;\n    var bcdet = bdx * cdy - cdx * bdy;\n    var cadet = cdx * ady - adx * cdy;\n    var alift = adx * adx + ady * ady;\n    var blift = bdx * bdx + bdy * bdy;\n    var clift = cdx * cdx + cdy * cdy;\n    var disc = alift * bcdet + blift * cadet + clift * abdet;\n    return disc > 0;\n  };\n\n  TrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {\n    var px = DD.valueOf(p.x);\n    var py = DD.valueOf(p.y);\n    var ax = DD.valueOf(a.x);\n    var ay = DD.valueOf(a.y);\n    var bx = DD.valueOf(b.x);\n    var by = DD.valueOf(b.y);\n    var cx = DD.valueOf(c.x);\n    var cy = DD.valueOf(c.y);\n    var aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n    var bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n    var cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n    var pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n    var sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n    var isInCircle = sum.doubleValue() > 0;\n    return isInCircle;\n  };\n\n  TrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {\n    var isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n    return isInCircle;\n  };\n\n  TrianglePredicate.isInCircleRobust = function (a, b, c, p) {\n    return TrianglePredicate.isInCircleNormalized(a, b, c, p);\n  };\n\n  TrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {\n    return bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n  };\n\n  TrianglePredicate.triAreaDDFast = function (a, b, c) {\n    var t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n    var t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n    return t1.selfSubtract(t2);\n  };\n\n  function Vertex() {\n    this._p = null;\n\n    if (arguments.length === 1) {\n      var _p = arguments[0];\n      this._p = new Coordinate(_p);\n    } else if (arguments.length === 2) {\n      var _x = arguments[0],\n          _y = arguments[1];\n      this._p = new Coordinate(_x, _y);\n    } else if (arguments.length === 3) {\n      var _x2 = arguments[0],\n          _y2 = arguments[1],\n          _z = arguments[2];\n      this._p = new Coordinate(_x2, _y2, _z);\n    }\n  }\n  extend(Vertex.prototype, {\n    circleCenter: function circleCenter(b, c) {\n      var a = new Vertex(this.getX(), this.getY());\n      var cab = this.bisector(a, b);\n      var cbc = this.bisector(b, c);\n      var hcc = new HCoordinate(cab, cbc);\n      var cc = null;\n\n      try {\n        cc = new Vertex(hcc.getX(), hcc.getY());\n      } catch (nre) {\n        if (nre instanceof NotRepresentableException) {\n          System.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\n          System.err.println(nre);\n        } else throw nre;\n      } finally {}\n\n      return cc;\n    },\n    dot: function dot(v) {\n      return this._p.x * v.getX() + this._p.y * v.getY();\n    },\n    magn: function magn() {\n      return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);\n    },\n    getZ: function getZ() {\n      return this._p.z;\n    },\n    bisector: function bisector(a, b) {\n      var dx = b.getX() - a.getX();\n      var dy = b.getY() - a.getY();\n      var l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n      var l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n      return new HCoordinate(l1, l2);\n    },\n    equals: function equals() {\n      if (arguments.length === 1) {\n        var _x = arguments[0];\n\n        if (this._p.x === _x.getX() && this._p.y === _x.getY()) {\n          return true;\n        } else {\n          return false;\n        }\n      } else if (arguments.length === 2) {\n        var _x3 = arguments[0],\n            tolerance = arguments[1];\n\n        if (this._p.distance(_x3.getCoordinate()) < tolerance) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    },\n    getCoordinate: function getCoordinate() {\n      return this._p;\n    },\n    isInCircle: function isInCircle(a, b, c) {\n      return TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);\n    },\n    interpolateZValue: function interpolateZValue(v0, v1, v2) {\n      var x0 = v0.getX();\n      var y0 = v0.getY();\n      var a = v1.getX() - x0;\n      var b = v2.getX() - x0;\n      var c = v1.getY() - y0;\n      var d = v2.getY() - y0;\n      var det = a * d - b * c;\n      var dx = this.getX() - x0;\n      var dy = this.getY() - y0;\n      var t = (d * dx - b * dy) / det;\n      var u = (-c * dx + a * dy) / det;\n      var z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n      return z;\n    },\n    midPoint: function midPoint(a) {\n      var xm = (this._p.x + a.getX()) / 2.0;\n      var ym = (this._p.y + a.getY()) / 2.0;\n      var zm = (this._p.z + a.getZ()) / 2.0;\n      return new Vertex(xm, ym, zm);\n    },\n    rightOf: function rightOf(e) {\n      return this.isCCW(e.dest(), e.orig());\n    },\n    isCCW: function isCCW(b, c) {\n      return (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;\n    },\n    getX: function getX() {\n      return this._p.x;\n    },\n    crossProduct: function crossProduct(v) {\n      return this._p.x * v.getY() - this._p.y * v.getX();\n    },\n    setZ: function setZ(_z) {\n      this._p.z = _z;\n    },\n    times: function times(c) {\n      return new Vertex(c * this._p.x, c * this._p.y);\n    },\n    cross: function cross() {\n      return new Vertex(this._p.y, -this._p.x);\n    },\n    leftOf: function leftOf(e) {\n      return this.isCCW(e.orig(), e.dest());\n    },\n    toString: function toString() {\n      return \"POINT (\" + this._p.x + \" \" + this._p.y + \")\";\n    },\n    sub: function sub(v) {\n      return new Vertex(this._p.x - v.getX(), this._p.y - v.getY());\n    },\n    getY: function getY() {\n      return this._p.y;\n    },\n    classify: function classify(p0, p1) {\n      var p2 = this;\n      var a = p1.sub(p0);\n      var b = p2.sub(p0);\n      var sa = a.crossProduct(b);\n      if (sa > 0.0) return Vertex.LEFT;\n      if (sa < 0.0) return Vertex.RIGHT;\n      if (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n      if (a.magn() < b.magn()) return Vertex.BEYOND;\n      if (p0.equals(p2)) return Vertex.ORIGIN;\n      if (p1.equals(p2)) return Vertex.DESTINATION;\n      return Vertex.BETWEEN;\n    },\n    sum: function sum(v) {\n      return new Vertex(this._p.x + v.getX(), this._p.y + v.getY());\n    },\n    distance: function distance(v1, v2) {\n      return Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n    },\n    circumRadiusRatio: function circumRadiusRatio(b, c) {\n      var x = this.circleCenter(b, c);\n      var radius = this.distance(x, b);\n      var edgeLength = this.distance(this, b);\n      var el = this.distance(b, c);\n\n      if (el < edgeLength) {\n        edgeLength = el;\n      }\n\n      el = this.distance(c, this);\n\n      if (el < edgeLength) {\n        edgeLength = el;\n      }\n\n      return radius / edgeLength;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Vertex;\n    }\n  });\n\n  Vertex.interpolateZ = function () {\n    if (arguments.length === 3) {\n      var p = arguments[0],\n          p0 = arguments[1],\n          p1 = arguments[2];\n      var segLen = p0.distance(p1);\n      var ptLen = p.distance(p0);\n      var dz = p1.z - p0.z;\n      var pz = p0.z + dz * (ptLen / segLen);\n      return pz;\n    } else if (arguments.length === 4) {\n      var _p2 = arguments[0],\n          v0 = arguments[1],\n          v1 = arguments[2],\n          v2 = arguments[3];\n      var x0 = v0.x;\n      var y0 = v0.y;\n      var a = v1.x - x0;\n      var b = v2.x - x0;\n      var c = v1.y - y0;\n      var d = v2.y - y0;\n      var det = a * d - b * c;\n      var dx = _p2.x - x0;\n      var dy = _p2.y - y0;\n      var t = (d * dx - b * dy) / det;\n      var u = (-c * dx + a * dy) / det;\n      var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n      return z;\n    }\n  };\n\n  Vertex.LEFT = 0;\n  Vertex.RIGHT = 1;\n  Vertex.BEYOND = 2;\n  Vertex.BEHIND = 3;\n  Vertex.BETWEEN = 4;\n  Vertex.ORIGIN = 5;\n  Vertex.DESTINATION = 6;\n\n  function ConstraintVertex() {\n    this._isOnConstraint = null;\n    this._constraint = null;\n    var p = arguments[0];\n    Vertex.call(this, p);\n  }\n  inherits(ConstraintVertex, Vertex);\n  extend(ConstraintVertex.prototype, {\n    getConstraint: function getConstraint() {\n      return this._constraint;\n    },\n    setOnConstraint: function setOnConstraint(isOnConstraint) {\n      this._isOnConstraint = isOnConstraint;\n    },\n    merge: function merge(other) {\n      if (other._isOnConstraint) {\n        this._isOnConstraint = true;\n        this._constraint = other._constraint;\n      }\n    },\n    isOnConstraint: function isOnConstraint() {\n      return this._isOnConstraint;\n    },\n    setConstraint: function setConstraint(constraint) {\n      this._isOnConstraint = true;\n      this._constraint = constraint;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConstraintVertex;\n    }\n  });\n\n  function QuadEdge() {\n    this._rot = null;\n    this._vertex = null;\n    this._next = null;\n    this._data = null;\n  }\n  extend(QuadEdge.prototype, {\n    equalsNonOriented: function equalsNonOriented(qe) {\n      if (this.equalsOriented(qe)) return true;\n      if (this.equalsOriented(qe.sym())) return true;\n      return false;\n    },\n    toLineSegment: function toLineSegment() {\n      return new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());\n    },\n    dest: function dest() {\n      return this.sym().orig();\n    },\n    oNext: function oNext() {\n      return this._next;\n    },\n    equalsOriented: function equalsOriented(qe) {\n      if (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n      return false;\n    },\n    dNext: function dNext() {\n      return this.sym().oNext().sym();\n    },\n    lPrev: function lPrev() {\n      return this._next.sym();\n    },\n    rPrev: function rPrev() {\n      return this.sym().oNext();\n    },\n    rot: function rot() {\n      return this._rot;\n    },\n    oPrev: function oPrev() {\n      return this._rot._next._rot;\n    },\n    sym: function sym() {\n      return this._rot._rot;\n    },\n    setOrig: function setOrig(o) {\n      this._vertex = o;\n    },\n    lNext: function lNext() {\n      return this.invRot().oNext().rot();\n    },\n    getLength: function getLength() {\n      return this.orig().getCoordinate().distance(this.dest().getCoordinate());\n    },\n    invRot: function invRot() {\n      return this._rot.sym();\n    },\n    setDest: function setDest(d) {\n      this.sym().setOrig(d);\n    },\n    setData: function setData(data) {\n      this._data = data;\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    delete: function _delete() {\n      this._rot = null;\n    },\n    orig: function orig() {\n      return this._vertex;\n    },\n    rNext: function rNext() {\n      return this._rot._next.invRot();\n    },\n    toString: function toString() {\n      var p0 = this._vertex.getCoordinate();\n\n      var p1 = this.dest().getCoordinate();\n      return WKTWriter.toLineString(p0, p1);\n    },\n    isLive: function isLive() {\n      return this._rot !== null;\n    },\n    getPrimary: function getPrimary() {\n      if (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();\n    },\n    dPrev: function dPrev() {\n      return this.invRot().oNext().invRot();\n    },\n    setNext: function setNext(next) {\n      this._next = next;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return QuadEdge;\n    }\n  });\n\n  QuadEdge.makeEdge = function (o, d) {\n    var q0 = new QuadEdge();\n    var q1 = new QuadEdge();\n    var q2 = new QuadEdge();\n    var q3 = new QuadEdge();\n    q0._rot = q1;\n    q1._rot = q2;\n    q2._rot = q3;\n    q3._rot = q0;\n    q0.setNext(q0);\n    q1.setNext(q3);\n    q2.setNext(q2);\n    q3.setNext(q1);\n    var base = q0;\n    base.setOrig(o);\n    base.setDest(d);\n    return base;\n  };\n\n  QuadEdge.swap = function (e) {\n    var a = e.oPrev();\n    var b = e.sym().oPrev();\n    QuadEdge.splice(e, a);\n    QuadEdge.splice(e.sym(), b);\n    QuadEdge.splice(e, a.lNext());\n    QuadEdge.splice(e.sym(), b.lNext());\n    e.setOrig(a.dest());\n    e.setDest(b.dest());\n  };\n\n  QuadEdge.splice = function (a, b) {\n    var alpha = a.oNext().rot();\n    var beta = b.oNext().rot();\n    var t1 = b.oNext();\n    var t2 = a.oNext();\n    var t3 = beta.oNext();\n    var t4 = alpha.oNext();\n    a.setNext(t1);\n    b.setNext(t2);\n    alpha.setNext(t3);\n    beta.setNext(t4);\n  };\n\n  QuadEdge.connect = function (a, b) {\n    var e = QuadEdge.makeEdge(a.dest(), b.orig());\n    QuadEdge.splice(e, a.lNext());\n    QuadEdge.splice(e.sym(), b);\n    return e;\n  };\n\n  function IncrementalDelaunayTriangulator() {\n    this._subdiv = null;\n    this._isUsingTolerance = false;\n    var subdiv = arguments[0];\n    this._subdiv = subdiv;\n    this._isUsingTolerance = subdiv.getTolerance() > 0.0;\n  }\n  extend(IncrementalDelaunayTriangulator.prototype, {\n    insertSite: function insertSite(v) {\n      var e = this._subdiv.locate(v);\n\n      if (this._subdiv.isVertexOfEdge(e, v)) {\n        return e;\n      } else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {\n        e = e.oPrev();\n\n        this._subdiv.delete(e.oNext());\n      }\n\n      var base = this._subdiv.makeEdge(e.orig(), v);\n\n      QuadEdge.splice(base, e);\n      var startEdge = base;\n\n      do {\n        base = this._subdiv.connect(e, base.sym());\n        e = base.oPrev();\n      } while (e.lNext() !== startEdge);\n\n      do {\n        var t = e.oPrev();\n\n        if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n          QuadEdge.swap(e);\n          e = e.oPrev();\n        } else if (e.oNext() === startEdge) {\n          return base;\n        } else {\n          e = e.oNext().lPrev();\n        }\n      } while (true);\n    },\n    insertSites: function insertSites(vertices) {\n      for (var i = vertices.iterator(); i.hasNext();) {\n        var v = i.next();\n        this.insertSite(v);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return IncrementalDelaunayTriangulator;\n    }\n  });\n\n  function QuadEdgeLocator() {}\n  extend(QuadEdgeLocator.prototype, {\n    locate: function locate(v) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return QuadEdgeLocator;\n    }\n  });\n\n  function LastFoundQuadEdgeLocator() {\n    this._subdiv = null;\n    this._lastEdge = null;\n    var subdiv = arguments[0];\n    this._subdiv = subdiv;\n    this.init();\n  }\n  extend(LastFoundQuadEdgeLocator.prototype, {\n    init: function init() {\n      this._lastEdge = this.findEdge();\n    },\n    locate: function locate(v) {\n      if (!this._lastEdge.isLive()) {\n        this.init();\n      }\n\n      var e = this._subdiv.locateFromEdge(v, this._lastEdge);\n\n      this._lastEdge = e;\n      return e;\n    },\n    findEdge: function findEdge() {\n      var edges = this._subdiv.getEdges();\n\n      return edges.iterator().next();\n    },\n    interfaces_: function interfaces_() {\n      return [QuadEdgeLocator];\n    },\n    getClass: function getClass() {\n      return LastFoundQuadEdgeLocator;\n    }\n  });\n\n  function LocateFailureException() {\n    this._seg = null;\n\n    if (arguments.length === 1) {\n      if (typeof arguments[0] === \"string\") {\n        var msg = arguments[0];\n        RuntimeException.call(this, msg);\n      } else if (arguments[0] instanceof LineSegment) {\n        var seg = arguments[0];\n        RuntimeException.call(this, \"Locate failed to converge (at edge: \" + seg + \").  Possible causes include invalid Subdivision topology or very close sites\");\n        this._seg = new LineSegment(seg);\n      }\n    } else if (arguments.length === 2) {\n      var _msg = arguments[0],\n          _seg = arguments[1];\n      RuntimeException.call(this, LocateFailureException.msgWithSpatial(_msg, _seg));\n      this._seg = new LineSegment(_seg);\n    }\n  }\n  inherits(LocateFailureException, RuntimeException);\n  extend(LocateFailureException.prototype, {\n    getSegment: function getSegment() {\n      return this._seg;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LocateFailureException;\n    }\n  });\n\n  LocateFailureException.msgWithSpatial = function (msg, seg) {\n    if (seg !== null) return msg + \" [ \" + seg + \" ]\";\n    return msg;\n  };\n\n  function TriangleVisitor() {}\n  extend(TriangleVisitor.prototype, {\n    visit: function visit(triEdges) {},\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return TriangleVisitor;\n    }\n  });\n\n  function QuadEdgeSubdivision() {\n    this._visitedKey = 0;\n    this._quadEdges = new ArrayList();\n    this._startingEdge = null;\n    this._tolerance = null;\n    this._edgeCoincidenceTolerance = null;\n    this._frameVertex = new Array(3).fill(null);\n    this._frameEnv = null;\n    this._locator = null;\n    this._seg = new LineSegment();\n    this._triEdges = new Array(3).fill(null);\n    var env = arguments[0],\n        tolerance = arguments[1];\n    this._tolerance = tolerance;\n    this._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n    this.createFrame(env);\n    this._startingEdge = this.initSubdiv();\n    this._locator = new LastFoundQuadEdgeLocator(this);\n  }\n  extend(QuadEdgeSubdivision.prototype, {\n    getTriangleVertices: function getTriangleVertices(includeFrame) {\n      var visitor = new TriangleVertexListVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangleVertices();\n    },\n    isFrameVertex: function isFrameVertex(v) {\n      if (v.equals(this._frameVertex[0])) return true;\n      if (v.equals(this._frameVertex[1])) return true;\n      if (v.equals(this._frameVertex[2])) return true;\n      return false;\n    },\n    isVertexOfEdge: function isVertexOfEdge(e, v) {\n      if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n        return true;\n      }\n\n      return false;\n    },\n    connect: function connect(a, b) {\n      var q = QuadEdge.connect(a, b);\n\n      this._quadEdges.add(q);\n\n      return q;\n    },\n    getVoronoiCellPolygon: function getVoronoiCellPolygon(qe, geomFact) {\n      var cellPts = new ArrayList();\n      var startQE = qe;\n\n      do {\n        var cc = qe.rot().orig().getCoordinate();\n        cellPts.add(cc);\n        qe = qe.oPrev();\n      } while (qe !== startQE);\n\n      var coordList = new CoordinateList();\n      coordList.addAll(cellPts, false);\n      coordList.closeRing();\n\n      if (coordList.size() < 4) {\n        System.out.println(coordList);\n        coordList.add(coordList.get(coordList.size() - 1), true);\n      }\n\n      var pts = coordList.toCoordinateArray();\n      var cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts));\n      var v = startQE.orig();\n      cellPoly.setUserData(v.getCoordinate());\n      return cellPoly;\n    },\n    setLocator: function setLocator(locator) {\n      this._locator = locator;\n    },\n    initSubdiv: function initSubdiv() {\n      var ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);\n      var eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);\n      QuadEdge.splice(ea.sym(), eb);\n      var ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);\n      QuadEdge.splice(eb.sym(), ec);\n      QuadEdge.splice(ec.sym(), ea);\n      return ea;\n    },\n    isFrameBorderEdge: function isFrameBorderEdge(e) {\n      var leftTri = new Array(3).fill(null);\n      QuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n      var rightTri = new Array(3).fill(null);\n      QuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n      var vLeftTriOther = e.lNext().dest();\n      if (this.isFrameVertex(vLeftTriOther)) return true;\n      var vRightTriOther = e.sym().lNext().dest();\n      if (this.isFrameVertex(vRightTriOther)) return true;\n      return false;\n    },\n    makeEdge: function makeEdge(o, d) {\n      var q = QuadEdge.makeEdge(o, d);\n\n      this._quadEdges.add(q);\n\n      return q;\n    },\n    visitTriangles: function visitTriangles(triVisitor, includeFrame) {\n      this._visitedKey++;\n      var edgeStack = new Stack();\n      edgeStack.push(this._startingEdge);\n      var visitedEdges = new HashSet();\n\n      while (!edgeStack.empty()) {\n        var edge = edgeStack.pop();\n\n        if (!visitedEdges.contains(edge)) {\n          var triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n          if (triEdges !== null) triVisitor.visit(triEdges);\n        }\n      }\n    },\n    isFrameEdge: function isFrameEdge(e) {\n      if (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n      return false;\n    },\n    isOnEdge: function isOnEdge(e, p) {\n      this._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n\n      var dist = this._seg.distance(p);\n\n      return dist < this._edgeCoincidenceTolerance;\n    },\n    getEnvelope: function getEnvelope() {\n      return new Envelope(this._frameEnv);\n    },\n    createFrame: function createFrame(env) {\n      var deltaX = env.getWidth();\n      var deltaY = env.getHeight();\n      var offset = 0.0;\n\n      if (deltaX > deltaY) {\n        offset = deltaX * 10.0;\n      } else {\n        offset = deltaY * 10.0;\n      }\n\n      this._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n      this._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n      this._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n      this._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());\n\n      this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());\n    },\n    getTriangleCoordinates: function getTriangleCoordinates(includeFrame) {\n      var visitor = new TriangleCoordinatesVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangles();\n    },\n    getVertices: function getVertices(includeFrame) {\n      var vertices = new HashSet();\n\n      for (var i = this._quadEdges.iterator(); i.hasNext();) {\n        var qe = i.next();\n        var v = qe.orig();\n        if (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n        var vd = qe.dest();\n        if (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n      }\n\n      return vertices;\n    },\n    fetchTriangleToVisit: function fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {\n      var curr = edge;\n      var edgeCount = 0;\n      var isFrame = false;\n\n      do {\n        this._triEdges[edgeCount] = curr;\n        if (this.isFrameEdge(curr)) isFrame = true;\n        var sym = curr.sym();\n        if (!visitedEdges.contains(sym)) edgeStack.push(sym);\n        visitedEdges.add(curr);\n        edgeCount++;\n        curr = curr.lNext();\n      } while (curr !== edge);\n\n      if (isFrame && !includeFrame) return null;\n      return this._triEdges;\n    },\n    getEdges: function getEdges() {\n      if (arguments.length === 0) {\n        return this._quadEdges;\n      } else if (arguments.length === 1) {\n        var geomFact = arguments[0];\n        var quadEdges = this.getPrimaryEdges(false);\n        var edges = new Array(quadEdges.size()).fill(null);\n        var i = 0;\n\n        for (var it = quadEdges.iterator(); it.hasNext();) {\n          var qe = it.next();\n          edges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n        }\n\n        return geomFact.createMultiLineString(edges);\n      }\n    },\n    getVertexUniqueEdges: function getVertexUniqueEdges(includeFrame) {\n      var edges = new ArrayList();\n      var visitedVertices = new HashSet();\n\n      for (var i = this._quadEdges.iterator(); i.hasNext();) {\n        var qe = i.next();\n        var v = qe.orig();\n\n        if (!visitedVertices.contains(v)) {\n          visitedVertices.add(v);\n\n          if (includeFrame || !this.isFrameVertex(v)) {\n            edges.add(qe);\n          }\n        }\n\n        var qd = qe.sym();\n        var vd = qd.orig();\n\n        if (!visitedVertices.contains(vd)) {\n          visitedVertices.add(vd);\n\n          if (includeFrame || !this.isFrameVertex(vd)) {\n            edges.add(qd);\n          }\n        }\n      }\n\n      return edges;\n    },\n    getTriangleEdges: function getTriangleEdges(includeFrame) {\n      var visitor = new TriangleEdgesListVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangleEdges();\n    },\n    getPrimaryEdges: function getPrimaryEdges(includeFrame) {\n      this._visitedKey++;\n      var edges = new ArrayList();\n      var edgeStack = new Stack();\n      edgeStack.push(this._startingEdge);\n      var visitedEdges = new HashSet();\n\n      while (!edgeStack.empty()) {\n        var edge = edgeStack.pop();\n\n        if (!visitedEdges.contains(edge)) {\n          var priQE = edge.getPrimary();\n          if (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n          edgeStack.push(edge.oNext());\n          edgeStack.push(edge.sym().oNext());\n          visitedEdges.add(edge);\n          visitedEdges.add(edge.sym());\n        }\n      }\n\n      return edges;\n    },\n    delete: function _delete(e) {\n      QuadEdge.splice(e, e.oPrev());\n      QuadEdge.splice(e.sym(), e.sym().oPrev());\n      var eSym = e.sym();\n      var eRot = e.rot();\n      var eRotSym = e.rot().sym();\n\n      this._quadEdges.remove(e);\n\n      this._quadEdges.remove(eSym);\n\n      this._quadEdges.remove(eRot);\n\n      this._quadEdges.remove(eRotSym);\n\n      e.delete();\n      eSym.delete();\n      eRot.delete();\n      eRotSym.delete();\n    },\n    locateFromEdge: function locateFromEdge(v, startEdge) {\n      var iter = 0;\n\n      var maxIter = this._quadEdges.size();\n\n      var e = startEdge;\n\n      while (true) {\n        iter++;\n\n        if (iter > maxIter) {\n          throw new LocateFailureException(e.toLineSegment());\n        }\n\n        if (v.equals(e.orig()) || v.equals(e.dest())) {\n          break;\n        } else if (v.rightOf(e)) {\n          e = e.sym();\n        } else if (!v.rightOf(e.oNext())) {\n          e = e.oNext();\n        } else if (!v.rightOf(e.dPrev())) {\n          e = e.dPrev();\n        } else {\n          break;\n        }\n      }\n\n      return e;\n    },\n    getTolerance: function getTolerance() {\n      return this._tolerance;\n    },\n    getVoronoiCellPolygons: function getVoronoiCellPolygons(geomFact) {\n      this.visitTriangles(new TriangleCircumcentreVisitor(), true);\n      var cells = new ArrayList();\n      var edges = this.getVertexUniqueEdges(false);\n\n      for (var i = edges.iterator(); i.hasNext();) {\n        var qe = i.next();\n        cells.add(this.getVoronoiCellPolygon(qe, geomFact));\n      }\n\n      return cells;\n    },\n    getVoronoiDiagram: function getVoronoiDiagram(geomFact) {\n      var vorCells = this.getVoronoiCellPolygons(geomFact);\n      return geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n    },\n    getTriangles: function getTriangles(geomFact) {\n      var triPtsList = this.getTriangleCoordinates(false);\n      var tris = new Array(triPtsList.size()).fill(null);\n      var i = 0;\n\n      for (var it = triPtsList.iterator(); it.hasNext();) {\n        var triPt = it.next();\n        tris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt));\n      }\n\n      return geomFact.createGeometryCollection(tris);\n    },\n    insertSite: function insertSite(v) {\n      var e = this.locate(v);\n\n      if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {\n        return e;\n      }\n\n      var base = this.makeEdge(e.orig(), v);\n      QuadEdge.splice(base, e);\n      var startEdge = base;\n\n      do {\n        base = this.connect(e, base.sym());\n        e = base.oPrev();\n      } while (e.lNext() !== startEdge);\n\n      return startEdge;\n    },\n    locate: function locate() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Vertex) {\n          var v = arguments[0];\n          return this._locator.locate(v);\n        } else if (arguments[0] instanceof Coordinate) {\n          var p = arguments[0];\n          return this._locator.locate(new Vertex(p));\n        }\n      } else if (arguments.length === 2) {\n        var p0 = arguments[0],\n            p1 = arguments[1];\n\n        var e = this._locator.locate(new Vertex(p0));\n\n        if (e === null) return null;\n        var base = e;\n        if (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n        var locEdge = base;\n\n        do {\n          if (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n          locEdge = locEdge.oNext();\n        } while (locEdge !== base);\n\n        return null;\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return QuadEdgeSubdivision;\n    }\n  });\n\n  QuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {\n    triEdge[0] = startQE;\n    triEdge[1] = triEdge[0].lNext();\n    triEdge[2] = triEdge[1].lNext();\n    if (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException(\"Edges do not form a triangle\");\n  };\n\n  function TriangleCircumcentreVisitor() {}\n\n  extend(TriangleCircumcentreVisitor.prototype, {\n    visit: function visit(triEdges) {\n      var a = triEdges[0].orig().getCoordinate();\n      var b = triEdges[1].orig().getCoordinate();\n      var c = triEdges[2].orig().getCoordinate();\n      var cc = Triangle.circumcentre(a, b, c);\n      var ccVertex = new Vertex(cc);\n\n      for (var i = 0; i < 3; i++) {\n        triEdges[i].rot().setOrig(ccVertex);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [TriangleVisitor];\n    },\n    getClass: function getClass() {\n      return TriangleCircumcentreVisitor;\n    }\n  });\n\n  function TriangleEdgesListVisitor() {\n    this._triList = new ArrayList();\n  }\n\n  extend(TriangleEdgesListVisitor.prototype, {\n    getTriangleEdges: function getTriangleEdges() {\n      return this._triList;\n    },\n    visit: function visit(triEdges) {\n      this._triList.add(triEdges);\n    },\n    interfaces_: function interfaces_() {\n      return [TriangleVisitor];\n    },\n    getClass: function getClass() {\n      return TriangleEdgesListVisitor;\n    }\n  });\n\n  function TriangleVertexListVisitor() {\n    this._triList = new ArrayList();\n  }\n\n  extend(TriangleVertexListVisitor.prototype, {\n    visit: function visit(triEdges) {\n      this._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n    },\n    getTriangleVertices: function getTriangleVertices() {\n      return this._triList;\n    },\n    interfaces_: function interfaces_() {\n      return [TriangleVisitor];\n    },\n    getClass: function getClass() {\n      return TriangleVertexListVisitor;\n    }\n  });\n\n  function TriangleCoordinatesVisitor() {\n    this._coordList = new CoordinateList();\n    this._triCoords = new ArrayList();\n  }\n\n  extend(TriangleCoordinatesVisitor.prototype, {\n    checkTriangleSize: function checkTriangleSize(pts) {\n      var loc = \"\";\n      if (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else {\n        if (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n      }\n    },\n    visit: function visit(triEdges) {\n      this._coordList.clear();\n\n      for (var i = 0; i < 3; i++) {\n        var v = triEdges[i].orig();\n\n        this._coordList.add(v.getCoordinate());\n      }\n\n      if (this._coordList.size() > 0) {\n        this._coordList.closeRing();\n\n        var pts = this._coordList.toCoordinateArray();\n\n        if (pts.length !== 4) {\n          return null;\n        }\n\n        this._triCoords.add(pts);\n      }\n    },\n    getTriangles: function getTriangles() {\n      return this._triCoords;\n    },\n    interfaces_: function interfaces_() {\n      return [TriangleVisitor];\n    },\n    getClass: function getClass() {\n      return TriangleCoordinatesVisitor;\n    }\n  });\n  QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\n  QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\n  QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\n  QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\n  QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n\n  function Segment() {\n    this._ls = null;\n    this._data = null;\n\n    if (arguments.length === 2) {\n      var p0 = arguments[0],\n          p1 = arguments[1];\n      this._ls = new LineSegment(p0, p1);\n    } else if (arguments.length === 3) {\n      var _p = arguments[0],\n          _p2 = arguments[1],\n          data = arguments[2];\n      this._ls = new LineSegment(_p, _p2);\n      this._data = data;\n    } else if (arguments.length === 6) {\n      var x1 = arguments[0],\n          y1 = arguments[1],\n          z1 = arguments[2],\n          x2 = arguments[3],\n          y2 = arguments[4],\n          z2 = arguments[5];\n      Segment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n    } else if (arguments.length === 7) {\n      var _x = arguments[0],\n          _y = arguments[1],\n          _z = arguments[2],\n          _x2 = arguments[3],\n          _y2 = arguments[4],\n          _z2 = arguments[5],\n          _data = arguments[6];\n      Segment.call(this, new Coordinate(_x, _y, _z), new Coordinate(_x2, _y2, _z2), _data);\n    }\n  }\n  extend(Segment.prototype, {\n    getLineSegment: function getLineSegment() {\n      return this._ls;\n    },\n    getEndZ: function getEndZ() {\n      var p = this._ls.getCoordinate(1);\n\n      return p.z;\n    },\n    getStartZ: function getStartZ() {\n      var p = this._ls.getCoordinate(0);\n\n      return p.z;\n    },\n    intersection: function intersection(s) {\n      return this._ls.intersection(s.getLineSegment());\n    },\n    getStart: function getStart() {\n      return this._ls.getCoordinate(0);\n    },\n    getEnd: function getEnd() {\n      return this._ls.getCoordinate(1);\n    },\n    getEndY: function getEndY() {\n      var p = this._ls.getCoordinate(1);\n\n      return p.y;\n    },\n    getStartX: function getStartX() {\n      var p = this._ls.getCoordinate(0);\n\n      return p.x;\n    },\n    equalsTopo: function equalsTopo(s) {\n      return this._ls.equalsTopo(s.getLineSegment());\n    },\n    getStartY: function getStartY() {\n      var p = this._ls.getCoordinate(0);\n\n      return p.y;\n    },\n    setData: function setData(data) {\n      this._data = data;\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    getEndX: function getEndX() {\n      var p = this._ls.getCoordinate(1);\n\n      return p.x;\n    },\n    toString: function toString() {\n      return this._ls.toString();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return Segment;\n    }\n  });\n\n  function ConformingDelaunayTriangulator() {\n    this._initialVertices = null;\n    this._segVertices = null;\n    this._segments = new ArrayList();\n    this._subdiv = null;\n    this._incDel = null;\n    this._convexHull = null;\n    this._splitFinder = new NonEncroachingSplitPointFinder();\n    this._kdt = null;\n    this._vertexFactory = null;\n    this._computeAreaEnv = null;\n    this._splitPt = null;\n    this._tolerance = null;\n    var initialVertices = arguments[0],\n        tolerance = arguments[1];\n    this._initialVertices = new ArrayList(initialVertices);\n    this._tolerance = tolerance;\n    this._kdt = new KdTree(tolerance);\n  }\n  extend(ConformingDelaunayTriangulator.prototype, {\n    getInitialVertices: function getInitialVertices() {\n      return this._initialVertices;\n    },\n    getKDT: function getKDT() {\n      return this._kdt;\n    },\n    enforceConstraints: function enforceConstraints() {\n      this.addConstraintVertices();\n      var count = 0;\n      var splits = 0;\n\n      do {\n        splits = this.enforceGabriel(this._segments);\n        count++;\n      } while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n    },\n    insertSites: function insertSites(vertices) {\n      for (var i = vertices.iterator(); i.hasNext();) {\n        var v = i.next();\n        this.insertSite(v);\n      }\n    },\n    getVertexFactory: function getVertexFactory() {\n      return this._vertexFactory;\n    },\n    getPointArray: function getPointArray() {\n      var pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);\n      var index = 0;\n\n      for (var i = this._initialVertices.iterator(); i.hasNext();) {\n        var v = i.next();\n        pts[index++] = v.getCoordinate();\n      }\n\n      for (var i2 = this._segVertices.iterator(); i2.hasNext();) {\n        var v = i2.next();\n        pts[index++] = v.getCoordinate();\n      }\n\n      return pts;\n    },\n    setConstraints: function setConstraints(segments, segVertices) {\n      this._segments = segments;\n      this._segVertices = segVertices;\n    },\n    computeConvexHull: function computeConvexHull() {\n      var fact = new GeometryFactory();\n      var coords = this.getPointArray();\n      var hull = new ConvexHull(coords, fact);\n      this._convexHull = hull.getConvexHull();\n    },\n    addConstraintVertices: function addConstraintVertices() {\n      this.computeConvexHull();\n      this.insertSites(this._segVertices);\n    },\n    findNonGabrielPoint: function findNonGabrielPoint(seg) {\n      var p = seg.getStart();\n      var q = seg.getEnd();\n      var midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n      var segRadius = p.distance(midPt);\n      var env = new Envelope(midPt);\n      env.expandBy(segRadius);\n\n      var result = this._kdt.query(env);\n\n      var closestNonGabriel = null;\n      var minDist = Double.MAX_VALUE;\n\n      for (var i = result.iterator(); i.hasNext();) {\n        var nextNode = i.next();\n        var testPt = nextNode.getCoordinate();\n        if (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n        var testRadius = midPt.distance(testPt);\n\n        if (testRadius < segRadius) {\n          var testDist = testRadius;\n\n          if (closestNonGabriel === null || testDist < minDist) {\n            closestNonGabriel = testPt;\n            minDist = testDist;\n          }\n        }\n      }\n\n      return closestNonGabriel;\n    },\n    getConstraintSegments: function getConstraintSegments() {\n      return this._segments;\n    },\n    setSplitPointFinder: function setSplitPointFinder(splitFinder) {\n      this._splitFinder = splitFinder;\n    },\n    getConvexHull: function getConvexHull() {\n      return this._convexHull;\n    },\n    getTolerance: function getTolerance() {\n      return this._tolerance;\n    },\n    enforceGabriel: function enforceGabriel(segsToInsert) {\n      var newSegments = new ArrayList();\n      var splits = 0;\n      var segsToRemove = new ArrayList();\n\n      for (var i = segsToInsert.iterator(); i.hasNext();) {\n        var seg = i.next();\n        var encroachPt = this.findNonGabrielPoint(seg);\n        if (encroachPt === null) continue;\n        this._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);\n        var splitVertex = this.createVertex(this._splitPt, seg);\n        var insertedVertex = this.insertSite(splitVertex);\n\n        if (!insertedVertex.getCoordinate().equals2D(this._splitPt)) ;\n\n        var s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n        var s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n        newSegments.add(s1);\n        newSegments.add(s2);\n        segsToRemove.add(seg);\n        splits = splits + 1;\n      }\n\n      segsToInsert.removeAll(segsToRemove);\n      segsToInsert.addAll(newSegments);\n      return splits;\n    },\n    createVertex: function createVertex() {\n      if (arguments.length === 1) {\n        var p = arguments[0];\n        var v = null;\n        if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);\n        return v;\n      } else if (arguments.length === 2) {\n        var _p = arguments[0],\n            seg = arguments[1];\n        var v = null;\n        if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(_p, seg);else v = new ConstraintVertex(_p);\n        v.setOnConstraint(true);\n        return v;\n      }\n    },\n    getSubdivision: function getSubdivision() {\n      return this._subdiv;\n    },\n    computeBoundingBox: function computeBoundingBox() {\n      var vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);\n      var segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);\n      var allPointsEnv = new Envelope(vertexEnv);\n      allPointsEnv.expandToInclude(segEnv);\n      var deltaX = allPointsEnv.getWidth() * 0.2;\n      var deltaY = allPointsEnv.getHeight() * 0.2;\n      var delta = Math.max(deltaX, deltaY);\n      this._computeAreaEnv = new Envelope(allPointsEnv);\n\n      this._computeAreaEnv.expandBy(delta);\n    },\n    setVertexFactory: function setVertexFactory(vertexFactory) {\n      this._vertexFactory = vertexFactory;\n    },\n    formInitialDelaunay: function formInitialDelaunay() {\n      this.computeBoundingBox();\n      this._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);\n\n      this._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));\n\n      this._incDel = new IncrementalDelaunayTriangulator(this._subdiv);\n      this.insertSites(this._initialVertices);\n    },\n    insertSite: function insertSite() {\n      if (arguments[0] instanceof ConstraintVertex) {\n        var v = arguments[0];\n\n        var kdnode = this._kdt.insert(v.getCoordinate(), v);\n\n        if (!kdnode.isRepeated()) {\n          this._incDel.insertSite(v);\n        } else {\n          var snappedV = kdnode.getData();\n          snappedV.merge(v);\n          return snappedV;\n        }\n\n        return v;\n      } else if (arguments[0] instanceof Coordinate) {\n        var p = arguments[0];\n        this.insertSite(this.createVertex(p));\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConformingDelaunayTriangulator;\n    }\n  });\n\n  ConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {\n    var env = new Envelope();\n\n    for (var i = vertices.iterator(); i.hasNext();) {\n      var v = i.next();\n      env.expandToInclude(v.getCoordinate());\n    }\n\n    return env;\n  };\n\n  ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n\n  function DelaunayTriangulationBuilder() {\n    this._siteCoords = null;\n    this._tolerance = 0.0;\n    this._subdiv = null;\n  }\n  extend(DelaunayTriangulationBuilder.prototype, {\n    create: function create() {\n      if (this._subdiv !== null) return null;\n      var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      var vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n      this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n      var triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n      triangulator.insertSites(vertices);\n    },\n    setTolerance: function setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    },\n    setSites: function setSites() {\n      if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n      } else if (hasInterface(arguments[0], Collection)) {\n        var coords = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n      }\n    },\n    getEdges: function getEdges(geomFact) {\n      this.create();\n      return this._subdiv.getEdges(geomFact);\n    },\n    getSubdivision: function getSubdivision() {\n      this.create();\n      return this._subdiv;\n    },\n    getTriangles: function getTriangles(geomFact) {\n      this.create();\n      return this._subdiv.getTriangles(geomFact);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return DelaunayTriangulationBuilder;\n    }\n  });\n\n  DelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {\n    if (geom === null) return new CoordinateList();\n    var coords = geom.getCoordinates();\n    return DelaunayTriangulationBuilder.unique(coords);\n  };\n\n  DelaunayTriangulationBuilder.envelope = function (coords) {\n    var env = new Envelope();\n\n    for (var i = coords.iterator(); i.hasNext();) {\n      var coord = i.next();\n      env.expandToInclude(coord);\n    }\n\n    return env;\n  };\n\n  DelaunayTriangulationBuilder.unique = function (coords) {\n    var coordsCopy = CoordinateArrays.copyDeep(coords);\n    Arrays.sort(coordsCopy);\n    var coordList = new CoordinateList(coordsCopy, false);\n    return coordList;\n  };\n\n  DelaunayTriangulationBuilder.toVertices = function (coords) {\n    var verts = new ArrayList();\n\n    for (var i = coords.iterator(); i.hasNext();) {\n      var coord = i.next();\n      verts.add(new Vertex(coord));\n    }\n\n    return verts;\n  };\n\n  function ConformingDelaunayTriangulationBuilder() {\n    this._siteCoords = null;\n    this._constraintLines = null;\n    this._tolerance = 0.0;\n    this._subdiv = null;\n    this._constraintVertexMap = new TreeMap();\n  }\n  extend(ConformingDelaunayTriangulationBuilder.prototype, {\n    createSiteVertices: function createSiteVertices(coords) {\n      var verts = new ArrayList();\n\n      for (var i = coords.iterator(); i.hasNext();) {\n        var coord = i.next();\n        if (this._constraintVertexMap.containsKey(coord)) continue;\n        verts.add(new ConstraintVertex(coord));\n      }\n\n      return verts;\n    },\n    create: function create() {\n      if (this._subdiv !== null) return null;\n      var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      var segments = new ArrayList();\n\n      if (this._constraintLines !== null) {\n        siteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());\n        this.createVertices(this._constraintLines);\n        segments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);\n      }\n\n      var sites = this.createSiteVertices(this._siteCoords);\n      var cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);\n      cdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));\n      cdt.formInitialDelaunay();\n      cdt.enforceConstraints();\n      this._subdiv = cdt.getSubdivision();\n    },\n    setTolerance: function setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    },\n    setConstraints: function setConstraints(constraintLines) {\n      this._constraintLines = constraintLines;\n    },\n    setSites: function setSites(geom) {\n      this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n    },\n    getEdges: function getEdges(geomFact) {\n      this.create();\n      return this._subdiv.getEdges(geomFact);\n    },\n    getSubdivision: function getSubdivision() {\n      this.create();\n      return this._subdiv;\n    },\n    getTriangles: function getTriangles(geomFact) {\n      this.create();\n      return this._subdiv.getTriangles(geomFact);\n    },\n    createVertices: function createVertices(geom) {\n      var coords = geom.getCoordinates();\n\n      for (var i = 0; i < coords.length; i++) {\n        var v = new ConstraintVertex(coords[i]);\n\n        this._constraintVertexMap.put(coords[i], v);\n      }\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ConformingDelaunayTriangulationBuilder;\n    }\n  });\n\n  ConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {\n    if (arguments.length === 1) {\n      var geom = arguments[0];\n      var lines = LinearComponentExtracter.getLines(geom);\n      var constraintSegs = new ArrayList();\n\n      for (var i = lines.iterator(); i.hasNext();) {\n        var line = i.next();\n        ConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n      }\n\n      return constraintSegs;\n    } else if (arguments.length === 2) {\n      var _line = arguments[0],\n          _constraintSegs = arguments[1];\n\n      var coords = _line.getCoordinates();\n\n      for (var i = 1; i < coords.length; i++) {\n        _constraintSegs.add(new Segment(coords[i - 1], coords[i]));\n      }\n    }\n  };\n\n  function VoronoiDiagramBuilder() {\n    this._siteCoords = null;\n    this._tolerance = 0.0;\n    this._subdiv = null;\n    this._clipEnv = null;\n    this._diagramEnv = null;\n  }\n  extend(VoronoiDiagramBuilder.prototype, {\n    create: function create() {\n      if (this._subdiv !== null) return null;\n      var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      this._diagramEnv = siteEnv;\n      var expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());\n\n      this._diagramEnv.expandBy(expandBy);\n\n      if (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);\n      var vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n      this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n      var triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n      triangulator.insertSites(vertices);\n    },\n    getDiagram: function getDiagram(geomFact) {\n      this.create();\n\n      var polys = this._subdiv.getVoronoiDiagram(geomFact);\n\n      return VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);\n    },\n    setTolerance: function setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    },\n    setSites: function setSites() {\n      if (arguments[0] instanceof Geometry) {\n        var geom = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n      } else if (hasInterface(arguments[0], Collection)) {\n        var coords = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n      }\n    },\n    setClipEnvelope: function setClipEnvelope(clipEnv) {\n      this._clipEnv = clipEnv;\n    },\n    getSubdivision: function getSubdivision() {\n      this.create();\n      return this._subdiv;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return VoronoiDiagramBuilder;\n    }\n  });\n\n  VoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {\n    var clipPoly = geom.getFactory().toGeometry(clipEnv);\n    var clipped = new ArrayList();\n\n    for (var i = 0; i < geom.getNumGeometries(); i++) {\n      var g = geom.getGeometryN(i);\n      var result = null;\n      if (clipEnv.contains(g.getEnvelopeInternal())) result = g;else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n        result = clipPoly.intersection(g);\n        result.setUserData(g.getUserData());\n      }\n\n      if (result !== null && !result.isEmpty()) {\n        clipped.add(result);\n      }\n    }\n\n    return geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n  };\n\n\n\n  var quadedge = /*#__PURE__*/Object.freeze({\n    Vertex: Vertex\n  });\n\n\n\n  var triangulate = /*#__PURE__*/Object.freeze({\n    ConformingDelaunayTriangulationBuilder: ConformingDelaunayTriangulationBuilder,\n    DelaunayTriangulationBuilder: DelaunayTriangulationBuilder,\n    VoronoiDiagramBuilder: VoronoiDiagramBuilder,\n    quadedge: quadedge\n  });\n\n  function LinearLocation() {\n    this._componentIndex = 0;\n    this._segmentIndex = 0;\n    this._segmentFraction = 0.0;\n\n    if (arguments.length === 0) ; else if (arguments.length === 1) {\n      var loc = arguments[0];\n      this._componentIndex = loc._componentIndex;\n      this._segmentIndex = loc._segmentIndex;\n      this._segmentFraction = loc._segmentFraction;\n    } else if (arguments.length === 2) {\n      var segmentIndex = arguments[0],\n          segmentFraction = arguments[1];\n      LinearLocation.call(this, 0, segmentIndex, segmentFraction);\n    } else if (arguments.length === 3) {\n      var componentIndex = arguments[0],\n          _segmentIndex = arguments[1],\n          _segmentFraction = arguments[2];\n      this._componentIndex = componentIndex;\n      this._segmentIndex = _segmentIndex;\n      this._segmentFraction = _segmentFraction;\n      this.normalize();\n    } else if (arguments.length === 4) {\n      var _componentIndex = arguments[0],\n          _segmentIndex2 = arguments[1],\n          _segmentFraction2 = arguments[2],\n          doNormalize = arguments[3];\n      this._componentIndex = _componentIndex;\n      this._segmentIndex = _segmentIndex2;\n      this._segmentFraction = _segmentFraction2;\n      if (doNormalize) this.normalize();\n    }\n  }\n  extend(LinearLocation.prototype, {\n    getSegmentIndex: function getSegmentIndex() {\n      return this._segmentIndex;\n    },\n    getComponentIndex: function getComponentIndex() {\n      return this._componentIndex;\n    },\n    isEndpoint: function isEndpoint(linearGeom) {\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      var nseg = lineComp.getNumPoints() - 1;\n      return this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;\n    },\n    isValid: function isValid(linearGeom) {\n      if (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      if (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;\n      if (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;\n      if (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;\n      return true;\n    },\n    normalize: function normalize() {\n      if (this._segmentFraction < 0.0) {\n        this._segmentFraction = 0.0;\n      }\n\n      if (this._segmentFraction > 1.0) {\n        this._segmentFraction = 1.0;\n      }\n\n      if (this._componentIndex < 0) {\n        this._componentIndex = 0;\n        this._segmentIndex = 0;\n        this._segmentFraction = 0.0;\n      }\n\n      if (this._segmentIndex < 0) {\n        this._segmentIndex = 0;\n        this._segmentFraction = 0.0;\n      }\n\n      if (this._segmentFraction === 1.0) {\n        this._segmentFraction = 0.0;\n        this._segmentIndex += 1;\n      }\n    },\n    toLowest: function toLowest(linearGeom) {\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      var nseg = lineComp.getNumPoints() - 1;\n      if (this._segmentIndex < nseg) return this;\n      return new LinearLocation(this._componentIndex, nseg, 1.0, false);\n    },\n    getCoordinate: function getCoordinate(linearGeom) {\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      var p0 = lineComp.getCoordinateN(this._segmentIndex);\n      if (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;\n      var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n      return LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);\n    },\n    getSegmentFraction: function getSegmentFraction() {\n      return this._segmentFraction;\n    },\n    getSegment: function getSegment(linearGeom) {\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      var p0 = lineComp.getCoordinateN(this._segmentIndex);\n\n      if (this._segmentIndex >= lineComp.getNumPoints() - 1) {\n        var prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n        return new LineSegment(prev, p0);\n      }\n\n      var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n      return new LineSegment(p0, p1);\n    },\n    clamp: function clamp(linear) {\n      if (this._componentIndex >= linear.getNumGeometries()) {\n        this.setToEnd(linear);\n        return null;\n      }\n\n      if (this._segmentIndex >= linear.getNumPoints()) {\n        var line = linear.getGeometryN(this._componentIndex);\n        this._segmentIndex = line.getNumPoints() - 1;\n        this._segmentFraction = 1.0;\n      }\n    },\n    setToEnd: function setToEnd(linear) {\n      this._componentIndex = linear.getNumGeometries() - 1;\n      var lastLine = linear.getGeometryN(this._componentIndex);\n      this._segmentIndex = lastLine.getNumPoints() - 1;\n      this._segmentFraction = 1.0;\n    },\n    compareTo: function compareTo(o) {\n      var other = o;\n      if (this._componentIndex < other._componentIndex) return -1;\n      if (this._componentIndex > other._componentIndex) return 1;\n      if (this._segmentIndex < other._segmentIndex) return -1;\n      if (this._segmentIndex > other._segmentIndex) return 1;\n      if (this._segmentFraction < other._segmentFraction) return -1;\n      if (this._segmentFraction > other._segmentFraction) return 1;\n      return 0;\n    },\n    copy: function copy() {\n      return new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);\n    },\n    toString: function toString() {\n      return \"LinearLoc[\" + this._componentIndex + \", \" + this._segmentIndex + \", \" + this._segmentFraction + \"]\";\n    },\n    isOnSameSegment: function isOnSameSegment(loc) {\n      if (this._componentIndex !== loc._componentIndex) return false;\n      if (this._segmentIndex === loc._segmentIndex) return true;\n      if (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;\n      if (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;\n      return false;\n    },\n    snapToVertex: function snapToVertex(linearGeom, minDistance) {\n      if (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;\n      var segLen = this.getSegmentLength(linearGeom);\n      var lenToStart = this._segmentFraction * segLen;\n      var lenToEnd = segLen - lenToStart;\n\n      if (lenToStart <= lenToEnd && lenToStart < minDistance) {\n        this._segmentFraction = 0.0;\n      } else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {\n        this._segmentFraction = 1.0;\n      }\n    },\n    compareLocationValues: function compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {\n      if (this._componentIndex < componentIndex1) return -1;\n      if (this._componentIndex > componentIndex1) return 1;\n      if (this._segmentIndex < segmentIndex1) return -1;\n      if (this._segmentIndex > segmentIndex1) return 1;\n      if (this._segmentFraction < segmentFraction1) return -1;\n      if (this._segmentFraction > segmentFraction1) return 1;\n      return 0;\n    },\n    getSegmentLength: function getSegmentLength(linearGeom) {\n      var lineComp = linearGeom.getGeometryN(this._componentIndex);\n      var segIndex = this._segmentIndex;\n      if (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;\n      var p0 = lineComp.getCoordinateN(segIndex);\n      var p1 = lineComp.getCoordinateN(segIndex + 1);\n      return p0.distance(p1);\n    },\n    isVertex: function isVertex() {\n      return this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;\n    },\n    interfaces_: function interfaces_() {\n      return [Comparable];\n    },\n    getClass: function getClass() {\n      return LinearLocation;\n    }\n  });\n\n  LinearLocation.getEndLocation = function (linear) {\n    var loc = new LinearLocation();\n    loc.setToEnd(linear);\n    return loc;\n  };\n\n  LinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {\n    if (frac <= 0.0) return p0;\n    if (frac >= 1.0) return p1;\n    var x = (p1.x - p0.x) * frac + p0.x;\n    var y = (p1.y - p0.y) * frac + p0.y;\n    var z = (p1.z - p0.z) * frac + p0.z;\n    return new Coordinate(x, y, z);\n  };\n\n  LinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n    if (componentIndex0 < componentIndex1) return -1;\n    if (componentIndex0 > componentIndex1) return 1;\n    if (segmentIndex0 < segmentIndex1) return -1;\n    if (segmentIndex0 > segmentIndex1) return 1;\n    if (segmentFraction0 < segmentFraction1) return -1;\n    if (segmentFraction0 > segmentFraction1) return 1;\n    return 0;\n  };\n\n  function LinearIterator() {\n    this._linearGeom = null;\n    this._numLines = null;\n    this._currentLine = null;\n    this._componentIndex = 0;\n    this._vertexIndex = 0;\n\n    if (arguments.length === 1) {\n      var linear = arguments[0];\n      LinearIterator.call(this, linear, 0, 0);\n    } else if (arguments.length === 2) {\n      var _linear = arguments[0],\n          start = arguments[1];\n      LinearIterator.call(this, _linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n    } else if (arguments.length === 3) {\n      var linearGeom = arguments[0],\n          componentIndex = arguments[1],\n          vertexIndex = arguments[2];\n      if (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException(\"Lineal geometry is required\");\n      this._linearGeom = linearGeom;\n      this._numLines = linearGeom.getNumGeometries();\n      this._componentIndex = componentIndex;\n      this._vertexIndex = vertexIndex;\n      this.loadCurrentLine();\n    }\n  }\n  extend(LinearIterator.prototype, {\n    getComponentIndex: function getComponentIndex() {\n      return this._componentIndex;\n    },\n    getLine: function getLine() {\n      return this._currentLine;\n    },\n    getVertexIndex: function getVertexIndex() {\n      return this._vertexIndex;\n    },\n    getSegmentEnd: function getSegmentEnd() {\n      if (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);\n      return null;\n    },\n    next: function next() {\n      if (!this.hasNext()) return null;\n      this._vertexIndex++;\n\n      if (this._vertexIndex >= this._currentLine.getNumPoints()) {\n        this._componentIndex++;\n        this.loadCurrentLine();\n        this._vertexIndex = 0;\n      }\n    },\n    loadCurrentLine: function loadCurrentLine() {\n      if (this._componentIndex >= this._numLines) {\n        this._currentLine = null;\n        return null;\n      }\n\n      this._currentLine = this._linearGeom.getGeometryN(this._componentIndex);\n    },\n    getSegmentStart: function getSegmentStart() {\n      return this._currentLine.getCoordinateN(this._vertexIndex);\n    },\n    isEndOfLine: function isEndOfLine() {\n      if (this._componentIndex >= this._numLines) return false;\n      if (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;\n      return true;\n    },\n    hasNext: function hasNext() {\n      if (this._componentIndex >= this._numLines) return false;\n      if (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;\n      return true;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LinearIterator;\n    }\n  });\n\n  LinearIterator.segmentEndVertexIndex = function (loc) {\n    if (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n    return loc.getSegmentIndex();\n  };\n\n  function LocationIndexOfPoint() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfPoint.prototype, {\n    indexOf: function indexOf(inputPt) {\n      return this.indexOfFromStart(inputPt, null);\n    },\n    indexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n      var minDistance = Double.MAX_VALUE;\n      var minComponentIndex = 0;\n      var minSegmentIndex = 0;\n      var minFrac = -1.0;\n      var seg = new LineSegment();\n\n      for (var it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) {\n        if (!it.isEndOfLine()) {\n          seg.p0 = it.getSegmentStart();\n          seg.p1 = it.getSegmentEnd();\n          var segDistance = seg.distance(inputPt);\n          var segFrac = seg.segmentFraction(inputPt);\n          var candidateComponentIndex = it.getComponentIndex();\n          var candidateSegmentIndex = it.getVertexIndex();\n\n          if (segDistance < minDistance) {\n            if (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n              minComponentIndex = candidateComponentIndex;\n              minSegmentIndex = candidateSegmentIndex;\n              minFrac = segFrac;\n              minDistance = segDistance;\n            }\n          }\n        }\n      }\n\n      if (minDistance === Double.MAX_VALUE) {\n        return new LinearLocation(minIndex);\n      }\n\n      var loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n      return loc;\n    },\n    indexOfAfter: function indexOfAfter(inputPt, minIndex) {\n      if (minIndex === null) return this.indexOf(inputPt);\n      var endLoc = LinearLocation.getEndLocation(this._linearGeom);\n      if (endLoc.compareTo(minIndex) <= 0) return endLoc;\n      var closestAfter = this.indexOfFromStart(inputPt, minIndex);\n      Assert.isTrue(closestAfter.compareTo(minIndex) >= 0, \"computed location is before specified minimum location\");\n      return closestAfter;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LocationIndexOfPoint;\n    }\n  });\n\n  LocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n    var locater = new LocationIndexOfPoint(linearGeom);\n    return locater.indexOf(inputPt);\n  };\n\n  LocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n    var locater = new LocationIndexOfPoint(linearGeom);\n    return locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LocationIndexOfLine() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n  }\n  extend(LocationIndexOfLine.prototype, {\n    indicesOf: function indicesOf(subLine) {\n      var startPt = subLine.getGeometryN(0).getCoordinateN(0);\n      var lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n      var endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n      var locPt = new LocationIndexOfPoint(this._linearGeom);\n      var subLineLoc = new Array(2).fill(null);\n      subLineLoc[0] = locPt.indexOf(startPt);\n\n      if (subLine.getLength() === 0.0) {\n        subLineLoc[1] = subLineLoc[0].copy();\n      } else {\n        subLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n      }\n\n      return subLineLoc;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LocationIndexOfLine;\n    }\n  });\n\n  LocationIndexOfLine.indicesOf = function (linearGeom, subLine) {\n    var locater = new LocationIndexOfLine(linearGeom);\n    return locater.indicesOf(subLine);\n  };\n\n  function LinearGeometryBuilder() {\n    this._geomFact = null;\n    this._lines = new ArrayList();\n    this._coordList = null;\n    this._ignoreInvalidLines = false;\n    this._fixInvalidLines = false;\n    this._lastPt = null;\n    var geomFact = arguments[0];\n    this._geomFact = geomFact;\n  }\n  extend(LinearGeometryBuilder.prototype, {\n    getGeometry: function getGeometry() {\n      this.endLine();\n      return this._geomFact.buildGeometry(this._lines);\n    },\n    getLastCoordinate: function getLastCoordinate() {\n      return this._lastPt;\n    },\n    endLine: function endLine() {\n      if (this._coordList === null) {\n        return null;\n      }\n\n      if (this._ignoreInvalidLines && this._coordList.size() < 2) {\n        this._coordList = null;\n        return null;\n      }\n\n      var rawPts = this._coordList.toCoordinateArray();\n\n      var pts = rawPts;\n      if (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n      this._coordList = null;\n      var line = null;\n\n      try {\n        line = this._geomFact.createLineString(pts);\n      } catch (ex) {\n        if (ex instanceof IllegalArgumentException) {\n          if (!this._ignoreInvalidLines) throw ex;\n        } else throw ex;\n      } finally {}\n\n      if (line !== null) this._lines.add(line);\n    },\n    setFixInvalidLines: function setFixInvalidLines(fixInvalidLines) {\n      this._fixInvalidLines = fixInvalidLines;\n    },\n    add: function add() {\n      if (arguments.length === 1) {\n        var pt = arguments[0];\n        this.add(pt, true);\n      } else if (arguments.length === 2) {\n        var _pt = arguments[0],\n            allowRepeatedPoints = arguments[1];\n        if (this._coordList === null) this._coordList = new CoordinateList();\n\n        this._coordList.add(_pt, allowRepeatedPoints);\n\n        this._lastPt = _pt;\n      }\n    },\n    setIgnoreInvalidLines: function setIgnoreInvalidLines(ignoreInvalidLines) {\n      this._ignoreInvalidLines = ignoreInvalidLines;\n    },\n    validCoordinateSequence: function validCoordinateSequence(pts) {\n      if (pts.length >= 2) return pts;\n      var validPts = [pts[0], pts[0]];\n      return validPts;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LinearGeometryBuilder;\n    }\n  });\n\n  function ExtractLineByLocation() {\n    this._line = null;\n    var line = arguments[0];\n    this._line = line;\n  }\n  extend(ExtractLineByLocation.prototype, {\n    computeLinear: function computeLinear(start, end) {\n      var builder = new LinearGeometryBuilder(this._line.getFactory());\n      builder.setFixInvalidLines(true);\n      if (!start.isVertex()) builder.add(start.getCoordinate(this._line));\n\n      for (var it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {\n        if (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n        var pt = it.getSegmentStart();\n        builder.add(pt);\n        if (it.isEndOfLine()) builder.endLine();\n      }\n\n      if (!end.isVertex()) builder.add(end.getCoordinate(this._line));\n      return builder.getGeometry();\n    },\n    computeLine: function computeLine(start, end) {\n      var coordinates = this._line.getCoordinates();\n\n      var newCoordinates = new CoordinateList();\n      var startSegmentIndex = start.getSegmentIndex();\n      if (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n      var lastSegmentIndex = end.getSegmentIndex();\n      if (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n      if (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n      if (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));\n\n      for (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {\n        newCoordinates.add(coordinates[i]);\n      }\n\n      if (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));\n      if (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));\n      var newCoordinateArray = newCoordinates.toCoordinateArray();\n\n      if (newCoordinateArray.length <= 1) {\n        newCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n      }\n\n      return this._line.getFactory().createLineString(newCoordinateArray);\n    },\n    extract: function extract(start, end) {\n      if (end.compareTo(start) < 0) {\n        return this.reverse(this.computeLinear(end, start));\n      }\n\n      return this.computeLinear(start, end);\n    },\n    reverse: function reverse(linear) {\n      if (linear instanceof LineString) return linear.reverse();\n      if (linear instanceof MultiLineString) return linear.reverse();\n      Assert.shouldNeverReachHere(\"non-linear geometry encountered\");\n      return null;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return ExtractLineByLocation;\n    }\n  });\n\n  ExtractLineByLocation.extract = function (line, start, end) {\n    var ls = new ExtractLineByLocation(line);\n    return ls.extract(start, end);\n  };\n\n  function LocationIndexedLine() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n    this.checkGeometryType();\n  }\n  extend(LocationIndexedLine.prototype, {\n    clampIndex: function clampIndex(index) {\n      var loc = index.copy();\n      loc.clamp(this._linearGeom);\n      return loc;\n    },\n    project: function project(pt) {\n      return LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n    },\n    checkGeometryType: function checkGeometryType() {\n      if (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException(\"Input geometry must be linear\");\n    },\n    extractPoint: function extractPoint() {\n      if (arguments.length === 1) {\n        var index = arguments[0];\n        return index.getCoordinate(this._linearGeom);\n      } else if (arguments.length === 2) {\n        var _index = arguments[0],\n            offsetDistance = arguments[1];\n\n        var indexLow = _index.toLowest(this._linearGeom);\n\n        return indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n      }\n    },\n    isValidIndex: function isValidIndex(index) {\n      return index.isValid(this._linearGeom);\n    },\n    getEndIndex: function getEndIndex() {\n      return LinearLocation.getEndLocation(this._linearGeom);\n    },\n    getStartIndex: function getStartIndex() {\n      return new LinearLocation();\n    },\n    indexOfAfter: function indexOfAfter(pt, minIndex) {\n      return LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n    },\n    extractLine: function extractLine(startIndex, endIndex) {\n      return ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);\n    },\n    indexOf: function indexOf(pt) {\n      return LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n    },\n    indicesOf: function indicesOf(subLine) {\n      return LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LocationIndexedLine;\n    }\n  });\n\n  function LengthIndexOfPoint() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n  }\n  extend(LengthIndexOfPoint.prototype, {\n    indexOf: function indexOf(inputPt) {\n      return this.indexOfFromStart(inputPt, -1.0);\n    },\n    indexOfFromStart: function indexOfFromStart(inputPt, minIndex) {\n      var minDistance = Double.MAX_VALUE;\n      var ptMeasure = minIndex;\n      var segmentStartMeasure = 0.0;\n      var seg = new LineSegment();\n      var it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (!it.isEndOfLine()) {\n          seg.p0 = it.getSegmentStart();\n          seg.p1 = it.getSegmentEnd();\n          var segDistance = seg.distance(inputPt);\n          var segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n\n          if (segDistance < minDistance && segMeasureToPt > minIndex) {\n            ptMeasure = segMeasureToPt;\n            minDistance = segDistance;\n          }\n\n          segmentStartMeasure += seg.getLength();\n        }\n\n        it.next();\n      }\n\n      return ptMeasure;\n    },\n    indexOfAfter: function indexOfAfter(inputPt, minIndex) {\n      if (minIndex < 0.0) return this.indexOf(inputPt);\n\n      var endIndex = this._linearGeom.getLength();\n\n      if (endIndex < minIndex) return endIndex;\n      var closestAfter = this.indexOfFromStart(inputPt, minIndex);\n      Assert.isTrue(closestAfter >= minIndex, \"computed index is before specified minimum index\");\n      return closestAfter;\n    },\n    segmentNearestMeasure: function segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {\n      var projFactor = seg.projectionFactor(inputPt);\n      if (projFactor <= 0.0) return segmentStartMeasure;\n      if (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n      return segmentStartMeasure + seg.getLength();\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LengthIndexOfPoint;\n    }\n  });\n\n  LengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n    var locater = new LengthIndexOfPoint(linearGeom);\n    return locater.indexOf(inputPt);\n  };\n\n  LengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n    var locater = new LengthIndexOfPoint(linearGeom);\n    return locater.indexOfAfter(inputPt, minIndex);\n  };\n\n  function LengthLocationMap() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n  }\n  extend(LengthLocationMap.prototype, {\n    getLength: function getLength(loc) {\n      var totalLength = 0.0;\n      var it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (!it.isEndOfLine()) {\n          var p0 = it.getSegmentStart();\n          var p1 = it.getSegmentEnd();\n          var segLen = p1.distance(p0);\n\n          if (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {\n            return totalLength + segLen * loc.getSegmentFraction();\n          }\n\n          totalLength += segLen;\n        }\n\n        it.next();\n      }\n\n      return totalLength;\n    },\n    resolveHigher: function resolveHigher(loc) {\n      if (!loc.isEndpoint(this._linearGeom)) return loc;\n      var compIndex = loc.getComponentIndex();\n      if (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;\n\n      do {\n        compIndex++;\n      } while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);\n\n      return new LinearLocation(compIndex, 0, 0.0);\n    },\n    getLocation: function getLocation() {\n      if (arguments.length === 1) {\n        var length = arguments[0];\n        return this.getLocation(length, true);\n      } else if (arguments.length === 2) {\n        var _length = arguments[0],\n            resolveLower = arguments[1];\n        var forwardLength = _length;\n\n        if (_length < 0.0) {\n          var lineLen = this._linearGeom.getLength();\n\n          forwardLength = lineLen + _length;\n        }\n\n        var loc = this.getLocationForward(forwardLength);\n\n        if (resolveLower) {\n          return loc;\n        }\n\n        return this.resolveHigher(loc);\n      }\n    },\n    getLocationForward: function getLocationForward(length) {\n      if (length <= 0.0) return new LinearLocation();\n      var totalLength = 0.0;\n      var it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (it.isEndOfLine()) {\n          if (totalLength === length) {\n            var compIndex = it.getComponentIndex();\n            var segIndex = it.getVertexIndex();\n            return new LinearLocation(compIndex, segIndex, 0.0);\n          }\n        } else {\n          var p0 = it.getSegmentStart();\n          var p1 = it.getSegmentEnd();\n          var segLen = p1.distance(p0);\n\n          if (totalLength + segLen > length) {\n            var frac = (length - totalLength) / segLen;\n            var compIndex = it.getComponentIndex();\n            var segIndex = it.getVertexIndex();\n            return new LinearLocation(compIndex, segIndex, frac);\n          }\n\n          totalLength += segLen;\n        }\n\n        it.next();\n      }\n\n      return LinearLocation.getEndLocation(this._linearGeom);\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LengthLocationMap;\n    }\n  });\n\n  LengthLocationMap.getLength = function (linearGeom, loc) {\n    var locater = new LengthLocationMap(linearGeom);\n    return locater.getLength(loc);\n  };\n\n  LengthLocationMap.getLocation = function () {\n    if (arguments.length === 2) {\n      var linearGeom = arguments[0],\n          length = arguments[1];\n      var locater = new LengthLocationMap(linearGeom);\n      return locater.getLocation(length);\n    } else if (arguments.length === 3) {\n      var _linearGeom = arguments[0],\n          _length2 = arguments[1],\n          resolveLower = arguments[2];\n      var locater = new LengthLocationMap(_linearGeom);\n      return locater.getLocation(_length2, resolveLower);\n    }\n  };\n\n  function LengthIndexedLine() {\n    this._linearGeom = null;\n    var linearGeom = arguments[0];\n    this._linearGeom = linearGeom;\n  }\n  extend(LengthIndexedLine.prototype, {\n    clampIndex: function clampIndex(index) {\n      var posIndex = this.positiveIndex(index);\n      var startIndex = this.getStartIndex();\n      if (posIndex < startIndex) return startIndex;\n      var endIndex = this.getEndIndex();\n      if (posIndex > endIndex) return endIndex;\n      return posIndex;\n    },\n    locationOf: function locationOf() {\n      if (arguments.length === 1) {\n        var index = arguments[0];\n        return LengthLocationMap.getLocation(this._linearGeom, index);\n      } else if (arguments.length === 2) {\n        var _index = arguments[0],\n            resolveLower = arguments[1];\n        return LengthLocationMap.getLocation(this._linearGeom, _index, resolveLower);\n      }\n    },\n    project: function project(pt) {\n      return LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n    },\n    positiveIndex: function positiveIndex(index) {\n      if (index >= 0.0) return index;\n      return this._linearGeom.getLength() + index;\n    },\n    extractPoint: function extractPoint() {\n      if (arguments.length === 1) {\n        var index = arguments[0];\n        var loc = LengthLocationMap.getLocation(this._linearGeom, index);\n        return loc.getCoordinate(this._linearGeom);\n      } else if (arguments.length === 2) {\n        var _index2 = arguments[0],\n            offsetDistance = arguments[1];\n        var loc = LengthLocationMap.getLocation(this._linearGeom, _index2);\n        var locLow = loc.toLowest(this._linearGeom);\n        return locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n      }\n    },\n    isValidIndex: function isValidIndex(index) {\n      return index >= this.getStartIndex() && index <= this.getEndIndex();\n    },\n    getEndIndex: function getEndIndex() {\n      return this._linearGeom.getLength();\n    },\n    getStartIndex: function getStartIndex() {\n      return 0.0;\n    },\n    indexOfAfter: function indexOfAfter(pt, minIndex) {\n      return LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n    },\n    extractLine: function extractLine(startIndex, endIndex) {\n      var lil = new LocationIndexedLine(this._linearGeom);\n      var startIndex2 = this.clampIndex(startIndex);\n      var endIndex2 = this.clampIndex(endIndex);\n      var resolveStartLower = startIndex2 === endIndex2;\n      var startLoc = this.locationOf(startIndex2, resolveStartLower);\n      var endLoc = this.locationOf(endIndex2);\n      return ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);\n    },\n    indexOf: function indexOf(pt) {\n      return LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n    },\n    indicesOf: function indicesOf(subLine) {\n      var locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n      var index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];\n      return index;\n    },\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return LengthIndexedLine;\n    }\n  });\n\n\n\n  var linearref = /*#__PURE__*/Object.freeze({\n    LengthIndexedLine: LengthIndexedLine,\n    LengthLocationMap: LengthLocationMap,\n    LinearGeometryBuilder: LinearGeometryBuilder,\n    LinearIterator: LinearIterator,\n    LinearLocation: LinearLocation,\n    LocationIndexedLine: LocationIndexedLine\n  });\n\n  function UnionOp() {}\n  extend(UnionOp.prototype, {\n    interfaces_: function interfaces_() {\n      return [];\n    },\n    getClass: function getClass() {\n      return UnionOp;\n    }\n  });\n\n  UnionOp.union = function (g, other) {\n    if (g.isEmpty() || other.isEmpty()) {\n      if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n      if (g.isEmpty()) return other.copy();\n      if (other.isEmpty()) return g.copy();\n    }\n\n    g.checkNotGeometryCollection(g);\n    g.checkNotGeometryCollection(other);\n    return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n  };\n\n  extend(Geometry.prototype, {\n    equalsTopo: function equalsTopo(g) {\n      if (!this.getEnvelopeInternal().equals(g.getEnvelopeInternal())) return false;\n      return RelateOp.relate(this, g).isEquals(this.getDimension(), g.getDimension());\n    },\n    union: function union() {\n      if (arguments.length === 0) {\n        return UnaryUnionOp.union(this);\n      } else if (arguments.length === 1) {\n        var other = arguments[0];\n        return UnionOp.union(this, other);\n      }\n    },\n    isValid: function isValid() {\n      return IsValidOp.isValid(this);\n    },\n    intersection: function intersection(other) {\n      if (this.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, this, other, this._factory);\n\n      if (this.isGeometryCollection()) {\n        var g2 = other;\n        return GeometryCollectionMapper.map(this, {\n          interfaces_: function interfaces_() {\n            return [MapOp];\n          },\n          map: function map(g) {\n            return g.intersection(g2);\n          }\n        });\n      }\n\n      this.checkNotGeometryCollection(this);\n      this.checkNotGeometryCollection(other);\n      return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.INTERSECTION);\n    },\n    covers: function covers(g) {\n      return RelateOp.covers(this, g);\n    },\n    coveredBy: function coveredBy(g) {\n      return RelateOp.covers(g, this);\n    },\n    touches: function touches(g) {\n      return RelateOp.touches(this, g);\n    },\n    intersects: function intersects(g) {\n      return RelateOp.intersects(this, g);\n    },\n    within: function within(g) {\n      return RelateOp.contains(g, this);\n    },\n    overlaps: function overlaps(g) {\n      return RelateOp.overlaps(this, g);\n    },\n    disjoint: function disjoint(g) {\n      return RelateOp.disjoint(this, g);\n    },\n    crosses: function crosses(g) {\n      return RelateOp.crosses(this, g);\n    },\n    buffer: function buffer() {\n      if (arguments.length === 1) {\n        var distance = arguments[0];\n        return BufferOp.bufferOp(this, distance);\n      } else if (arguments.length === 2) {\n        var _distance = arguments[0],\n            quadrantSegments = arguments[1];\n        return BufferOp.bufferOp(this, _distance, quadrantSegments);\n      } else if (arguments.length === 3) {\n        var _distance2 = arguments[0],\n            _quadrantSegments = arguments[1],\n            endCapStyle = arguments[2];\n        return BufferOp.bufferOp(this, _distance2, _quadrantSegments, endCapStyle);\n      }\n    },\n    convexHull: function convexHull() {\n      return new ConvexHull(this).getConvexHull();\n    },\n    relate: function relate() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (arguments.length === 1) {\n        var geometry = arguments[0];\n        return RelateOp.relate(this, geometry);\n      } else if (arguments.length === 2) {\n        var _geometry = arguments[0],\n            intersectionPattern = arguments[1];\n        return RelateOp.relate(this, _geometry).matches(intersectionPattern);\n      }\n    },\n    getCentroid: function getCentroid() {\n      if (this.isEmpty()) return this._factory.createPoint();\n      var centPt = Centroid.getCentroid(this);\n      return this.createPointFromInternalCoord(centPt, this);\n    },\n    getInteriorPoint: function getInteriorPoint() {\n      if (this.isEmpty()) return this._factory.createPoint();\n      var interiorPt = null;\n      var dim = this.getDimension();\n\n      if (dim === 0) {\n        var intPt = new InteriorPointPoint(this);\n        interiorPt = intPt.getInteriorPoint();\n      } else if (dim === 1) {\n        var intPt = new InteriorPointLine(this);\n        interiorPt = intPt.getInteriorPoint();\n      } else {\n        var intPt = new InteriorPointArea(this);\n        interiorPt = intPt.getInteriorPoint();\n      }\n\n      return this.createPointFromInternalCoord(interiorPt, this);\n    },\n    symDifference: function symDifference(other) {\n      if (this.isEmpty() || other.isEmpty()) {\n        if (this.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, this, other, this._factory);\n        if (this.isEmpty()) return other.copy();\n        if (other.isEmpty()) return this.copy();\n      }\n\n      this.checkNotGeometryCollection(this);\n      this.checkNotGeometryCollection(other);\n      return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.SYMDIFFERENCE);\n    },\n    createPointFromInternalCoord: function createPointFromInternalCoord(coord, exemplar) {\n      exemplar.getPrecisionModel().makePrecise(coord);\n      return exemplar.getFactory().createPoint(coord);\n    },\n    toText: function toText() {\n      var writer = new WKTWriter();\n      return writer.write(this);\n    },\n    toString: function toString() {\n      this.toText();\n    },\n    contains: function contains(g) {\n      return RelateOp.contains(this, g);\n    },\n    difference: function difference(other) {\n      if (this.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, this, other, this._factory);\n      if (other.isEmpty()) return this.copy();\n      this.checkNotGeometryCollection(this);\n      this.checkNotGeometryCollection(other);\n      return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.DIFFERENCE);\n    },\n    isSimple: function isSimple() {\n      var op = new IsSimpleOp(this);\n      return op.isSimple();\n    },\n    isWithinDistance: function isWithinDistance(geom, distance) {\n      var envDist = this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());\n      if (envDist > distance) return false;\n      return DistanceOp.isWithinDistance(this, geom, distance);\n    },\n    distance: function distance(g) {\n      return DistanceOp.distance(this, g);\n    },\n    isEquivalentClass: function isEquivalentClass(other) {\n      return this.getClass() === other.getClass();\n    }\n  });\n\n  var version = '1.6.2 (258b53b)';\n\n  exports.version = version;\n  exports.algorithm = algorithm;\n  exports.densify = densify;\n  exports.dissolve = dissolve;\n  exports.geom = geom;\n  exports.geomgraph = geomgraph;\n  exports.index = index;\n  exports.io = io;\n  exports.noding = noding;\n  exports.operation = operation;\n  exports.precision = precision;\n  exports.simplify = simplify;\n  exports.triangulate = triangulate;\n  exports.linearref = linearref;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=jsts.js.map\n"],"sourceRoot":"webpack:///"}
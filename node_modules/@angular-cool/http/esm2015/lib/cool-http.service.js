/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { HttpHeader } from './http-header.model';
import { CookieStore } from './cookie-store.service';
import { HttpError } from './http-error.model';
import { DEFAULT_REQUEST_OPTIONS } from './request-options.interface';
import { from } from 'rxjs';
/**
 * @record
 * @template T, T1, T2, TResult
 */
export function Func() { }
function Func_tsickle_Closure_declarations() {
    /* TODO: handle strange member:
    (item: T, item1: T1, item2: T2): TResult;
    */
}
export class CoolHttp {
    /**
     * @param {?} _http
     */
    constructor(_http) {
        this._http = _http;
        this._cookieStore = new CookieStore();
        this._globalHeaders = [];
        this._requestInterceptors = [];
        this._responseInterceptors = [];
        this._customCookieToHeaders = [];
    }
    /**
     * @return {?}
     */
    get baseUrl() {
        return this._baseUrl;
    }
    /**
     * @param {?} baseUrl
     * @return {?}
     */
    registerBaseUrl(baseUrl) {
        this._baseUrl = baseUrl;
        if (this._baseUrl[this._baseUrl.length - 1] !== '/') {
            this._baseUrl += '/';
        }
    }
    /**
     * @return {?}
     */
    deRegisterBaseUrl() {
        this._baseUrl = null;
    }
    /**
     * @param {?} status
     * @return {?}
     */
    setWithCredentials(status) {
        this._withCredentials = status;
    }
    /**
     * @param {?} header
     * @return {?}
     */
    registerGlobalHeader(header) {
        this.deregisterGlobalHeader(header.key);
        this._globalHeaders.push(header);
    }
    /**
     * @return {?}
     */
    getGlobalHeaders() {
        return this._globalHeaders;
    }
    /**
     * @param {?} headerKey
     * @return {?}
     */
    deregisterGlobalHeader(headerKey) {
        const /** @type {?} */ indexOfHeader = this._globalHeaders.findIndex(header => header.key === headerKey);
        if (indexOfHeader === -1) {
            return false;
        }
        this._globalHeaders.splice(indexOfHeader, 1);
        return true;
    }
    /**
     * @return {?}
     */
    removeAllRegisteredGlobalHeaders() {
        this._globalHeaders.length = 0;
    }
    /**
     * @param {?} requestInterceptor
     * @return {?}
     */
    registerRequestInterceptor(requestInterceptor) {
        this._requestInterceptors.push(requestInterceptor);
    }
    /**
     * @param {?} requestInterceptor
     * @return {?}
     */
    deregisterRequestInterceptor(requestInterceptor) {
        let /** @type {?} */ indexOfItem = this._requestInterceptors.indexOf(requestInterceptor);
        if (indexOfItem === -1) {
            return false;
        }
        this._requestInterceptors.splice(indexOfItem, 1);
        return true;
    }
    /**
     * @param {?} responseInterceptor
     * @return {?}
     */
    registerResponseInterceptor(responseInterceptor) {
        this._responseInterceptors.push(responseInterceptor);
    }
    /**
     * @param {?} responseInterceptor
     * @return {?}
     */
    deregisterResponseInterceptor(responseInterceptor) {
        let /** @type {?} */ indexOfItem = this._responseInterceptors.indexOf(responseInterceptor);
        if (indexOfItem === -1) {
            return false;
        }
        this._responseInterceptors.splice(indexOfItem, 1);
        return true;
    }
    /**
     * @param {?} cookieName
     * @param {?} customHeaderName
     * @return {?}
     */
    sendCookieValueInCustomHeader(cookieName, customHeaderName) {
        this._customCookieToHeaders.push({
            cookieName: cookieName,
            customHeaderName: customHeaderName
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    getAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'GET', null, options, (url, data, modOptions) => {
                return that._http.get(url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    postAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'POST', data, options, (url, data, modOptions) => {
                return that._http.post(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    putAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'PUT', data, options, (url, data, modOptions) => {
                return that._http.put(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    deleteAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'DELETE', null, options, (url, data, modOptions) => {
                return that._http['delete'](url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    patchAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'PATCH', data, options, (url, data, modOptions) => {
                return that._http.patch(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    headAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'HEAD', null, options, (url, data, modOptions) => {
                return that._http.head(url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} options
     * @param {?} action
     * @return {?}
     */
    _requestCoreAsync(url, method, data, options, action) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            url = this._convertUrl(url);
            const /** @type {?} */ modifiedOptions = this._modifyOptions(options);
            let /** @type {?} */ clientHeaders = this._convertAngularHeadersToHttpClientHeaders(/** @type {?} */ (modifiedOptions.headers));
            let /** @type {?} */ shouldIntercept = yield this._invokeRequestInterceptorsAsync(url, method, data, clientHeaders);
            if (shouldIntercept) {
                return;
            }
            modifiedOptions.headers = this._updateAngularHeadersFromHttpClientHeaders(clientHeaders, /** @type {?} */ (modifiedOptions.headers));
            let /** @type {?} */ response;
            try {
                response = yield action(url, data, modifiedOptions).toPromise();
            }
            catch (/** @type {?} */ errorResponse) {
                response = errorResponse;
            }
            shouldIntercept = yield this._invokeResponseInterceptorsAsync(response, url, method, data, clientHeaders);
            if (shouldIntercept) {
                return;
            }
            if (!response.ok) {
                throw new HttpError(method, url, response.status, response.statusText, JSON.stringify(response.body));
            }
            let /** @type {?} */ returnValue;
            try {
                returnValue = JSON.parse(response.body);
            }
            catch (/** @type {?} */ e) {
                returnValue = { data: response.body };
            }
            return /** @type {?} */ (returnValue);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    getObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'GET', null, options, (url, data, modOptions) => {
            return that._http.get(url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    postObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'POST', data, options, (url, data, modOptions) => {
            return that._http.post(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    putObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'PUT', data, options, (url, data, modOptions) => {
            return that._http.put(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    deleteObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'DELETE', null, options, (url, data, modOptions) => {
            return that._http['delete'](url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    patchObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'PATCH', data, options, (url, data, modOptions) => {
            return that._http.patch(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    headObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'HEAD', null, options, (url, data, modOptions) => {
            return that._http.head(url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} options
     * @param {?} action
     * @return {?}
     */
    _requestCoreObservable(url, method, data, options, action) {
        return from(this._requestCoreAsync(url, method, data, options, action));
    }
    /**
     * @param {?} url
     * @return {?}
     */
    _convertUrl(url) {
        let /** @type {?} */ returnUrl = url;
        if (this._baseUrl) {
            returnUrl = this._baseUrl + returnUrl;
        }
        return returnUrl;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    _modifyOptions(options) {
        const /** @type {?} */ resultOptions = {
            headers: options.headers || new HttpHeaders(),
            observe: 'response',
            params: options.params,
            reportProgress: options.reportProgress,
            responseType: 'text',
            withCredentials: options.withCredentials || this._withCredentials,
        };
        options.headers = options.headers || new HttpHeaders();
        resultOptions.headers = this._appendGlobalHeaders(/** @type {?} */ (resultOptions.headers));
        resultOptions.headers = this._tryAppendRegisteredCookiesToCustomHeaders(/** @type {?} */ (resultOptions.headers));
        return resultOptions;
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _appendGlobalHeaders(headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ registeredHeader of this._globalHeaders) {
            newHeaders = headers.set(registeredHeader.key, registeredHeader.value);
        }
        return newHeaders;
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _tryAppendRegisteredCookiesToCustomHeaders(headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ cookieToHeader of this._customCookieToHeaders) {
            const /** @type {?} */ cookieValue = this._cookieStore.getCookie(cookieToHeader.cookieName);
            if (cookieValue) {
                newHeaders = headers.set(cookieToHeader.customHeaderName, cookieValue);
            }
        }
        return newHeaders;
    }
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} headers
     * @return {?}
     */
    _invokeRequestInterceptorsAsync(url, method, data, headers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const /** @type {?} */ requestInterceptor of this._requestInterceptors) {
                const /** @type {?} */ shouldIntercept = yield requestInterceptor.beforeRequestAsync(url, method, data, headers);
                if (shouldIntercept) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * @param {?} response
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} headers
     * @return {?}
     */
    _invokeResponseInterceptorsAsync(response, url, method, data, headers) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (const /** @type {?} */ responseInterceptor of this._responseInterceptors) {
                const /** @type {?} */ shouldIntercept = yield responseInterceptor.afterResponseAsync(response, url, method, data, headers);
                if (shouldIntercept) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _convertAngularHeadersToHttpClientHeaders(headers) {
        return headers.keys().map(headerKey => {
            const /** @type {?} */ httpClientHeader = new HttpHeader();
            httpClientHeader.key = headerKey;
            httpClientHeader.value = headers.get(headerKey);
            return httpClientHeader;
        });
    }
    /**
     * @param {?} httpClientHeaders
     * @param {?} headers
     * @return {?}
     */
    _updateAngularHeadersFromHttpClientHeaders(httpClientHeaders, headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ clientHeader of httpClientHeaders) {
            const /** @type {?} */ headerValue = headers.get(clientHeader.key);
            if (headerValue !== clientHeader.value) {
                newHeaders = headers.set(clientHeader.key, clientHeader.value);
            }
        }
        return newHeaders;
    }
}
CoolHttp.decorators = [
    { type: Injectable },
];
/** @nocollapse */
CoolHttp.ctorParameters = () => [
    { type: HttpClient, },
];
function CoolHttp_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    CoolHttp.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    CoolHttp.ctorParameters;
    /** @type {?} */
    CoolHttp.prototype._cookieStore;
    /** @type {?} */
    CoolHttp.prototype._globalHeaders;
    /** @type {?} */
    CoolHttp.prototype._requestInterceptors;
    /** @type {?} */
    CoolHttp.prototype._responseInterceptors;
    /** @type {?} */
    CoolHttp.prototype._customCookieToHeaders;
    /** @type {?} */
    CoolHttp.prototype._baseUrl;
    /** @type {?} */
    CoolHttp.prototype._withCredentials;
    /** @type {?} */
    CoolHttp.prototype._http;
}
//# sourceMappingURL=cool-http.service.js.map

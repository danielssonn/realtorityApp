import { __awaiter } from 'tslib';
import { Injectable, NgModule } from '@angular/core';
import { HttpClient, HttpHeaders, HttpClientModule } from '@angular/common/http';
import { from } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CookieStore {
    /**
     * @param {?} key
     * @return {?}
     */
    getCookie(key) {
        let /** @type {?} */ cookieCollection = this.getCookieCollection();
        return cookieCollection[key];
    }
    /**
     * @return {?}
     */
    getCookieCollection() {
        let /** @type {?} */ currentRawCookie = document.cookie;
        if (currentRawCookie === this.lastReadRawCookieCollection) {
            return this.lastReadCookieCollection;
        }
        this.lastReadRawCookieCollection = currentRawCookie;
        this.lastReadCookieCollection = {};
        if (this.lastReadRawCookieCollection.indexOf('; ') !== -1) {
            let /** @type {?} */ cookies = this.lastReadRawCookieCollection.split('; ');
            for (let /** @type {?} */ cookie of cookies) {
                let /** @type {?} */ indexOfEqualSign = cookie.indexOf('=');
                if (indexOfEqualSign > 0) {
                    let /** @type {?} */ cookieName = CookieStore.tryDecodeUriComponent(cookie.substring(0, indexOfEqualSign));
                    this.lastReadCookieCollection[cookieName] = CookieStore.tryDecodeUriComponent(cookie.substring(indexOfEqualSign + 1));
                }
            }
        }
        return this.lastReadCookieCollection;
    }
    /**
     * @param {?} uriComponent
     * @return {?}
     */
    static tryDecodeUriComponent(uriComponent) {
        try {
            return decodeURIComponent(uriComponent);
        }
        catch (/** @type {?} */ e) {
            return uriComponent;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class HttpHeader {
    /**
     * @param {?=} key
     * @param {?=} value
     */
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class HttpError extends Error {
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} status
     * @param {?} statusText
     * @param {?} body
     */
    constructor(method, url, status, statusText, body) {
        super(`Failed to call api ${method} ${url}, status code: ${status}`);
        this.method = method;
        this.url = url;
        this.status = status;
        this.statusText = statusText;
        this.body = body;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, new.target.prototype);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DEFAULT_REQUEST_OPTIONS = {};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CoolHttp {
    /**
     * @param {?} _http
     */
    constructor(_http) {
        this._http = _http;
        this._cookieStore = new CookieStore();
        this._globalHeaders = [];
        this._requestInterceptors = [];
        this._responseInterceptors = [];
        this._customCookieToHeaders = [];
    }
    /**
     * @return {?}
     */
    get baseUrl() {
        return this._baseUrl;
    }
    /**
     * @param {?} baseUrl
     * @return {?}
     */
    registerBaseUrl(baseUrl) {
        this._baseUrl = baseUrl;
        if (this._baseUrl[this._baseUrl.length - 1] !== '/') {
            this._baseUrl += '/';
        }
    }
    /**
     * @return {?}
     */
    deRegisterBaseUrl() {
        this._baseUrl = null;
    }
    /**
     * @param {?} status
     * @return {?}
     */
    setWithCredentials(status) {
        this._withCredentials = status;
    }
    /**
     * @param {?} header
     * @return {?}
     */
    registerGlobalHeader(header) {
        this.deregisterGlobalHeader(header.key);
        this._globalHeaders.push(header);
    }
    /**
     * @return {?}
     */
    getGlobalHeaders() {
        return this._globalHeaders;
    }
    /**
     * @param {?} headerKey
     * @return {?}
     */
    deregisterGlobalHeader(headerKey) {
        const /** @type {?} */ indexOfHeader = this._globalHeaders.findIndex(header => header.key === headerKey);
        if (indexOfHeader === -1) {
            return false;
        }
        this._globalHeaders.splice(indexOfHeader, 1);
        return true;
    }
    /**
     * @return {?}
     */
    removeAllRegisteredGlobalHeaders() {
        this._globalHeaders.length = 0;
    }
    /**
     * @param {?} requestInterceptor
     * @return {?}
     */
    registerRequestInterceptor(requestInterceptor) {
        this._requestInterceptors.push(requestInterceptor);
    }
    /**
     * @param {?} requestInterceptor
     * @return {?}
     */
    deregisterRequestInterceptor(requestInterceptor) {
        let /** @type {?} */ indexOfItem = this._requestInterceptors.indexOf(requestInterceptor);
        if (indexOfItem === -1) {
            return false;
        }
        this._requestInterceptors.splice(indexOfItem, 1);
        return true;
    }
    /**
     * @param {?} responseInterceptor
     * @return {?}
     */
    registerResponseInterceptor(responseInterceptor) {
        this._responseInterceptors.push(responseInterceptor);
    }
    /**
     * @param {?} responseInterceptor
     * @return {?}
     */
    deregisterResponseInterceptor(responseInterceptor) {
        let /** @type {?} */ indexOfItem = this._responseInterceptors.indexOf(responseInterceptor);
        if (indexOfItem === -1) {
            return false;
        }
        this._responseInterceptors.splice(indexOfItem, 1);
        return true;
    }
    /**
     * @param {?} cookieName
     * @param {?} customHeaderName
     * @return {?}
     */
    sendCookieValueInCustomHeader(cookieName, customHeaderName) {
        this._customCookieToHeaders.push({
            cookieName: cookieName,
            customHeaderName: customHeaderName
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    getAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'GET', null, options, (url, data, modOptions) => {
                return that._http.get(url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    postAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'POST', data, options, (url, data, modOptions) => {
                return that._http.post(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    putAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'PUT', data, options, (url, data, modOptions) => {
                return that._http.put(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    deleteAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'DELETE', null, options, (url, data, modOptions) => {
                return that._http['delete'](url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} data
     * @param {?=} options
     * @return {?}
     */
    patchAsync(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'PATCH', data, options, (url, data, modOptions) => {
                return that._http.patch(url, data, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    headAsync(url, options = DEFAULT_REQUEST_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            let /** @type {?} */ that = this;
            return yield that._requestCoreAsync(url, 'HEAD', null, options, (url, data, modOptions) => {
                return that._http.head(url, modOptions);
            });
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} options
     * @param {?} action
     * @return {?}
     */
    _requestCoreAsync(url, method, data, options, action) {
        return __awaiter(this, void 0, void 0, function* () {
            url = this._convertUrl(url);
            const /** @type {?} */ modifiedOptions = this._modifyOptions(options);
            let /** @type {?} */ clientHeaders = this._convertAngularHeadersToHttpClientHeaders(/** @type {?} */ (modifiedOptions.headers));
            let /** @type {?} */ shouldIntercept = yield this._invokeRequestInterceptorsAsync(url, method, data, clientHeaders);
            if (shouldIntercept) {
                return;
            }
            modifiedOptions.headers = this._updateAngularHeadersFromHttpClientHeaders(clientHeaders, /** @type {?} */ (modifiedOptions.headers));
            let /** @type {?} */ response;
            try {
                response = yield action(url, data, modifiedOptions).toPromise();
            }
            catch (/** @type {?} */ errorResponse) {
                response = errorResponse;
            }
            shouldIntercept = yield this._invokeResponseInterceptorsAsync(response, url, method, data, clientHeaders);
            if (shouldIntercept) {
                return;
            }
            if (!response.ok) {
                throw new HttpError(method, url, response.status, response.statusText, JSON.stringify(response.body));
            }
            let /** @type {?} */ returnValue;
            try {
                returnValue = JSON.parse(response.body);
            }
            catch (/** @type {?} */ e) {
                returnValue = { data: response.body };
            }
            return /** @type {?} */ (returnValue);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    getObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'GET', null, options, (url, data, modOptions) => {
            return that._http.get(url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    postObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'POST', data, options, (url, data, modOptions) => {
            return that._http.post(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    putObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'PUT', data, options, (url, data, modOptions) => {
            return that._http.put(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    deleteObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'DELETE', null, options, (url, data, modOptions) => {
            return that._http['delete'](url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    patchObservable(url, data, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'PATCH', data, options, (url, data, modOptions) => {
            return that._http.patch(url, data, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    headObservable(url, options = DEFAULT_REQUEST_OPTIONS) {
        let /** @type {?} */ that = this;
        return that._requestCoreObservable(url, 'HEAD', null, options, (url, data, modOptions) => {
            return that._http.head(url, modOptions);
        });
    }
    /**
     * @template T
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} options
     * @param {?} action
     * @return {?}
     */
    _requestCoreObservable(url, method, data, options, action) {
        return from(this._requestCoreAsync(url, method, data, options, action));
    }
    /**
     * @param {?} url
     * @return {?}
     */
    _convertUrl(url) {
        let /** @type {?} */ returnUrl = url;
        if (this._baseUrl) {
            returnUrl = this._baseUrl + returnUrl;
        }
        return returnUrl;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    _modifyOptions(options) {
        const /** @type {?} */ resultOptions = {
            headers: options.headers || new HttpHeaders(),
            observe: 'response',
            params: options.params,
            reportProgress: options.reportProgress,
            responseType: 'text',
            withCredentials: options.withCredentials || this._withCredentials,
        };
        options.headers = options.headers || new HttpHeaders();
        resultOptions.headers = this._appendGlobalHeaders(/** @type {?} */ (resultOptions.headers));
        resultOptions.headers = this._tryAppendRegisteredCookiesToCustomHeaders(/** @type {?} */ (resultOptions.headers));
        return resultOptions;
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _appendGlobalHeaders(headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ registeredHeader of this._globalHeaders) {
            newHeaders = headers.set(registeredHeader.key, registeredHeader.value);
        }
        return newHeaders;
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _tryAppendRegisteredCookiesToCustomHeaders(headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ cookieToHeader of this._customCookieToHeaders) {
            const /** @type {?} */ cookieValue = this._cookieStore.getCookie(cookieToHeader.cookieName);
            if (cookieValue) {
                newHeaders = headers.set(cookieToHeader.customHeaderName, cookieValue);
            }
        }
        return newHeaders;
    }
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} headers
     * @return {?}
     */
    _invokeRequestInterceptorsAsync(url, method, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const /** @type {?} */ requestInterceptor of this._requestInterceptors) {
                const /** @type {?} */ shouldIntercept = yield requestInterceptor.beforeRequestAsync(url, method, data, headers);
                if (shouldIntercept) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * @param {?} response
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?} headers
     * @return {?}
     */
    _invokeResponseInterceptorsAsync(response, url, method, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const /** @type {?} */ responseInterceptor of this._responseInterceptors) {
                const /** @type {?} */ shouldIntercept = yield responseInterceptor.afterResponseAsync(response, url, method, data, headers);
                if (shouldIntercept) {
                    return true;
                }
            }
            return false;
        });
    }
    /**
     * @param {?} headers
     * @return {?}
     */
    _convertAngularHeadersToHttpClientHeaders(headers) {
        return headers.keys().map(headerKey => {
            const /** @type {?} */ httpClientHeader = new HttpHeader();
            httpClientHeader.key = headerKey;
            httpClientHeader.value = headers.get(headerKey);
            return httpClientHeader;
        });
    }
    /**
     * @param {?} httpClientHeaders
     * @param {?} headers
     * @return {?}
     */
    _updateAngularHeadersFromHttpClientHeaders(httpClientHeaders, headers) {
        let /** @type {?} */ newHeaders = headers;
        for (const /** @type {?} */ clientHeader of httpClientHeaders) {
            const /** @type {?} */ headerValue = headers.get(clientHeader.key);
            if (headerValue !== clientHeader.value) {
                newHeaders = headers.set(clientHeader.key, clientHeader.value);
            }
        }
        return newHeaders;
    }
}
CoolHttp.decorators = [
    { type: Injectable },
];
/** @nocollapse */
CoolHttp.ctorParameters = () => [
    { type: HttpClient, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CoolHttpModule {
    /**
     * @deprecated
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CoolHttpModule,
            providers: []
        };
    }
}
CoolHttpModule.decorators = [
    { type: NgModule, args: [{
                exports: [],
                imports: [HttpClientModule],
                providers: [CoolHttp]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { CookieStore, CoolHttp, HttpHeader, HttpError, DEFAULT_REQUEST_OPTIONS, CoolHttpModule };
//# sourceMappingURL=angular-cool-http.js.map
